<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【CS144-2021】计算机网络</title>
      <link href="c-c/0557084365cd.html"/>
      <url>c-c/0557084365cd.html</url>
      
        <content type="html"><![CDATA[<h2 id="【CS144-2021】计算机网络"><a href="#【CS144-2021】计算机网络" class="headerlink" title="【CS144-2021】计算机网络"></a>【CS144-2021】计算机网络</h2><ul><li>2019 Fall：<a href="https://kangyupl.gitee.io/cs144.github.io/">https://kangyupl.gitee.io/cs144.github.io/</a></li><li>2020 Fall：<a href="https://github.com/lawliet9712/Stanford-CS144-2021">https://github.com/lawliet9712/Stanford-CS144-2021</a></li><li>【推荐】2021 Fall：<a href="https://github.com/Kiprey/sponge">https://github.com/Kiprey/sponge</a></li></ul><blockquote><p>前前后后弄了半个月，终于啃完 CS144 了，感谢 <a href="https://kiprey.github.io/tags/CS144/">K大博客</a>，大概弄懂了 80% 吧</p><p>源代码仓库：<a href="https://gitee.com/ericps/cs144-2021">https://gitee.com/ericps/cs144-2021</a></p></blockquote><h3 id="Linux-环境"><a href="#Linux-环境" class="headerlink" title="Linux 环境"></a>Linux 环境</h3><ul><li>Mac VirtualBox 安装 Ubuntu desktop 版：<a href="https://www.zhihu.com/tardis/zm/art/109808506">https://www.zhihu.com/tardis/zm/art/109808506</a></li><li>安装 ubuntu server 版：<a href="https://blog.csdn.net/weixin_46658699/article/details/114693006">https://blog.csdn.net/weixin_46658699/article/details/114693006</a></li><li>VirtualBox 增强工具（方便双向复制）：<a href="https://blog.csdn.net/zhu_1997/article/details/117814728">https://blog.csdn.net/zhu_1997/article/details/117814728</a></li><li>SSH 连接 VirtualBox Ubuntu 虚拟机：<a href="https://www.cnblogs.com/linxiaoxu/p/16260601.html">https://www.cnblogs.com/linxiaoxu/p/16260601.html</a></li><li>Ubuntu18.04 升级 gcc：<a href="https://blog.csdn.net/weixin_44128857/article/details/108554751">https://blog.csdn.net/weixin_44128857/article/details/108554751</a></li><li>Sponge 仓库 2021：<a href="https://gitee.com/ericps/cs144-2021">https://gitee.com/ericps/cs144-2021</a></li></ul><h3 id="Lab0-ByteStream"><a href="#Lab0-ByteStream" class="headerlink" title="Lab0: ByteStream"></a>Lab0: ByteStream</h3><ul><li>webget: 利用已有 API 获取网页</li><li>byte_stream: 实现一个有序字节流类（in-order byte stream），使之支持读写、容量控制。可以使用 std::dueue （双端开口）作为「可靠」字节流的底层。这个字节流类似于一个带容量的队列，从一头读，从另一头写。当流中的数据达到容量上限时，便无法再写入新的数据。特别的，写操作被分为了peek和pop两步。peek为从头部开始读取指定数量的字节，pop为弹出指定数量的字节。</li><li>string_view: <a href="https://blog.csdn.net/danshiming/article/details/122573151">https://blog.csdn.net/danshiming/article/details/122573151</a></li></ul><h3 id="Lab1-StreamReassembler"><a href="#Lab1-StreamReassembler" class="headerlink" title="Lab1: StreamReassembler"></a>Lab1: StreamReassembler</h3><ul><li>git 拉取远程所有分支到本地：<code>for i in git branch -r; do git checkout basename $i &amp;&amp; git pull --all; done</code></li><li>git 合并分支：<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6">参考</a></li><li>内含 ByteStream 没有默认的构造函数为啥可以直接定义，这里面没有设置 ByteStream 的 capacity？</li><li>不可靠的流失传输中每条数据可能 reorder、duplicate 等等，<strong>TCP 的功能就是使用不可靠的数据包提供可靠的字节流服务</strong>，因此需要实现「流重组器」来应对收到的乱序或者重复数据的情况，每条流带有一个 stream_index（类型是uint64_t，理解为不会 wrap），按照顺序重组字节流并送入指定的 ByteStream 中</li><li>实现使用 std::map&lt;size_t, std::string&gt; 存放那些还未重组的数据，维护下图中的 first_unassembled 即可，收到一个子串就会调用 push_substring，根据 map 中的内容重组 ByteStream，整个思路就是比较 stream_idx，找到比 stream_idx 小的第一个位置以及比 stream_idx 大的第一个位置（二分查找）</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/cd76c2fa742eb2544508c015b098fb5a.webp?x-oss-process=image/format,png" alt="reassembled"></p><h3 id="Lab2-TCPReceiver"><a href="#Lab2-TCPReceiver" class="headerlink" title="Lab2: TCPReceiver"></a>Lab2: TCPReceiver</h3><ul><li><p>make 出错：安装 libpcap-dev 库</p></li><li><p>三个索引：</p><ul><li>(relative) seqno：从 ISN 开始，包含 SYN 和 FIN，<strong>32 位循环计数</strong>（这也是 TCP Header 的一个字段）</li><li>absolute seqno：从 0 开始，包含 SYN 和 FIN，64 位非循环技术（为什么不会循环，pdf 给出了说明：Transmitting at 100 gigabits/sec, it would take almost 50 years to reach 2^64 bytes. By contrast, it takes only a third of a second to reach 2^32 bytes.）</li><li>stream_index：从 0 起步，排除 SYN 和 FIN，64 位非循环技术</li></ul></li><li><p>首先理解 wrapping_intergers 转换过程</p><ul><li>absolute seqno 转 seqno 比较简单：absolute seq 转 32 位之后直接和 isn 相加即可，溢出自动处理</li><li>seqno 转 absolute seqno 需要思考一下：需要利用上一次收到的 checkpoint <a href="https://zhuanlan.zhihu.com/p/464281077">参考</a></li></ul></li><li><p>实现 TCPReceiver</p><ul><li>segment_received()：该函数将会在每次获取到 TCP 报文被调用，完成两个功能<ul><li>如果接受到 SYN 包就设置 ISN 编号（SYN 和 FIN 包仍然可以携带用户数据并一同传输。同时，同一个数据包下既可以设置 SYN 标志也可以设置 FIN 标志。why ??? 有点不太理解）</li><li>将收到的数据直接丢进 stream reassembler，并在接收到 FIN 包时终止数据传输</li></ul></li><li>ackno() 返回接收方下一次期望接收到的字节索引，根据 ByteStream 已写字节数得到 absolute seqno （注意如果是 FIN 需要 ++），然后转换成 seqno 即可</li><li>window_size() 返回接受窗口的大小，也就是 capacity - ByteStream 的 BUFFER_SIZE，可以用于「<strong>流量控制</strong>」</li></ul></li></ul><h3 id="Lab3-TCPSender"><a href="#Lab3-TCPSender" class="headerlink" title="Lab3: TCPSender"></a>Lab3: TCPSender</h3><ul><li><p>TCPSender 需要将 ByteStream 中的数据以 TCP 报文形式持续发送给 receiver（利用写好的 TCPSegment 这个类填充其中的头部字段以及 payload 信息）</p></li><li><p>需要处理 TCPReceiver 传入的 ackno 和 window size，以追踪接收者当前的接收状态，以及检测丢包情况</p></li><li><p>若<strong>经过一个超时时间后</strong>仍然<strong>没有接收到 TCPReceiver 发送的针对某个数据包的 ack 包</strong>，则重传对应的原始数据包，主要这里的检测主要是通过 tick 函数实现，不需要使用 timer 相关的系统调用，tick 函数的入参就是上一次调用到现在的时间（ms），因此需要维护一次 全局计时器变量 timecount，另外采用“指数退避”的思想，每次超时之后 timeout *= 2，另外需要维护一个全局的重传次数 retans_count，如果某个报文连续重传次数达到 8 次需要发送 RST 报文终止连接（当然这个是在 Lab4 中实现的）</p></li><li><p>注意！！！remote_window_size 应该初始化为 1，否则如果「初始」就丢包的话 remote_window_size = 0 不会退避 timeout，另外接收方的 Windows size 为 0，发送方也将按照接收方 window size 为 1 的情况进行处理，持续发包。为了 keep alive</p><ul><li>退避的前提的是 window_size &gt; 0，接收方可以接收数据但是网络拥塞了导致还没有收到数据，超时一次超时时长会乘2 （实行网络拥塞控制）</li></ul></li><li><p>维护一个已经发送但未被确认的 segment 队列 std::queue&lt;std::pair&lt;size_t, TCPSegment&gt;&gt;， 如果 ack_receiver 是收到 ackno 以及 window_size 之后需要检查 queue 以及移除并 reset timer 相关变量</p><ul><li>相当于采取累计确认方式通过维护缓存队列重传</li><li>根据 ackno –&gt; abs_seq，如果 abs_seq &gt; _next_seqno 直接丢弃并返回，否则从头遍历 queue 移除那些已经确认的 segment</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/432d9d6c6eb29fca5c256156ab156498.png" alt="system"></p><h3 id="Lab4-TCPConnection"><a href="#Lab4-TCPConnection" class="headerlink" title="Lab4: TCPConnection"></a>Lab4: TCPConnection</h3><ul><li><p>TCPConnection 需要将 TCPSender 和 TCPReceiver 结合，实现成一个 TCP 终端，同时收发数据。</p></li><li><p>接受数据端：</p><ul><li><p>如果收到 RST 直接关闭连接，否则交给 TCPReceiver 处理，对其中各个字段解析</p></li><li><p>收到 ACK 需要向当前自己的 TCPConnection 的 TCPSender 对端的 ackno 和 window_size 信息</p><blockquote><p>这一步相当重要，因为数据包在网络中以乱序形式发送，因此远程发送给本地的 ackno 存在滞后性。将远程的 ackno 和 window size 附加至发送数据中可以降低这种滞后性，提高 TCP 效率。</p></blockquote></li></ul></li><li><p>发送数据端：</p><ul><li>当 TCPSender 从 ByteStream 读取数据组成一个 TCPSegment 放入待发送的队列时，TCPConnection 从其中取出并将其发送（push 到 _segment_out 队列即可）</li><li>在发送当前数据包之前，TCPConnection 会获取当前<strong>它自己的 TCPReceiver</strong> 的 ackno 和 window size（用来表示自己下一次期望接收到 seqno 以及自己的 window_size），将其放置进待发送 TCPSegment 中，并设置其 ACK 标志。</li></ul></li><li><p>TCPConnection 需要检测时间的流逝。它存在一个 tick 函数，该函数将会被操作系统持续调用。当 TCPConnection 的 tick 函数被调用后，它需要</p><ul><li>告诉 TCPSender 时间的流逝，让其重新发送丢失的数据包</li><li>如果 sender 的「连续重传次数」超过 TCPConfig::MAX RETX ATTEMPTS，发送一个 RST 包终止连接</li><li>考虑 TIME_WAIT 状态</li></ul></li><li><p>关闭连接</p><ul><li>接收方收到 RST 标志或者发送方发送 RST 标志后，设置当前 TCPConnection 的输入输出字节流的状态为<strong>错误状态</strong>，并<strong>立即</strong>停止退出。这种属于暴力退出（unclear shutdown），可能会导致<strong>尚未传输完成的数据丢失</strong>（例如仍然在网络中运输的数据包在<strong>接收方收到RST标志后</strong>被丢弃）。</li><li>若想让双方都在数据流收发完整后退出（clear shutdonw），考虑四次挥手，参考 K 大的博客</li></ul></li></ul><h3 id="Lab5-NetworkInterface"><a href="#Lab5-NetworkInterface" class="headerlink" title="Lab5: NetworkInterface"></a>Lab5: NetworkInterface</h3><ul><li><p>ARP 协议：根据 IP 地址获取 Mac 地址，实现简单的 ARP 协议</p></li><li><p>维护 ARP 条目哈希表，每个条目 TTL 为 30s，到期之后删除</p></li><li><p>send_datagram(dgram, next_hop) 时如果 ARP 表中没有 IP 地址对应的表项就广播发送（构造 ARPMessage 以及 Ethernet Frame TYPE_ARP），如果有的话就直接构造 Ethernet Frame TYPE_IPv4 将 dgram 发送</p></li><li><p>recv_frame(dgram) 首先判断是不是 frame 的 目的地址是不是 自己的Mac/广播地址，不是直接 丢弃</p><ul><li><p>TYPE_IPv4：收到 IP 数据包直接转发丢给上层</p><blockquote><p>为啥 recv_frame 为什么还可以收到 IPv4 的数据包呢？因为 ARP 数据包加上 Ethernet Frame Header 之后变成以太网帧在数据链路层传输，Frame 类型有很多，包括 IPv4、IPv6、ARP 等等，如果是 IPv4 数据包仅仅只需要转发给 caller 即可，因为作为数据链路层不需要管 TCP 状态、IP 字段等等其他信息</p></blockquote></li><li><p>TYPE_ARP：收到 ARP 包分为请求和应答两种情况处理</p><ul><li>请求：将自己的 Mac 封装之后发送，并且更新 ARP 表项</li><li>应答：更新 ARP 表项，并且检查 IP 请求列表，如果相符就 send_dgram，并删除对应的表项</li></ul></li></ul></li><li><p>tick(ms_since_last_tick) 删除过期的 ARP 表项以及 已经发送 dgram 表项</p></li></ul><h3 id="Lab6-Router"><a href="#Lab6-Router" class="headerlink" title="Lab6: Router"></a>Lab6: Router</h3><ul><li><p>router：实现简单的路由表，转发数据包，维护路由表（哈希表），最长匹配原则</p></li><li><p>add_route(route_prefix, prefix_length, next_hop, interface_num)：添加一条路由表项</p></li><li><p>route_one_datagram(dgram)：查询路由表，如果存在匹配项切 TTL &gt; 1 就转发给下一跳/直连，并将 TTL 减一，其余情况全部丢弃</p></li></ul><h3 id="Lab7"><a href="#Lab7" class="headerlink" title="Lab7"></a>Lab7</h3><ul><li><p>将之前所有内容合为一个 app</p><p><img src="https://img-blog.csdnimg.cn/img_convert/66d3477c735c6d338dd6124c54634f20.png"></p></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://csdiy.wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/">https://csdiy.wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/</a></li><li>K大博客：<a href="https://kiprey.github.io/tags/CS144/">https://kiprey.github.io/tags/CS144/</a></li><li>掘金博客： <a href="https://juejin.cn/user/822883244836461">https://juejin.cn/user/822883244836461</a></li><li>CS144-2019翻译：<a href="http://doraemonzzz.com/tags/CS144/">http://doraemonzzz.com/tags/CS144/</a></li><li>CS144-2019：<a href="https://blog.csdn.net/kangyupl/article/details/108589594">https://blog.csdn.net/kangyupl/article/details/108589594</a></li><li><a href="https://zhuanlan.zhihu.com/p/464281077">https://zhuanlan.zhihu.com/p/464281077</a></li><li><a href="https://gitee.com/dying1122/cs144-lab">https://gitee.com/dying1122/cs144-lab</a></li></ul><h3 id="我的CPP面试仓库笔记"><a href="#我的CPP面试仓库笔记" class="headerlink" title="我的CPP面试仓库笔记"></a>我的CPP面试仓库笔记</h3><ul><li><a href="https://github.com/EricPengShuai/Interview">https://github.com/EricPengShuai/Interview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【阅读笔记】Linux 高性能服务器编程</title>
      <link href="c-c/95309686d53e.html"/>
      <url>c-c/95309686d53e.html</url>
      
        <content type="html"><![CDATA[<h2 id="【阅读笔记】Linux-高性能服务器编程"><a href="#【阅读笔记】Linux-高性能服务器编程" class="headerlink" title="【阅读笔记】Linux 高性能服务器编程"></a>【阅读笔记】Linux 高性能服务器编程</h2><blockquote><p>原文地址以及相关代码参考：<a href="https://github.com/EricPengShuai/Interview/tree/main/Linux">https://github.com/EricPengShuai/Interview/tree/main/Linux</a></p></blockquote><h3 id="Ch-5-Linux-网络编程基础-API"><a href="#Ch-5-Linux-网络编程基础-API" class="headerlink" title="Ch.5 Linux 网络编程基础 API"></a>Ch.5 Linux 网络编程基础 API</h3><h4 id="5-1-socket-地址-API"><a href="#5-1-socket-地址-API" class="headerlink" title="5.1 socket 地址 API"></a>5.1 socket 地址 API</h4><h5 id="5-1-1-主机字节序和网络字节序"><a href="#5-1-1-主机字节序和网络字节序" class="headerlink" title="5.1.1 主机字节序和网络字节序"></a>5.1.1 主机字节序和网络字节序</h5><ul><li>大端字节序（网络字节序）：高位低地址</li><li>小端字节序（主机字节序）：高位高地址</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">union</span> <span class="token punctuation">{</span>    <span class="token keyword">short</span> value<span class="token punctuation">;</span>    <span class="token keyword">char</span> union_bytes<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> test<span class="token punctuation">;</span>test<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">0x0102</span><span class="token punctuation">;</span>test<span class="token punctuation">.</span>union_bytes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> test<span class="token punctuation">.</span>union_bytes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 大端</span>test<span class="token punctuation">.</span>union_bytes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> test<span class="token punctuation">.</span>union_bytes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 小端</span></code></pre><blockquote><p>参考代码：<a href="ch5/5-1byteorder.cpp">5-1byteorder.cpp</a></p></blockquote><p>一般网络编程中，发送端会将发送的数据转换成大端字节序数据后再发送，接收端这边根据自身采用的字节序决定是否对接受的数据进行转换（小端机转换，大端机不转），Linux 提供一下函数：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// h: host; n: network; l: long; s: short</span><span class="token comment">// long: 往往用来转换 IP; short: 往往用来转换 port</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netinet/in.h&gt;</span></span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">htonl</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> hostlong<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> hostshort<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token function">ntohl</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> netlong<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token function">ntohs</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> netshort<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="5-1-2-通用-socket-地址"><a href="#5-1-2-通用-socket-地址" class="headerlink" title="5.1.2 通用 socket 地址"></a>5.1.2 通用 socket 地址</h5><p>sockaddr 结构体表示 socket 地址</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/socket.h&gt;</span><span class="token comment">// &lt;sys/scoket.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token punctuation">{</span>    sa_family_t sa_family<span class="token punctuation">;</span><span class="token comment">// 常见的地址族有: AF_UNIX/AF_INET/AF_INET6</span>    <span class="token keyword">char</span> sa_data<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 存放 socket 地址值，不同的地址族地址值长度不同</span><span class="token punctuation">}</span></code></pre><p>地址族（address family）和协议族（protocol family）一一对应，两者是一样的，经常混用</p><ul><li>AF_*: AF_UNIX / AF_INET / AF_INET6</li><li>PF_*: PF_UNIX / PF_INET / PF_INET6</li></ul><p>UNIX 本地域协议族和 TCP/IPv6 协议族的地址值长度远远超过 14 字节，因为引入了一个新的通用 socket 地址结构体 sockaddr_storage，具体参考 P72</p><h5 id="5-1-3-专用-socket-地址"><a href="#5-1-3-专用-socket-地址" class="headerlink" title="5.1.3 专用 socket 地址"></a>5.1.3 专用 socket 地址</h5><p>上面的 sa_data 将 IP 地址和端口号混在一起，实际使用中经常使用 sockaddr_in 和 sockaddr_in6 结构体，分别针对于 AF_INET 和 AF_INET6 地址族</p><p>但是所有使用专用 socket 地址以及 sockaddr_storage 类型的变量在实际中又需要<strong>强制转换</strong>成通用的 socket 地址类型 sockaddr，因为所有的 socket 编程结构的地址参数类型都是 sockaddr</p><h5 id="5-1-4-IP-地址转换函数"><a href="#5-1-4-IP-地址转换函数" class="headerlink" title="5.1.4 IP 地址转换函数"></a>5.1.4 IP 地址转换函数</h5><p>Linux 提供三个「点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间转换」的接口</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>in_addr_t <span class="token function">inet_addr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> strptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 失败返回 INADDR_NONE</span><span class="token keyword">int</span> <span class="token function">inet_aton</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> cp<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">in_addr</span><span class="token operator">*</span> inp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 失败返回 0，成功返回 1</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">inet_ntoa</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">in_addr</span> in<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 逆向转换，注意该函数的不可重入性，具体参考 P73</span></code></pre><p>更适用与 IPv4/IPv6 的函数为：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">inet_pton</span><span class="token punctuation">(</span><span class="token keyword">int</span> af<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> src<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> dst<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// af 是地址族</span><span class="token comment">// 逆向转换，len 可以为 INET_ADDRSTRLEN(16, IPv4) / INET6_ADDRSTRLEN(46, IPv6)</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">inet_ntop</span><span class="token punctuation">(</span><span class="token keyword">int</span> af<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> src<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> dst<span class="token punctuation">,</span> socklen_t len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 失败返回 NULL</span></code></pre><h4 id="5-2-创建-socket"><a href="#5-2-创建-socket" class="headerlink" title="5.2 创建 socket"></a>5.2 创建 socket</h4><p>UNIX/Linux 一切皆文件的思想也囊括 socket，它是一个可读、可写、可控制、可关闭的文件描述符，创建的一个 socket 的系统调用为：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token comment">// domain: 协议族，包括 PF_INET、PF_INET6、PF_UNIX</span><span class="token comment">// type: 服务类型，包括 SOCK_STREAM（TCP流服务）、SOCK_DGRAM（UDP数据报服务）</span><span class="token comment">// protocol: 前两个参数已经决定了协议，一般设置为 0 即可</span><span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 失败返回 -1</span></code></pre><p>type 在 Linux 2.6.17 版本可以接受 SOCK_NONBLOCK 和 SOCK_CLOEXEC 宏，具体含义参考 P75</p><h4 id="5-3-命名-socket"><a href="#5-3-命名-socket" class="headerlink" title="5.3  命名 socket"></a>5.3  命名 socket</h4><p>将 socket 与具体的 IP 地址绑定称为命名 socket，服务端程序中只有命名 socket 之后客户端才能知道该如何连接它，客户端通常不需要命名 socket，而是采用匿名方式。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token comment">// 将 my_addr 所指的 socket 地址分配给 未命名的 sockfd 文件描述符</span><span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> my_addr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 失败返回 -1</span></code></pre><h4 id="5-4-监听-socket"><a href="#5-4-监听-socket" class="headerlink" title="5.4 监听 socket"></a>5.4 监听 socket</h4><p>socket 被命名之后还需要创建<strong>监听队列</strong>以存放待处理的客户端连接，才能接受客户端连接</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token comment">// backlog 是内核监听队列的最大长度，表示服务端完全连接状态 ESTABLISHED 数量的上限（backlog+1）</span><span class="token comment">// Mac 环境中测试是监听上限就是 backlog</span><span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 失败返回 -1，成功返回 0</span></code></pre><blockquote><p>代码参考：<a href="ch5/5-3testlisten.cpp">5-3testlisten.cpp</a></p></blockquote><h4 id="5-5-接受连接"><a href="#5-5-接受连接" class="headerlink" title="5.5 接受连接"></a>5.5 接受连接</h4><p>从 listen 监听队列中接受一个连接的系统调用为：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token comment">// sockfd 是执行过 listen 系统调用的监听 socket，处于 LISTEN 状态</span><span class="token comment">// addr 用来获取被接受连接的远端 socket 地址</span><span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> addr<span class="token punctuation">,</span> socklen_t <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>accept 成功调用会返回一个新的<strong>连接 socket</strong>（处于 ESTABLISHED 状态），该套接字唯一标识这个被接受的连接，服务器可以通过读写该 socket 来与客户端通信</p><blockquote><p>注意：accept 并不关心任何网络状况的变化，只是从监听队列中取出连接，而不论连接处于何种状态</p><p>代码参考：<a href="ch5/5-5testaccept.cpp">5-5testaccept.cpp</a></p></blockquote><h4 id="5-6-发起连接"><a href="#5-6-发起连接" class="headerlink" title="5.6 发起连接"></a>5.6 发起连接</h4><p>服务端是通过 listen 被动接受连接，客户端就需要通过 connect 系统调用主动发起与服务端的连接：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token comment">// sockfd 是客户端自己创建的套接字</span><span class="token comment">// serv_addr 是服务器监听的 socket 地址</span><span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> serv_addr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>成功调用返回 0，客户端的 sockfd 就唯一标识这个连接，客户端就可以通过读写 sockfd 来与服务器通信</p><h4 id="5-7-关闭连接"><a href="#5-7-关闭连接" class="headerlink" title="5.7 关闭连接"></a>5.7 关闭连接</h4><p>通过减少引用计数关闭连接，并不是真正关闭连接，只有当引用计数为 0 时才真正关闭</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>立即关闭连接可以使用：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token comment">// howto: 关闭读 SHUT_RD、关闭写 SHUT_WR、关闭读写 SHUT_RDWR</span><span class="token keyword">int</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> howto<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 成功返回 0，失败 -1</span></code></pre><h4 id="5-8-数据读写"><a href="#5-8-数据读写" class="headerlink" title="5.8 数据读写"></a>5.8 数据读写</h4><h5 id="5-8-1-TCP-数据读写"><a href="#5-8-1-TCP-数据读写" class="headerlink" title="5.8.1 TCP 数据读写"></a>5.8.1 TCP 数据读写</h5><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token comment">// buf 和 len 分别是读缓冲区的位置和大小，flags 一般为 0</span><span class="token comment">// recv 成功时返回实际读取的数据长度，可能小于 len</span><span class="token comment">// 返回 0 表示对方已经关闭连接，-1 表示出错</span>ssize_t <span class="token function">recv</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// send 成功时返回实际写入的数据长度，失败时返回 -1</span>ssize_t <span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>flags 选项可以设置 send 或者 recv 读取或者发送数据的方式，比如处理紧急数据（带外数据）等</p><p>带外数据处理代码参考：<a href="ch5/5-6oobsend.cpp">客户端-5-6oobsend.cpp</a>，<a href="ch5/5-7oobrecv.cpp">服务端-5-7oobrecv.cpp</a></p></blockquote><h5 id="5-8-2-UDP-数据读写"><a href="#5-8-2-UDP-数据读写" class="headerlink" title="5.8.2 UDP 数据读写"></a>5.8.2 UDP 数据读写</h5><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token comment">// 和 recv 不同的是需要指定发送端的 socket 地址，因为 UDP 没有连接的概念</span>ssize_t <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> src_addr<span class="token punctuation">,</span> socklen_t<span class="token operator">*</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 指定接收端的 socket 地址</span>ssize_t <span class="token function">sendto</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> dest_addr<span class="token punctuation">,</span> socklen_t<span class="token operator">*</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这两个函数也可以用于 TCP 接受数据，只需要将后面两个参数设置为 NULL 表示忽略发送端/接收端地址</p><h5 id="5-8-3-通用数据读写函数"><a href="#5-8-3-通用数据读写函数" class="headerlink" title="5.8.3 通用数据读写函数"></a>5.8.3 通用数据读写函数</h5><p>不区分 TCP 和 UDP，更加通用的数据读写函数为：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>ssize_t <span class="token function">recvmsg</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span><span class="token operator">*</span> msg<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>sszie_t <span class="token function">sendmsg</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span><span class="token operator">*</span> msg<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>msghdr 结构体为：具体含义参考 P85</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">msghdr</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span><span class="token operator">*</span> msg_name<span class="token punctuation">;</span><span class="token comment">// socket 地址</span>    socklen_t msg_namelen<span class="token punctuation">;</span><span class="token comment">// 地址长度</span>    <span class="token keyword">struct</span> <span class="token class-name">iovec</span><span class="token operator">*</span> msg_iov<span class="token punctuation">;</span><span class="token comment">// 存放数据：分散读、集中写</span>    <span class="token keyword">int</span> msg_iovlen<span class="token punctuation">;</span> <span class="token comment">// iovec 结构体个数</span>    <span class="token keyword">void</span><span class="token operator">*</span> msg_control<span class="token punctuation">;</span>    socklen_t msg_controllen<span class="token punctuation">;</span>    <span class="token keyword">int</span> msg_flags<span class="token punctuation">;</span><span class="token comment">// 复制函数中 flags 参数，调用过程中更新</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h4 id="5-9-带外标记"><a href="#5-9-带外标记" class="headerlink" title="5.9 带外标记"></a>5.9 带外标记</h4><p>内核通知应用程序带外数据到达的两种方式：<strong>「IO复用产生的异常事件」和 「SIGURG 信号」</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token comment">// 判断 sockfd 是否处于带外标记，即下一个被读到的数据是否是带外数据</span><span class="token comment">// 如果是返回 1，此时就可以设置 flags 为 MSG_OOB 标志的 recv 调用来接受带外数据；否则返回 0</span><span class="token keyword">int</span> <span class="token function">sockatmark</span><span class="token punctuation">(</span><span class="token keyword">int</span> socket<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="5-10-地址信息函数"><a href="#5-10-地址信息函数" class="headerlink" title="5.10 地址信息函数"></a>5.10 地址信息函数</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token comment">// 获取 sockfd 对应的本端 socket 地址，存在 addr 中</span><span class="token keyword">int</span> <span class="token function">getsockname</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> addr<span class="token punctuation">,</span> socklen_t<span class="token operator">*</span> addlen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 成功返回 0，失败 -1</span><span class="token comment">// 获取 sockfd 对应的远端 socket 地址，存在 addr 中</span><span class="token keyword">int</span> <span class="token function">getpeername</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> addr<span class="token punctuation">,</span> socklen_t<span class="token operator">*</span> addlen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 成功返回 0，失败 -1</span></code></pre><h4 id="5-11-socket-选项"><a href="#5-11-socket-选项" class="headerlink" title="5.11 socket 选项"></a>5.11 socket 选项</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span><span class="token comment">// level: 指定哪个协议，包括 SOL_SOCKET、IPPROTO_IP、IPPROTO_IPV6、IPPROTO_TCP</span><span class="token comment">// option_name: 指定选项名称</span><span class="token comment">// option_value 和 option_len 分别是选项的值和长度</span><span class="token keyword">int</span> <span class="token function">getsockopt</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> option_name<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> option_value<span class="token punctuation">,</span>               socketlen_t<span class="token operator">*</span> restrict option_len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 成功返回 0，失败 -1</span><span class="token keyword">int</span> <span class="token function">setsockopt</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> option_name<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> option_value<span class="token punctuation">,</span>               socketlen_t option_len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 成功返回 0，失败 -1</span></code></pre><ul><li><p>SO_REUSEADDR：强制使用被处于 TIME_WAIT 状态的连接占用的 socket 地址</p><blockquote><p>代码参考：<a href="ch5/5-9reuse_address.cpp">5-9reuse_address.cpp</a></p></blockquote></li><li><p>SO_RCVBUF：修改 TCP 接受缓冲区的大小（翻倍设置），最小为 256 字节</p><blockquote><p>代码参考：<a href="ch5/5-11set_recv_buffer.cpp">5-11set_recv_buffer.cpp</a></p></blockquote></li><li><p>SO_SNDBUF：修改 TCP 发送缓冲区的大小（翻倍设置），最小为 2048 字节</p><blockquote><p>代码参考：<a href="ch5/5-10set_send_buffer.cpp">5-10set_send_buffer.cpp</a></p></blockquote></li><li><p>SO_RCVLOWAT 和 SO_SNDLOWAT：TCP 接受缓冲区和发送缓冲区的低水位标记，用于 IO 复用中判断何时可读写</p></li></ul><h4 id="5-12-网络信息-API"><a href="#5-12-网络信息-API" class="headerlink" title="5.12 网络信息 API"></a>5.12 网络信息 API</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;netdb.h&gt;</span></span><span class="token comment">// 根据主机名称获取主机的完整信息</span><span class="token keyword">struct</span> <span class="token class-name">hostent</span><span class="token operator">*</span> <span class="token function">gethostbyname</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 根据 IP 地址获取主机的完整信息</span><span class="token keyword">struct</span> <span class="token class-name">hostent</span><span class="token operator">*</span> <span class="token function">gethostbyaddr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> addr<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>返回的都是 hostent 结构体类型的指针，更多具体的 API 参考 P95</p><blockquote><p>代码参考：<a href="ch5/5-12access_daytime.cpp">5-12access_daytime.cpp</a></p></blockquote><h3 id="Ch-6-高级-I-O-函数"><a href="#Ch-6-高级-I-O-函数" class="headerlink" title="Ch.6 高级 I/O 函数"></a>Ch.6 高级 I/O 函数</h3><p>Linux 提供很多高级 IO 函数，没有 read/open 等基础的常用，但是特定地方使用性能较高，一般有三类</p><ul><li><strong>创建文件描述符</strong>的函数：pipe、dup/dup2</li><li><strong>读写数据</strong>的函数：包括 readv/writev、sendfile、mmap/munmap、splice、tee 等</li><li><strong>控制 IO 行为和属性</strong>的函数：fcntl</li></ul><h4 id="6-1-pipe-函数"><a href="#6-1-pipe-函数" class="headerlink" title="6.1 pipe 函数"></a>6.1 pipe 函数</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token comment">// 往 fd[1] 写入的数据可以从 fd[0] 读出，不能反过来</span><span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 成功返回 0，并将一对打开的文件描述符填入其参数指向的数组</span></code></pre><ul><li>管道内部传输的数据是字节流</li><li>管道有容量限制，默认大小为 65536 字节</li><li>socketpair 函数可以在本地域 AF_UNIX 创建双向管道</li></ul><h4 id="6-2-dup-dup2-函数"><a href="#6-2-dup-dup2-函数" class="headerlink" title="6.2 dup/dup2 函数"></a>6.2 dup/dup2 函数</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token comment">// 返回一个新的文件描述符，和旧的文件描述符 old_fd 指向相同的文件、管道或者网络连接</span><span class="token comment">// 返回系统当前可用的最小整数值</span><span class="token keyword">int</span> <span class="token function">dup</span><span class="token punctuation">(</span><span class="token keyword">int</span> old_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 和 dup 类似，返回的文件描述符不小于 limit_fd</span><span class="token keyword">int</span> <span class="token function">dup2</span><span class="token punctuation">(</span><span class="token keyword">int</span> old_fd<span class="token punctuation">,</span> <span class="token keyword">int</span> limit_fd<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>P102 例子中，写了一个简单的服务端程序，与客户端通信的 socket 记为 connfd，先关闭标准输出 STDOUT_FILENO (其值为1)，<strong>然后调用 dup(connfd) 返回 1</strong>，这样标准输出就和 connfd 指向同样的文件，也就是 printf 的数据直接写入管道（不会出现在终端上），发送给客户端，这就是 Comman Gateway Interface（CGI）服务器的基本工作原理</p><blockquote><p>代码参考：<a href="ch6/6-1testdup.cpp">6-1testdup.cpp</a></p></blockquote><h4 id="6-3-readv-writev-函数"><a href="#6-3-readv-writev-函数" class="headerlink" title="6.3 readv/writev 函数"></a>6.3 readv/writev 函数</h4><p>简单来说 readv 是分散读，writev 是集中写，相当于 recvmsg/sendmsg</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/uio.h&gt;</span></span><span class="token comment">// fd 是被操作的 socket，vector 是 iovec 结构数组，iovec 结构描述的是一块内存区，count 参数是 vector 数组长度</span><span class="token comment">// 成功时返回读出/写入 fd 的字节数，失败返回 -1 并设置 errno </span>ssize_t <span class="token function">readv</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">iovec</span><span class="token operator">*</span> vector<span class="token punctuation">,</span> <span class="token keyword">int</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>ssize_t <span class="token function">writev</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">iovec</span><span class="token operator">*</span> vector<span class="token punctuation">,</span> <span class="token keyword">int</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>strcut iovec <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>iov_base<span class="token punctuation">;</span> <span class="token comment">// 内存起始地址</span>    size_t iov_len<span class="token punctuation">;</span> <span class="token comment">// 内存长度</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>P105 例子中给了简单 HTTP 文件服务器，通过 writev 将 headbuf（状态行+头部字段+空行）和 filebuf（文档内容）集中写入 socket</p><blockquote><p>代码参考：<a href="ch6/6-2testwritev.cpp">6-2testwritev.cpp</a></p></blockquote><h4 id="6-4-sendfile-函数"><a href="#6-4-sendfile-函数" class="headerlink" title="6.4 sendfile 函数"></a>6.4 sendfile 函数</h4><p>sendfile 在两个文件描述符之间直接传递数据，完全在内核中操作，避免了内核缓冲区和用户缓冲区之间的数据拷贝，这就是<strong>零拷贝</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/sendfile.h&gt;</span></span><span class="token comment">// in_fd --sendfile--&gt; out_fd</span><span class="token comment">// in_fd 表示待读出内容的文件描述符，out_fd 表示待写入内容的文件描述符</span><span class="token comment">// offset 表示 in_fd 的起始位置，count 表示 in_fd 和 out_fd 之间传输的字节数</span>ssize_t <span class="token function">sendfile</span><span class="token punctuation">(</span><span class="token keyword">int</span> out_fd<span class="token punctuation">,</span> <span class="token keyword">int</span> in_fd<span class="token punctuation">,</span> off_t<span class="token operator">*</span> offset<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 成功时返回传输的字节数，失败返回-1</span></code></pre><ul><li>in_fd 必须是一个支持类似 mmap 函数的文件描述符，必须指向真实的文件，不能是 socket 和管道</li><li>out_fd 必须是一个 socket</li></ul><blockquote><p>sendfile 几乎是专门为在网络上传输文件而设计的，注意 MacOS 的 sendfile 参数和 Linux 不太一样，参考 <a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/sendfile.2.html">sendfile.2</a></p></blockquote><p>P107 例子使用 sendfile 将服务器上的一个文件传输给客户端，其中没有<strong>为目标文件分配任何用户空间的缓存，也没有执行读取文件的操作</strong>，相比于之前的 通过 HTTP 传输文件的效率要高得多</p><blockquote><p>代码参考：<a href="ch6/6-3testsendfile.cpp">6-3testsendfile.cpp</a></p></blockquote><h4 id="6-5-mmap-munmap-函数"><a href="#6-5-mmap-munmap-函数" class="headerlink" title="6.5 mmap/munmap 函数"></a>6.5 mmap/munmap 函数</h4><p>mmap 用于申请一段内存空间，munmap 则释放由 mmap 创建的这段内存空间</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h&gt;</span></span><span class="token comment">// start: 待分配内存的起始地址，如果为 null 则系统自动分配一个地址</span><span class="token comment">// length: 指定内存段的长度；prot: 设置内存段的访问权限，可以按位或取 PROT_READ|PROT_WRITE|PROT_EXEC|PROT_NONE</span><span class="token comment">// fd 是被映射文件对应的文件描述符，一般通过 open 获得</span><span class="token comment">// [return] 成功时返回指向目标内存区域的指针，失败 -1</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>start<span class="token punctuation">,</span> size_t length<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> off_t offset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">munmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>start<span class="token punctuation">,</span> size_t length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 失败 -1，成功 0</span></code></pre><h4 id="6-6-splice-函数"><a href="#6-6-splice-函数" class="headerlink" title="6.6 splice 函数"></a>6.6 splice 函数</h4><p>splice 函数用于两个文件描述符之间移动数据，是<strong>零拷贝操作</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token comment">// fd_in 表示待输入数据的文件描述符</span><span class="token comment">// len 指定移动数据的长度</span><span class="token comment">// flags 控制数据如何移动，取异或值：SPLICE_F_MOVE|SPLICE_F_NONBLOCK|SPLICE_F_MORE</span>ssize_t <span class="token function">splice</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd_in<span class="token punctuation">,</span> loff_t<span class="token operator">*</span> off_in<span class="token punctuation">,</span> <span class="token keyword">int</span> fd_out<span class="token punctuation">,</span> loff_t<span class="token operator">*</span> off_out<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 成功时返回移动字节的数量，失败 -1</span></code></pre><p>fd_in/fd_out 必须至少有一个是管道文件描述符</p><ul><li>fd_in 如果是管道文件描述符，off_in 参数必须被设置为 NULL</li><li>fd_in 如果不是一个管道文件描述符，off_in 指定输入数据流的何处开始读取数据</li></ul><p>P110 例子实现了一个简单的回射服务器，利用 splice 函数将客户端的内容读入管道写端 fd[1]，然后再使用 splice 函数从管道读端 fd[0] 读出该内容到客户端。整个过程没有执行 recv/send 操作，十分高效</p><blockquote><p>代码参考：<a href="ch6/6-4testsplice.cpp">6-4testsplice.cpp</a> （注：MacOS 并没有 splice 函数）</p></blockquote><h4 id="6-7-tee-函数"><a href="#6-7-tee-函数" class="headerlink" title="6.7 tee 函数"></a>6.7 tee 函数</h4><p>tee 函数在两个管道文件描述符之间复制数据，是零拷贝操作</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token comment">// fd_in 和 fd_out 必须都是管道文件描述符</span><span class="token comment">// [return] 成功时返回复制的字节数，失败 -1</span>ssize_t <span class="token function">tee</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd_in<span class="token punctuation">,</span> <span class="token keyword">int</span> fd_out<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>P111 例子实现了一个简单的 tee 程序，利用 splice（标准输入输出&lt;–&gt;输入输出管道） 和 tee（输出管道&lt;–&gt;文件管道）同时输出数据到终端和文件</p><blockquote><p>代码参考：<a href="ch6/6-5testtee.cpp">6-5testtee.cpp</a></p></blockquote><h4 id="6-8-fcntl-函数"><a href="#6-8-fcntl-函数" class="headerlink" title="6.8 fcntl 函数"></a>6.8 fcntl 函数</h4><p>file control 函数提供对文件描述符的各种控制操作</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token comment">// fd 是被操作的文件描述符，cmd 指定执行何种类型的操作</span><span class="token comment">// 根据操作类型不同可能还需要第3个可选参数 arg</span><span class="token keyword">int</span> <span class="token function">fcntl</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 失败 -1</span></code></pre><ul><li>F_GETFD/F_SETFD：获取和设置文件描述符的标志</li><li>F_GETFL/F_SETFL：获取和设置文件描述符的状态标志</li></ul><p>P113 代码清单中首先 F_GETFL 获取 fd 的旧状态标志，然后 F_SETFL 将 fd 设置为非阻塞状态</p><h3 id="Ch-7-Linux-服务器程序规范"><a href="#Ch-7-Linux-服务器程序规范" class="headerlink" title="Ch.7 Linux 服务器程序规范"></a>Ch.7 Linux 服务器程序规范</h3><h4 id="7-1-日志"><a href="#7-1-日志" class="headerlink" title="7.1 日志"></a>7.1 日志</h4><h5 id="7-1-1-Linux-系统日志"><a href="#7-1-1-Linux-系统日志" class="headerlink" title="7.1.1 Linux 系统日志"></a>7.1.1 Linux 系统日志</h5><p>rsyslogd 守护进程技能接收用户进程输出的日志，又能接收内核日志，通过调用 syslog 函数生成系统日志，该函数将日志输出到一个 UNIX 本地域 socket 类型 AF_UNIX 的 文件 /dev/log 中，具体参考 P115 Linux 的系统日志体系。</p><h5 id="7-1-2-syslog-函数"><a href="#7-1-2-syslog-函数" class="headerlink" title="7.1.2 syslog 函数"></a>7.1.2 syslog 函数</h5><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;syslog.h&gt;</span></span><span class="token comment">// priority 是设施值（LOG_USER）与日志级别的按位或，7种日志级别参考 P115</span><span class="token keyword">void</span> <span class="token function">syslog</span><span class="token punctuation">(</span><span class="token keyword">int</span> priority<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> message<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>openlog 可以改变 syslog 的默认输出方式，进一步结构化日志内容 </p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;syslog.h&gt;</span></span><span class="token comment">// ident 参数指定的字符串被添加到日志消息的日期和时间之后，一般为程序的名字</span><span class="token keyword">void</span> <span class="token function">openlog</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> ident<span class="token punctuation">,</span> <span class="token keyword">int</span> logopt<span class="token punctuation">,</span> <span class="token keyword">int</span> facility<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>程序开发过程中需要输出很多调试信息，而发布之后又需要将这些调式信息关闭，这时候需要对日志进行过滤</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;syslog.h&gt;</span></span><span class="token comment">// 日志级别大于日志掩码的日志信息会被系统忽略</span><span class="token keyword">int</span> <span class="token function">setlogmask</span><span class="token punctuation">(</span><span class="token keyword">int</span> maskpri<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 最后需要关闭日志</span><span class="token keyword">void</span> <span class="token function">closelog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="7-2-用户信息"><a href="#7-2-用户信息" class="headerlink" title="7.2 用户信息"></a>7.2 用户信息</h4><h5 id="7-2-1-uid-euid-gid-egid"><a href="#7-2-1-uid-euid-gid-egid" class="headerlink" title="7.2.1 uid/euid/gid/egid"></a>7.2.1 uid/euid/gid/egid</h5><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>uid_t <span class="token function">getuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取真实用户 id</span>uid_t <span class="token function">geteuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取有效用户 id</span>gid_t <span class="token function">getgid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取真实组 id</span>gid_t <span class="token function">getegid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取有效组 id</span></code></pre><p>P117 代码清单 7-1 展示了 UID 和 EUID 的区别，代码参考：<a href="ch7/7-1testeuid.cpp">7-1testeuid.cpp</a></p><h5 id="7-2-2-切换用户"><a href="#7-2-2-切换用户" class="headerlink" title="7.2.2 切换用户"></a>7.2.2 切换用户</h5><p>代码清单 7-2 展示了以 root 身份启动的进程切换为一个普通用户身份运行，没看懂o(╥﹏╥)o</p><blockquote><p>root 的 uid == 0 &amp;&amp; guid == 0?</p><p>代码参考：<a href="ch7/7-2switchuser.cpp">7-2switchuser.cpp</a></p></blockquote><h4 id="7-3-进程间关系"><a href="#7-3-进程间关系" class="headerlink" title="7.3 进程间关系"></a>7.3 进程间关系</h4><h5 id="7-3-1-进程组"><a href="#7-3-1-进程组" class="headerlink" title="7.3.1 进程组"></a>7.3.1 进程组</h5><p>每个进程都隶属于一个进程组，进程组有进程组 ID（PGID），首领进程的 PID 和 PGID 相同</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>pid_t <span class="token function">getpgid</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 成功返回 pid 的进程组的 PGID，失败 -1</span><span class="token keyword">int</span> <span class="token function">setpgid</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">,</span> pid_t pgid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置 pid 的进程组的 PGID 为 pgid，成功 0，失败 -1</span></code></pre><p>一个进程只能设置自己或者子进程的 PGID，并且子进程调用 exec 系列函数之后不能再在父进程中对它设置 PGID</p><h5 id="7-3-2-会话"><a href="#7-3-2-会话" class="headerlink" title="7.3.2 会话"></a>7.3.2 会话</h5><p>一些关联的进程组形成一个会话 session，创建会话</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>pid_t <span class="token function">setsid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 只能由非首领进程创建会话，调用进程成为会话的首领</span>pid_t <span class="token function">getsid</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读取会话ID SID，Linux 系统认为 SID==PGID</span></code></pre><h5 id="7-3-3-ps-查看进程关系"><a href="#7-3-3-ps-查看进程关系" class="headerlink" title="7.3.3 ps 查看进程关系"></a>7.3.3 ps 查看进程关系</h5><p>P119 图 7-2 很清晰的展示了进程之间的关系，不同进程组成进程组，不同进程组组成会话</p><h4 id="7-4-系统资源限制"><a href="#7-4-系统资源限制" class="headerlink" title="7.4 系统资源限制"></a>7.4 系统资源限制</h4><p>Linux 系统有资源限制，比如物理设备限制、系统策略限制、具体实现的限制等等</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/resource.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">getrlimit</span><span class="token punctuation">(</span><span class="token keyword">int</span> resource<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">rlimit</span> <span class="token operator">*</span>rlim<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">setrlimit</span><span class="token punctuation">(</span><span class="token keyword">int</span> resource<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">rlimit</span> <span class="token operator">*</span>rlim<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// rlim_t 是一个整数类型，描述资源级别</span><span class="token keyword">struct</span> <span class="token class-name">rlimit</span><span class="token punctuation">{</span>    rlim_t rlim_cur<span class="token punctuation">;</span> <span class="token comment">// 资源的软限制，建议性的、最好不要超越的限制，超过可能会发信号终止进程</span>    rlim_t rlin_max<span class="token punctuation">;</span> <span class="token comment">// 资源的硬限制，软限制的上限，普通程序只能减少，只有 root 可以增加</span><span class="token punctuation">}</span></code></pre><p>ulimit 命令可以修改<strong>当前 shell</strong> 环境下的资源限制，也可以通过修改配置文件来改变系统的软限制和硬限制，这种修改是<strong>永久的</strong>。</p><h4 id="7-5-改变工作目录和根目录"><a href="#7-5-改变工作目录和根目录" class="headerlink" title="7.5 改变工作目录和根目录"></a>7.5 改变工作目录和根目录</h4><p>有些服务器程序还需要改变工作目录和根目录</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token comment">// buf 指向内存用于存储进程当前工作目录的绝对路径名，size 指定其大小</span><span class="token comment">// [return] 成功时返回一个指向目标存储区的指针</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">getcwd</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 失败返回 NULL 并设置 errno</span><span class="token comment">// path 指定要切换到的目标目录</span><span class="token keyword">int</span> <span class="token function">chdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 成功 0，失败 -1</span><span class="token comment">// path 指定要切换到的目标根目录</span><span class="token keyword">int</span> <span class="token function">chroot</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 成功 0，失败 -1</span></code></pre><h4 id="7-6-服务器程序后台化"><a href="#7-6-服务器程序后台化" class="headerlink" title="7.6 服务器程序后台化"></a>7.6 服务器程序后台化</h4><p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周 期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。守护进程特点如下：</p><ul><li><p>生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭</p></li><li><p>它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）</p></li></ul><p>代码参考：<a href="nowcoder/daemon.c">daemon.c</a></p><p>如何让进程以「<strong>守护进程</strong>」的方式运行？参考代码清单 7-3，实际上提供如下的系统调用：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token comment">// nochdir 用于指定是否改变工作目录，0 --&gt; 工作目录设置为 "/"，否则留在当前目录</span><span class="token comment">// noclose 为 0 时标准输入输出以及错误输出都被重定向到 /dev/null 文件，否则依然使用原来的设备</span><span class="token keyword">int</span> <span class="token function">daemon</span><span class="token punctuation">(</span><span class="token keyword">int</span> nochdir<span class="token punctuation">,</span> <span class="token keyword">int</span> noclose<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 成功 0，失败-1</span></code></pre><blockquote><p>代码参考：<a href="ch7/7-3daemonize.cpp">7-3daemonize.cpp</a></p></blockquote><h3 id="Ch-8-高性能服务器程序框架"><a href="#Ch-8-高性能服务器程序框架" class="headerlink" title="Ch.8 高性能服务器程序框架"></a>Ch.8 高性能服务器程序框架</h3><h4 id="8-1-服务器模型"><a href="#8-1-服务器模型" class="headerlink" title="8.1 服务器模型"></a>8.1 服务器模型</h4><h5 id="8-1-1-C-S-模型"><a href="#8-1-1-C-S-模型" class="headerlink" title="8.1.1 C/S 模型"></a>8.1.1 C/S 模型</h5><p>服务器客户端模式</p><ul><li>服务器：创建 socket –&gt; bind 地址 –&gt; listen –&gt; select IO 复用 –&gt; accept –&gt; 逻辑单元（fork子进程、子线程或其他）</li><li>客户端：socket –&gt; connect –&gt; send –&gt; recv</li></ul><p>缺点：访问量过大时，服务器负载加大，客户端得到的响应变慢</p><h5 id="8-1-2-P2P-模型"><a href="#8-1-2-P2P-模型" class="headerlink" title="8.1.2 P2P 模型"></a>8.1.2 P2P 模型</h5><p>点对点模式中主机既是服务端又是客户端，缺点是：用户之间传输的请求过多时，网络的负载加重</p><p>通常 P2P 模型带有一个专门的发现服务器，提供查找服务</p><h4 id="8-2-服务器编程框架"><a href="#8-2-服务器编程框架" class="headerlink" title="8.2 服务器编程框架"></a>8.2 服务器编程框架</h4><ul><li>IO 处理单元：服务器管理客户连接的模块</li><li>逻辑单元：进程或线程，分析并处理数据，然后将结果传递给 IO 处理单元或者直接返回给客户端</li><li>网络存储单元：数据库、缓存或文件，可选的</li></ul><h4 id="8-3-IO-模型"><a href="#8-3-IO-模型" class="headerlink" title="8.3 IO 模型"></a>8.3 IO 模型</h4><p>阻塞 I/O 和 非阻塞 I/O，P126 描述了阻塞的 connect 工作流程，无法立即完成被系统挂起，直到等待的时间发生为止</p><ul><li>socket 相关 API 中，可能被阻塞的系统调用包括 accept、send、recv 和 connect</li><li>非阻塞 I/O 执行的系统调用如果时间没有立即发生，返回 -1，这和出错的情况一样，此时需要根据 errno 来区分</li><li><strong>I/O 复用函数本身是阻塞的</strong>，它们能提高程序效率的原因在于它们具有同时<strong>监听多个 I/O 事件的能力</strong></li></ul><p>同步 I/O 向应用程序通知的是 I/O 就绪事件，异步 I/O 通知的是 I/O 完成事件</p><h4 id="8-4-两种高效的事件处理模式"><a href="#8-4-两种高效的事件处理模式" class="headerlink" title="8.4 两种高效的事件处理模式"></a>8.4 两种高效的事件处理模式</h4><p>同步 I/O 模型通常用于实现 Reactor 模式，异步 I/O 模型则用于实现 Proactor 模式</p><h5 id="8-4-1-Reactor-模式"><a href="#8-4-1-Reactor-模式" class="headerlink" title="8.4.1 Reactor 模式"></a>8.4.1 Reactor 模式</h5><ul><li>主线程（I/O 处理单元）只负责监听文件描述上是否有时间发生，有的话立即通知工作线程</li><li>工作线程（逻辑单元）读写数据、接收新的连接以及处理客户端请求</li></ul><p>P128 图 8-5 展示同步 I/O epoll_wait 实现的 Reactor 模式，主线程通过 epoll_wait 监听到 socket 上有数据可读或可写时，将这个可读或可写时间放入请求队列，工作线程从请求队列中取事件</p><h5 id="8-4-2-Proactor-模式"><a href="#8-4-2-Proactor-模式" class="headerlink" title="8.4.2 Proactor 模式"></a>8.4.2 Proactor 模式</h5><ul><li>主线程（I/O 处理单元）负责所有的 I/O 操作</li><li>工作线程（逻辑单元）仅仅负责业务逻辑</li></ul><p>图 8-6 展示了异步 I/O aio_read/aio_write 实现的 Proactor 模式，没看懂o(╥﹏╥)o</p><h5 id="8-4-3-模拟-Proactor-模式"><a href="#8-4-3-模拟-Proactor-模式" class="headerlink" title="8.4.3 模拟 Proactor 模式"></a>8.4.3 模拟 Proactor 模式</h5><p>使用同步 I/O epoll_wait 模拟 Proactor 模式，让主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作进程的角度上来看，它们就直接获得了数据的读写结果，接下来要做的就是对读写的结果进行逻辑处理。</p><blockquote><p>流程依旧没看懂o(╥﹏╥)o</p></blockquote><h4 id="8-5-两种高效的并发模式"><a href="#8-5-两种高效的并发模式" class="headerlink" title="8.5 两种高效的并发模式"></a>8.5 两种高效的并发模式</h4><h5 id="8-5-1-半同步-半异步模式"><a href="#8-5-1-半同步-半异步模式" class="headerlink" title="8.5.1 半同步/半异步模式"></a>8.5.1 半同步/半异步模式</h5><ul><li>同步：程序完成按照代码序列的顺序执行</li><li>异步：程序的执行需要由系统事件来驱动，常见的系统事件包括中断、信号等</li></ul><p>异步线程执行效率高、实时性强，但是难以调试和扩展，不适合大量并发；同步线程虽然执行效率较低、实时性差，但逻辑简单。服务器一般及要求较好的实时性，又要求能同时处理多个客户请求的应用程序，所以采用<strong>「半同步/半异步模式」</strong>实现</p><h5 id="8-5-2-领导者-追随者模式"><a href="#8-5-2-领导者-追随者模式" class="headerlink" title="8.5.2 领导者/追随者模式"></a>8.5.2 领导者/追随者模式</h5><p>多个工作线程轮流获得事件源集合，轮流监听、分发并处理时间的一种模式。在任意时间点，程序都仅有一个领导者线程，负责监听 I/O 事件。而其他线程都是追随者，它们休眠在线程池中等待成为新的领导者。</p><ul><li>句柄集 HandleSet</li><li>线程集 ThreadSet</li><li>时间处理器 EventHandler</li></ul><h4 id="8-6-有限状态机-fire"><a href="#8-6-有限状态机-fire" class="headerlink" title="8.6 有限状态机 :fire:"></a>8.6 有限状态机 <span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>程序清单 8-3 展示了 HTTP 请求的读取和分析中主从状态机是如何处理 HTTP 请求字段的</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 代码中有一个 string.h 文件里面的库函数</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token string">"hello world, friend of mine!"</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> sep <span class="token operator">=</span> <span class="token string">" ,!"</span><span class="token punctuation">;</span>str <span class="token operator">=</span> <span class="token function">strpbrk</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> sep<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 找分隔符，str = " world, friend of mine!"</span>str <span class="token operator">+=</span> <span class="token function">strspn</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> sep<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 跳过分隔符，str = "world, friend of mine!"</span>str <span class="token operator">=</span> <span class="token function">strchr</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 找到第一个出现的字符，str = "friend of mine!"</span></code></pre><blockquote><p>代码参考：<a href="ch8/8-3httpparser.cpp">8-3httpparser.cpp</a></p></blockquote><h4 id="8-7-提高服务器性能的其他建议"><a href="#8-7-提高服务器性能的其他建议" class="headerlink" title="8.7 提高服务器性能的其他建议"></a>8.7 提高服务器性能的其他建议</h4><h5 id="8-7-1-池"><a href="#8-7-1-池" class="headerlink" title="8.7.1 池"></a>8.7.1 池</h5><p>池通过空间换时间的思想来提高服务器的运行效率，相当于服务器管理系统资源的应用设施，避免了服务器对内核的频繁访问。</p><ul><li>内存池通常用于 socket 的接收缓存和发送缓存</li><li>进程池和线程池通常用于并发编程，当需要一个工作进程或线程来处理新的客户请求时，可以直接从池中取得一个执行实体，这样就无需动态地调用 fork 或 pthread_create 等函数来创建进程和线程</li><li>连接池通常用于服务器或服务器机群的内部永久连接，连接池是服务器预先和数据库程序建立的一组连接的集合</li></ul><h5 id="8-7-2-数据复制"><a href="#8-7-2-数据复制" class="headerlink" title="8.7.2 数据复制"></a>8.7.2 数据复制</h5><p>内核直接处理从 socket 或者文件读入的数据，所以应用程序没必要将这些数据从内核缓冲区复制到应用程序缓冲区中，使用“零拷贝”函数 sendfile 等就可以将一个文件直接发送给客户端。</p><p>另外当两个工作进程之间需要传递大量的数据时，应考虑使用共享内存来共享这些数据，而不是使用管道或者消息队列来传递，这样就可以<strong>避免不必要的数据复制</strong>。</p><h5 id="8-7-3-上下文切换和锁"><a href="#8-7-3-上下文切换和锁" class="headerlink" title="8.7.3 上下文切换和锁"></a>8.7.3 上下文切换和锁</h5><p>并发程序必须考虑上下文切换的问题，即进程切换或线程切换导致的系统开销；还需要考虑共享资源的加锁保护，如果服务器必须使用“锁”，则可以考虑减小锁的粒度。</p><h3 id="Ch-9-I-O-复用-fire"><a href="#Ch-9-I-O-复用-fire" class="headerlink" title="Ch.9 I/O 复用 :fire:"></a>Ch.9 I/O 复用 <span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h3><p>需要指出的是，I/O 复用虽然能同时监听多个文件描述符，但它本身是阻塞的。并且当多个文件描述符同时就绪时，如果不采取额外的措施，程序就只能按顺序依次处理其中的每一个文件描述符，这使得服务器程序看起来像是串行工作的。<strong>如果要实现并发，只能使用多进程或多线程等编程手段。</strong></p><h4 id="9-1-select-系统调用"><a href="#9-1-select-系统调用" class="headerlink" title="9.1 select 系统调用"></a>9.1 select 系统调用</h4><p>select 系统调用的原型如下：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/select.h&gt;</span></span><span class="token comment">// nfds 指定被监听的文件描述符的总数，通常是监听的所有文件描述符中的最大值加1</span><span class="token comment">// readfds, writefds, exceptfds 分别指向可读、可写和异常等事件对应的文件描述符集合</span><span class="token comment">// timeout 设置 select 函数的超时时间，0 立即返回，NULL 一直阻塞</span><span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> nfds<span class="token punctuation">,</span> fd_set<span class="token operator">*</span> readfds<span class="token punctuation">,</span> fd_set<span class="token operator">*</span> writefds<span class="token punctuation">,</span> fd_set<span class="token operator">*</span> exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span><span class="token operator">*</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// fd_set 结构体仅包含一个整形数组，该数组的每个元素的每一位 bit 标记一个文件描述符，容纳数量由 FD_SETSIZE 指定</span><span class="token function">FD_ZERO</span><span class="token punctuation">(</span>fd_set<span class="token operator">*</span> fdset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 清除 fdset 的所有位</span><span class="token function">FD_SET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置 fdset 的位 fd</span><span class="token function">FD_CLR</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 清除 fdset 的位 fd</span><span class="token keyword">int</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>fdset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 测试 fdset 的位 fd 是否被设置</span><span class="token keyword">struct</span> <span class="token class-name">timeval</span><span class="token punctuation">{</span>    <span class="token keyword">long</span> tv_sec<span class="token punctuation">;</span><span class="token comment">// 秒数</span>    <span class="token keyword">long</span> tv_usec<span class="token punctuation">;</span><span class="token comment">// 微秒数</span><span class="token punctuation">}</span></code></pre><p><strong>select 成功时返回就绪文件描述符的总数，如果在超时时间内没有任何文件描述符就绪就返回 0，失败 -1 并设置 errno</strong>，如果在 select 等待期间，程序收到信号，就立即返回 -1，并设置 errno 为 EINTR</p><p><strong>文件描述符可读就绪条件</strong></p><ul><li>socket 接收缓冲区中的字节数大于或等于低水位标记 SO_RCVLOWAT 时可以无阻塞地读 socket</li><li>socket 通信的对方关闭连接时，对该 socket 的读操作返回 0</li><li><strong>监听 socket</strong> 上有新的连接（注意「监听 socket」和「通信 socket」是两个概念）</li><li>socket 上有未处理的错误</li></ul><p><strong>文件描述符可写就绪条件</strong></p><ul><li>socket 发送缓冲区中的可用字节数大于或等于低水位标记 SO_SNDLOWAT 时可以无阻塞地写 socket</li><li>socket 的写操作被关闭，对该 socket 的执行写操作将触发一个 SIGPIPE 信号</li><li>socket 使用非阻塞 connect 连接成功或者失败（超时）之后</li><li>socket 上有未处理的错误</li></ul><p>代码参考：<a href="ch9/9-1use_select.cpp">9-1use_select.cpp</a></p><h4 id="9-2-poll-系统调用"><a href="#9-2-poll-系统调用" class="headerlink" title="9.2 poll 系统调用"></a>9.2 poll 系统调用</h4><p>poll 和 select 类似，也是在指定时间内轮询一定数量的文件描述符，测试其是否就绪</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;poll.h&gt;</span></span><span class="token comment">// fds 参数指定感兴趣的文件描述符上发生的可读、可写和异常事件</span><span class="token comment">// nfds 参数指定被监听事件集合 fds 的大小，实际类型为 unsigned long int</span><span class="token comment">// timeout 指定 poll 的超时值，单位是毫秒，-1 永远阻塞，0 直接返回</span><span class="token comment">// [return] 和 select 一样</span><span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span><span class="token operator">*</span> fds<span class="token punctuation">,</span> nfds_t nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// pollfd 结构体</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token comment">// 文件描述符</span>    <span class="token keyword">short</span> events<span class="token punctuation">;</span> <span class="token comment">// fd 上注册的事件，一系列 POLL 事件的按位或</span>    <span class="token keyword">short</span> revents<span class="token punctuation">;</span> <span class="token comment">// 实际发生的事件，内核填充</span><span class="token punctuation">}</span></code></pre><h4 id="9-3-epoll-系列系统调用"><a href="#9-3-epoll-系列系统调用" class="headerlink" title="9.3 epoll 系列系统调用"></a>9.3 epoll 系列系统调用</h4><blockquote><p>MacOSX 里没有 epoll 库，使用 kqueue 代替，<a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/kqueue.2.html">参考</a></p></blockquote><p>epoll 是 Linux 特有的 I/O 复用函数，它把用户关心的文件描述符上的事件放入内核里的一个事件表中，无需像 select 和 poll 那样每次调用都要重复传入文件描述符集或事件集。epoll 需要一个额外的文件描述符来唯一标识内核中的这个事件表</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/epoll.h&gt;</span></span><span class="token comment">// 创建标识内核中的事件表，size 参数并无实际作用</span><span class="token comment">// [return] 返回的 fd 将作为其他所有 epoll 系统调用的第一个参数</span><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 操作内核事件表 epfd</span><span class="token comment">// op 参数指定操作类型，由 EPOLL_CTL_ADD|EPOLL_CTL_MOD|EPOLL_CTL_DEL 组成</span><span class="token comment">// fd 参数是要操作的文件描述符</span><span class="token comment">// event 参数指定 fd 的监听事件</span><span class="token comment">// [return] 成功 0，失败 -1 并设置 errno</span><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token punctuation">{</span>    _uint32_t events<span class="token punctuation">;</span> <span class="token comment">// epoll 事件，和 poll 类型基本一致</span>    epoll_data_t data<span class="token punctuation">;</span> <span class="token comment">// 用户数据</span><span class="token punctuation">}</span><span class="token comment">// 联合体：不能同时使用多个成员</span><span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data <span class="token punctuation">{</span>    <span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span> <span class="token comment">// 使用最多，表示监听事件所属的目标文件描述符，和 epoll_ctl 中的 fd 相同</span>    <span class="token keyword">uint32_t</span> u32<span class="token punctuation">;</span>    <span class="token keyword">uint64_t</span> u64<span class="token punctuation">;</span><span class="token punctuation">}</span> epoll_data_t<span class="token punctuation">;</span><span class="token comment">// timeout 指定超时，maxevents 指定最多监听多少个事件</span><span class="token comment">// [return] 成功时返回就绪的文件描述符的个数，失败时返回 -1 并设置 errno</span><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span><span class="token operator">*</span> events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>epoll 相比于 poll 有两个额外的事件类型：EPOLLET | EPOLLONESHOT</p><p>epoll_wait 将所有就绪的事件从内核事件表（由 epfd 参数指定）中复制到 events 指定的数组中，<strong>只用于输出 epoll_wait 检测到的就绪事件</strong>，不像 select 和 poll 的数组参数那样既用于传入用户注册的时间又用于输出内核检测到的就绪事件，所以 epoll_wait 极大地提升了性能</p><h5 id="LT-和-ET-模式"><a href="#LT-和-ET-模式" class="headerlink" title="LT 和 ET 模式"></a>LT 和 ET 模式</h5><ul><li>LT：Level Trigger，默认的，epoll_wait 检测到其上有事件发生并将此事件通知应用程序之后，应用程序可以不立即处理该事件，下次调用 epoll_wait 还可以再次向应用程序通告此事件</li><li>ET：Edge Trigger，epoll_wait 检测到就绪事件之后必须处理，效率比 LT 模式要高，需要指定 EPOLLET 事件类型</li></ul><blockquote><p>代码参考：<a href="ch9/9-3mtlt.cpp">LT vs ET 9-3mtlt.cpp</a></p></blockquote><p><strong>EPOLLONESHOT 事件</strong></p><p>即使在 ET 模式下，一个 socket 上的某个事件还是可能被触发多次，在并发程序中，一个线程读取完某个 socket 上的数据后开始处理这些数据，但是在处理过程中该 socket 上又有新数据可读（EPOLLIN 被再次触发），此时另一个线程被唤醒来读取这些新的数据。此时出现了两个线程同时操作一个 socket 的局面</p><p>为此需要 EPOLLONESHOT 事件，one shot 不是对某一个事件的，而是针对某一个socket，也就是文件描述符，如果设置了epolloneshot，那么只会触发一次。防止一个线程在处理业务呢，然后来数据了，又从线程池里拿一个线程来处理新的业务，这样不就乱套了么。</p><blockquote><p>代码参考：<a href="ch9/9-4oneshot.cpp">9-4oneshot.cpp</a></p></blockquote><h4 id="9-4-三组-I-O-复用函数比较"><a href="#9-4-三组-I-O-复用函数比较" class="headerlink" title="9.4 三组 I/O 复用函数比较"></a>9.4 三组 I/O 复用函数比较</h4><p>selecet、poll 和 epoll 都通过某种结构体变量来告诉内核监听哪些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果</p><ul><li>select 参数类型 fd_set 没有将文件描述符和事件绑定，因此需要 3 个类型的参数分别区分可读、可写和异常事件，不能处理更多类型的事件，且下次调用时需要重置 3 个 fd_set 集合</li><li>poll 通过参数类型 pollfd 将文件描述符和事件都定义在其中，支持更多的事件类型，且下次调用 poll 时无需重置 pollfd 类型的事件集参数，因为内核修改的仅仅是 revents 成员</li><li>select 和 poll 调用返回整个用户注册的事件集合（包括就绪和未就绪的），通过<strong>「轮询扫描」</strong>索引就绪文件描述符的时间复杂度为 O(n)，epoll 通过 epoll_wait 直接从 epollfd 指定的内核事件表中取得用户注册的事件，内核检测到就绪的文件描述符将触发<strong>「回调函数」</strong>将该文件描述符上对应的事件插入「内核就绪队列」，且通过 events 参数仅仅用来返回就绪的事件，索引就绪的 fd 事件复杂度为 O(1)</li><li>poll 和 epoll_wait 分别使用 nfds 和 maxevents 参数指定最多监听的 fd 和 事件，最大 65535，但是 select 一般是 1024</li><li>poll 和 select 只能工作在相对低效的 LT 模式，epoll 可以在 ET 模式，且还支持 EPOLLONESHOT 事件</li></ul><blockquote><p>具体区别参考表格 9-2 </p></blockquote><h4 id="9-5-I-O-复用的高级应用一：非阻塞-connect"><a href="#9-5-I-O-复用的高级应用一：非阻塞-connect" class="headerlink" title="9.5 I/O 复用的高级应用一：非阻塞 connect"></a>9.5 I/O 复用的高级应用一：非阻塞 connect</h4><p>connect 出错时有一个 errno 值：EINPROGRESS，<strong>这种错误发生在非阻塞的 socket 调用 connect，而连接又没有立即建立时</strong>。根据 man 文档的解释，在这种情况下，我们可以调用 select、poll 等函数来监听这个连接失败的 socket 上的<strong>可写事件</strong>。当select、poll 等函数返回后，再利用 getsockopt 来读取错误码并清除该 socket 上的错误。如果错误码是0，表示连接成功建立，否则连接失败。</p><blockquote><p>代码参考：<a href="ch9/9-5unblockconnect.cpp">9-5unblockconnect.cpp</a></p></blockquote><h4 id="9-6-I-O-复用的高级应用二：聊天室程序"><a href="#9-6-I-O-复用的高级应用二：聊天室程序" class="headerlink" title="9.6 I/O 复用的高级应用二：聊天室程序"></a>9.6 I/O 复用的高级应用二：聊天室程序</h4><p>客户端程序有两个功能：</p><ul><li>从标准输人终端读入用户数据，并将用户数据发送至服务器</li><li>往标准输出终端打印服务器发送给它的数据</li></ul><blockquote><p>代码参考：<a href="ch9/9-6mytalk_client.cpp">9-6mytalk_client.cpp</a></p></blockquote><p>服务器的功能</p><ul><li>接收客户数据</li><li>把客户数据发送给每一个登录到该服务器上的客户端（数据发送者除外)</li></ul><blockquote><p>代码参考：<a href="ch9/9-7mytalk_server.cpp">9-7mytalk_server.cpp</a></p></blockquote><h4 id="9-7-I-O-复用的高级应用二：同时处理-TCP-和-UDP-服务"><a href="#9-7-I-O-复用的高级应用二：同时处理-TCP-和-UDP-服务" class="headerlink" title="9.7  I/O 复用的高级应用二：同时处理 TCP 和 UDP 服务"></a>9.7  I/O 复用的高级应用二：同时处理 TCP 和 UDP 服务</h4><p>代码参考：<a href="ch9/9-8multi_port.cpp">9-8multi_port.cpp</a></p><h4 id="9-8-超级服务-xinetd"><a href="#9-8-超级服务-xinetd" class="headerlink" title="9.8 超级服务 xinetd"></a>9.8 超级服务 xinetd</h4><p>Linux 因特网服务 inetd 是超级服务。它同时管理着多个子服务，即监听多个遄口。现在 Linux 系统上使用的 inetd 服务程序通常是其升级版本 xinetd。 xinetd 程序的原理与 inetd 相同，但增加了一些控制选项，并提高了安全性。</p><h3 id="Ch-10-信号"><a href="#Ch-10-信号" class="headerlink" title="Ch.10 信号"></a>Ch.10 信号</h3><p>信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。Linux 信号可由如下条件产生：</p><ul><li>对于前台进程，用户可以通过输人特殊的终端字符来给它发送信号。比如输入 Ctrl+C 通常会给进程发送一个中断信号</li><li>系统异常。比如浮点异常和非法内存段访问</li><li>系统状态变化。比如 alarm 定时器到期将引起 SIGALRM 信号</li><li>运行 kill 命令或调用 kill 函数</li></ul><h4 id="10-1-Linux-信号概述"><a href="#10-1-Linux-信号概述" class="headerlink" title="10.1 Linux 信号概述"></a>10.1 Linux 信号概述</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span><span class="token comment">// 把信号 sig 发给目标进程 pid</span><span class="token comment">// pid &gt; 0 : 将信号发送给指定的进程</span><span class="token comment">// pid = 0 : 将信号发送给当前的进程组</span><span class="token comment">// pid = -1 : 将信号发送给每一个有权限接收这个信号的进程</span><span class="token comment">// pid &lt; -1 : 这个pid=某个进程组的ID取反 （-12345）</span><span class="token keyword">int</span> <span class="token function">kill</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 成功返回 0，失败 -1 并设置 errno</span><span class="token comment">// 信号处理函数原型</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>__sighandler_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>linux 信号有很多，和网络编程关系紧密的是：</p><ul><li>SIGHUP：控制终端挂起</li><li>SIGPIPE：往读端被关闭的管道或者 socket 连接中写数据</li><li>SIGURG：socket 连接上接受到紧急数据</li><li>SIGALRM：由 <a href="nowcoder/2.21-signal-alarm/alarm.c">alarm.c</a> 或 <a href="nowcoder/2.21-signal-alarm/setitimer.c">setitimer.c</a> 设置的实时闹钟超时引起</li><li>SIGCHLD：子进程状态发生变化（退出或暂停）</li></ul><h4 id="10-2-信号函数"><a href="#10-2-信号函数" class="headerlink" title="10.2 信号函数"></a>10.2 信号函数</h4><h5 id="signal-系统调用"><a href="#signal-系统调用" class="headerlink" title="signal 系统调用"></a>signal 系统调用</h5><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span><span class="token comment">// sig 参数指出要捕获的信号类型，</span><span class="token comment">// _handler 参数是函数指针，用于指定信号 sig 的处理函数</span><span class="token comment">//- SIG_IGN ： 忽略信号</span><span class="token comment">// - SIG_DFL ： 使用信号默认的行为</span><span class="token comment">//- 回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号</span><span class="token comment">// [return] 成功，返回上一次注册的信号处理函数的地址。第一次调用返回 NULL</span><span class="token comment">//          失败，返回 SIG_ERR，设置错误号</span>_sighandler_t <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span> _sighandler_t handler<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>回调函数：</p><ul><li>需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义</li><li>不是程序员调用，而是当信号产生，由内核调用</li><li>函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了</li></ul><p>代码参考：<a href="nowcoder/2.21-signal-alarm/signal.c">signal.c</a></p><h5 id="sigaction-系统调用"><a href="#sigaction-系统调用" class="headerlink" title="sigaction 系统调用"></a>sigaction 系统调用</h5><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span><span class="token comment">// sig 指出要捕获的信号类型</span><span class="token comment">// act 参数指定新的信号处理方式</span><span class="token comment">// oact 输出信号先前的处理方式（如果不为 NULL 的话）</span><span class="token comment">// [return] 成功 0，失败 -1 并设置 errno</span><span class="token keyword">int</span> <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span><span class="token operator">*</span> act<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span><span class="token operator">*</span> oact<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 参考 P181</span></code></pre><p>代码参考：<a href="nowcoder/2.21-signal-alarm/sigaction.c">sigaction.c</a></p><h4 id="10-3-信号集"><a href="#10-3-信号集" class="headerlink" title="10.3 信号集"></a>10.3 信号集</h4><p>在 PCB 中有两个非常重要的信号集。一个称之为 「<strong>阻塞信号集</strong>」，另一个称之为 「<strong>未决信号集</strong>」 。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我 们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数 来对 PCB 中的这两个信号集进行修改。</p><ul><li>信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间，未决信号集不能修改只能获取</li><li>信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生，阻塞信号集可以修改</li></ul><h5 id="信号集函数"><a href="#信号集函数" class="headerlink" title="信号集函数"></a>信号集函数</h5><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sigset.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token expression"><span class="token function">_SIGSET_NWORDS</span> <span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>tydedef <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> __val<span class="token punctuation">[</span>_SIGSET_NWORDS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> __sigset_t<span class="token punctuation">;</span> <span class="token comment">// 其实就是一个长整型数组</span><span class="token comment">// 对「自定义」的信号集进行操作</span><span class="token keyword">int</span> <span class="token function">sigemptyset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清空信号集数据</span><span class="token keyword">int</span> <span class="token function">sigfillset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将信号集中所有标志位置为 1</span><span class="token keyword">int</span> <span class="token function">sigaddset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号</span><span class="token keyword">int</span> <span class="token function">sigdelset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号</span><span class="token keyword">int</span> <span class="token function">sigismember</span><span class="token punctuation">(</span><span class="token keyword">const</span> sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 判断某个信号是否阻塞</span></code></pre><p>代码参考：<a href="nowcoder/2.24-sigset/sigset.c">sigset.c</a></p><h5 id="进程信号掩码（阻塞信号集）"><a href="#进程信号掩码（阻塞信号集）" class="headerlink" title="进程信号掩码（阻塞信号集）"></a>进程信号掩码（阻塞信号集）</h5><p>sigprocmask 可以将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span><span class="token comment">// _set 参数指定新的信号掩码，</span><span class="token comment">// _how 指定设置掩码方式，假设内核中默认的阻塞信号集是mask</span><span class="token comment">//- SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变，mask | set</span><span class="token comment">//- SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞，mask &amp;= ~set</span><span class="token comment">//- SIG_SETMASK: 覆盖内核中原来的值</span><span class="token comment">// _oset 参数输出原来的信号掩码（如果不为 NULL 的话）</span><span class="token comment">// [return] 成功 0，失败 -1 并设置 errno</span><span class="token keyword">int</span> <span class="token function">sigprocmask</span><span class="token punctuation">(</span><span class="token keyword">int</span> _how<span class="token punctuation">,</span> _const sigset_t<span class="token operator">*</span> _set<span class="token punctuation">,</span> sigset_t<span class="token operator">*</span> _oset<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>代码参考：<a href="nowcoder/2.24-sigset/sigprocmask.c">sigprocmask.c</a></p><h5 id="被挂起的信号（未决信号集）"><a href="#被挂起的信号（未决信号集）" class="headerlink" title="被挂起的信号（未决信号集）"></a>被挂起的信号（未决信号集）</h5><p><strong>设置进程信号掩码后，被屏蔽的信号将不能被进程接收</strong>。如果给进程发送一个被屏蔽的信号，则操作系统将该信号设置为进程的一个<strong>被挂起的信号</strong>。如果我们取消对被挂起信号的屏蔽，则它能立即被进程接收到。如下两数可以获得进程当前被挂起的信号集</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span><span class="token comment">// 获取进程当前被挂起的信号集（未决信号集）</span><span class="token comment">// [return] 成功 0，失败 -1 并设置 errno</span><span class="token keyword">int</span> <span class="token function">sigpending</span><span class="token punctuation">(</span>sigset_t<span class="token operator">*</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="10-4-统一事件源"><a href="#10-4-统一事件源" class="headerlink" title="10.4 统一事件源"></a>10.4 统一事件源</h4><p>信号是一种异步事件：信号处理两数和程序的主循环是两条不同的执行路线。很显然，信号处理函数需要尽可能快地执行完毕，以确保该信号不被屏蔽（前面提到过，为了避免一些竞态条件，信号在处理期间，系统不会再次触发它）太久。一种典型的解决方案是：</p><p>把信号的主要处理逻辑放到程序的主循环中，当信号处理函数被触发时，它只是简单地通知主循环程序接收到信号，并把信号值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。信号处理函数通常使用管道来将信号 “传递”给主循环：<strong>信号处理函数往管道的写端写人信号值</strong>，主循环则从管道的读端读出该信号值。<strong>那么主循环怎么知道管道上何时有数据可读呢？</strong>这很简单，我们只需要使用 I/O 复用系统调用来<strong>监听管道的读端文件描述符</strong>上的可读事件。如此一来，信号事件就能和其他 I/O 事件一样被处理，即统一事件源。</p><blockquote><p>代码参考：<a href="ch10/10-1unievent.cpp">10-1unievent.cpp</a></p></blockquote><h4 id="10-5-网络编程相关的信号"><a href="#10-5-网络编程相关的信号" class="headerlink" title="10.5 网络编程相关的信号"></a>10.5 网络编程相关的信号</h4><p><strong>SIGHUP</strong>：书中展示了 xinetd 程序接收并处理 SIGHUP 信号的流程</p><p><strong>SIGPIPE</strong>：往一个读端关闭的管道或 socket 连接中写数据会引发 SIGPIPE 信号，两种方式检测该信号：</p><ul><li>send 函数加入 MSG_NOSIGNAL 标志可以进制写操作触发 SIGPIPE 信号，否则就会失败并设置 errno，根据 errno 值来判断管道或者 socket 连接的读端是否已经关闭</li><li>poll 系统调用在管道读端关闭时，写端文件描述符上的 POLLHUP 会被触发，socket 被对方关闭时，socket 上的 POLLRDHUP 事件会被触发</li></ul><p><strong>SIGURG</strong>：socket 接收到紧急数据时触发，两种方式检测带外数据：</p><ul><li>select 系统调用接收到带外数据返回时会向应用程序报告 socket 上的异常事件 exception_fds</li><li>检测 SIGURG 信号，设置该信号的处理函数</li></ul><h3 id="Ch-11-定时器"><a href="#Ch-11-定时器" class="headerlink" title="Ch.11 定时器"></a>Ch.11 定时器</h3><h4 id="11-1-socket-选项-SO-RCVTIMEO-SO-SNDTIMEO"><a href="#11-1-socket-选项-SO-RCVTIMEO-SO-SNDTIMEO" class="headerlink" title="11.1 socket 选项 SO_RCVTIMEO/SO_SNDTIMEO"></a>11.1 socket 选项 SO_RCVTIMEO/SO_SNDTIMEO</h4><p>这两个参数分别表示 socket 接受数据超时时间和发送数据超时时间，这个选项只针对 send, sendmsg, recv, recvmsg, accept, connect 有效</p><blockquote><p>代码参考：<a href="ch11/11-1connect_timeout.cpp">11-1connect_timeout.cpp</a></p></blockquote><h4 id="11-2-SIGALRM-信号"><a href="#11-2-SIGALRM-信号" class="headerlink" title="11.2 SIGALRM 信号"></a>11.2 SIGALRM 信号</h4><p>第10章提到，由alarm 和 setitimer 兩数设置的实时闹钟一旦超时，将触发 SIGALRM 信号。因此可以利用该信号的<strong>信号处理函数来处理定时任务</strong>。但是，如果要处理我个定时任务，我们就需要不断地触发 SIGALRM 信号，并在其信号处理函数中执行到期的任务。一般而言，SIGALRM 信号按照固定的频率生成，即由 alarm 或 setitimer 函数设置的定时周期 T 保持不变。如果某个定时任务的超时时间不是 T 的整数倍，那么它实际被执行的时间和预期的时间将略有偏差。</p><h5 id="11-2-1-基于升序链表的定时器"><a href="#11-2-1-基于升序链表的定时器" class="headerlink" title="11.2.1 基于升序链表的定时器"></a>11.2.1 基于升序链表的定时器</h5><p>其核心函数 tick 相当于一个心搏函数，它每隔一段固定的时间就执行一次，以检测并处理到期的任务。判断定时任务到期的依据是定时器的 expire 值小于当前的系统时间。从执行效率来看，添加定时器的时向复杂度是 O(n)，删除定时器的时间复杂度是 O(1)，执行定时任务的时间复杂度是 O(1)</p><blockquote><p>代码参考：<a href="ch11/11-2lst_timer.h">11-2lst_timer.h</a></p></blockquote><h5 id="11-2-2-处理非活动连接"><a href="#11-2-2-处理非活动连接" class="headerlink" title="11.2.2 处理非活动连接"></a>11.2.2 处理非活动连接</h5><p>服务器程序通常要定期处理非活动连接：给客户端发一个重连请求，或者关闭该连接，或者其他。Linux 在内核中提供了对连接是否处于活动状态的定期检查机制，我们可以通过 socket 选项 KEEPALIVE 来激活它。不过使用这种方式将使得应用程序对连接的管理变得复杂。因此，我们可以考虑在应用层实现类似于 KEEPALIVE 的机制，以管理所有长时间处于非活动状态的连接。代码清单 11-3 利用alarm 函数周期性地触发 SIGALRM 信号，该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务——关闭非活动的连接。</p><blockquote><p>代码参考：<a href="ch11/11-3nonactive_conn.cpp">11-3nonactive_conn.cpp</a></p></blockquote><h4 id="11-3-I-O-复用系统调用的超时参数"><a href="#11-3-I-O-复用系统调用的超时参数" class="headerlink" title="11.3 I/O 复用系统调用的超时参数"></a>11.3 I/O 复用系统调用的超时参数</h4><p>Linux 下的 3 组 I/O 复用系统调用都带有超时参数，因此它们不仅能统一处理信号和 I/O 事件，也能统一处理定时事件。但是由于 I/O 复用系统调用可能在超时时间到期之前就返回（有 I/O 事件发生），所以如果我们要利用它们来定时，就需要不断更新定时参数以反映剩余的时间</p><blockquote><p>代码参考：<a href="ch11/11-4io_timer.cpp">11-4io_timer.cpp</a></p></blockquote><h4 id="11-4-高性能定时器"><a href="#11-4-高性能定时器" class="headerlink" title="11.4 高性能定时器"></a>11.4 高性能定时器</h4><p><strong>时间轮</strong></p><p>前面的基于排序链表的定时器添加定时器的效率偏低，为此考虑更高效的时间轮</p><p>基于排序链表的定时器使用唯一的一条链表来管理所有定时器，所以插人操作的效率随着定时器数目的增多而降低。而<strong>时间轮使用哈希表的思想，将定时器散列到不同的链表上</strong>。这样每条链表上的定时器数目都将明显少于原来的排序链表上的定时器数目，插人操作的效率基本不受定时器数目的影响。</p><blockquote><p>代码参考：<a href="ch11/11-5tw_timer.h">11-5tw_timer.h</a></p></blockquote><p><strong>时间堆</strong></p><p>前面讨论的定时方案都是以固定的频率调用心搏函数 tick，并在其中依次检测到期的定时器，然后执行到期定时器上的回调函数。设计定时器的另外一种思路是：<strong>将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔</strong>。这样，一旦心搏函数 tick 被调用，超时时间最小的定时器必然到期，我们就可以在 tick 函数中处理该定时器。然后，再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。如此反复，就实现了较为精确的定时。</p><blockquote><p>代码参考：<a href="ch11/11-6time_heap.h">11-6time_heap.h</a> 没太看懂</p></blockquote><h3 id="Ch-12-高性能-I-O-框架库-Libevent"><a href="#Ch-12-高性能-I-O-框架库-Libevent" class="headerlink" title="Ch.12 高性能 I/O 框架库 Libevent"></a>Ch.12 高性能 I/O 框架库 Libevent</h3><h4 id="12-1-I-O-框架库概述"><a href="#12-1-I-O-框架库概述" class="headerlink" title="12.1 I/O 框架库概述"></a>12.1 I/O 框架库概述</h4><ul><li>句柄：I/O 框架库要处理的对象，即 I/O 事件、信号和定时事件</li><li>事件多路分发器：I/O 框架库一般将系统支持的各种 I/O 复用系统调用封装成统一的接口</li><li>事件处理器：包含一个或多个 handle_event 回调函数</li><li>具体事件处理器：继承事件处理器的接口实现自己的事件处理器</li></ul><h4 id="12-2-Libevent-源码分析"><a href="#12-2-Libevent-源码分析" class="headerlink" title="12.2 Libevent 源码分析"></a>12.2 Libevent 源码分析</h4><p>TODO 略</p><h3 id="Ch-13-多进程编程"><a href="#Ch-13-多进程编程" class="headerlink" title="Ch.13 多进程编程"></a>Ch.13 多进程编程</h3><h4 id="13-1-fork-系统调用"><a href="#13-1-fork-系统调用" class="headerlink" title="13.1 fork 系统调用"></a>13.1 fork 系统调用</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token comment">// 返回两次，父进程返回的子进程的 PID，子进程中返回 0，失败 -1</span>pid_t <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>fork 函数复制当前进程，在内核进程表中创建一个新的进程表项。新的进程表项有很多属性和原进程相同，比如<strong>堆指针、栈指针和标志寄存器的值</strong>。但也有许多属性被赋予了新的值，比如该进程的 PPID 被设置成原进程的 PID，信号位图被清除（原进程设置的信号处理函数不再对新进程起作用)，fork() 之后的父子进程共享文件，此时的 fork() 产生的子进程与父进程相同的文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针</p><p><strong>父子进程虚拟地址空间</strong></p><p>Linux 的 fork() 使用是通过<strong>写时拷贝（copy-on-write）</strong>实现。写时拷贝是一种<strong>可以推迟甚至避免拷贝数据的技术</strong>。内核并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只有在写入时才会复制地址空间（重新开辟一块内存），从而使各个进程拥有自己的地址空间。即资源的复制只有在写入时才会进行，在此之前，只有以只读的方式进行，即所谓的<strong>「读时共享，写时拷贝」</strong></p><p><strong>GDB 多进程调试</strong></p><p>gdb 默认只能跟踪一个进程，<a href="https://www.nowcoder.com/study/live/504/2/5">视频</a></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 设置调试父进程或者子进程</span><span class="token builtin class-name">set</span> follow-fork-mode <span class="token punctuation">[</span>parent<span class="token punctuation">(</span>默认<span class="token punctuation">)</span><span class="token operator">|</span>child<span class="token punctuation">]</span><span class="token comment"># on 表示调试当前进程时其他进程继续运行，off 表示调试当前进程时其他进程被 GDB 挂起</span><span class="token builtin class-name">set</span> detach-on-fork <span class="token punctuation">[</span>on<span class="token punctuation">(</span>默认<span class="token punctuation">)</span><span class="token operator">|</span>off<span class="token punctuation">]</span><span class="token comment"># 查看调试的进程</span>info inferiors<span class="token comment"># 切换当前调试的进程</span>inferior <span class="token function">id</span><span class="token comment"># 使进程脱离 GDB 调试</span>detach inferiors <span class="token function">id</span></code></pre><h4 id="13-2-exec-系列系统调用"><a href="#13-2-exec-系列系统调用" class="headerlink" title="13.2 exec 系列系统调用"></a>13.2 exec 系列系统调用</h4><p>需要在子进程种执行其他程序，即替换当前进程映像，就需要使用 exec 系列函数 <a href="https://blog.csdn.net/u014530704/article/details/73848573">参考</a></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token keyword">extern</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> environ<span class="token punctuation">;</span><span class="token comment">// path 参数指定可执行文件的完整路径</span><span class="token comment">// file 参数接受文件名</span><span class="token comment">// avg 接受可变参数，argv 接受参数数组</span><span class="token comment">// envp 设置新程序的环境变量</span><span class="token comment">// 传可变参数list，NULL 结尾，execlp("ps", "ps", "-l", NULL)</span><span class="token keyword">int</span> <span class="token function">execl</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execle</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 传参数的指针数组，char *argv[] = {"ps","-l",NULL};</span><span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">execvpe</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// l(list) 参数地址列表，以空指针结尾</span><span class="token comment">// v(vector) 存有各参数地址的指针数组的地址</span><span class="token comment">// p(path) 按 PATH 环境变量指定的目录搜索可执行文件</span><span class="token comment">// e(environment) 存有环境变量字符串地址的指针数组的地址</span></code></pre><p>一般情况下，exec 函数是不返回的，除非出错。它出错时返回-1，并设置 errno。 如果没出错，则原程序中 exec 调用之后的代码都不会执行，因为此时原程序己经被 exec 的参数指定的程序完全替换（包括代码和数据）。<strong>exec 函数不会关闭原程序打开的文件描述符</strong>，除非该文件描述符被设置了类似 SOCK_CLOEXEC 的属性（见5.2节）。</p><h4 id="13-3-处理僵尸进程"><a href="#13-3-处理僵尸进程" class="headerlink" title="13.3 处理僵尸进程"></a>13.3 处理僵尸进程</h4><p>每个进程结束之后都会释放自己地址空间中的用户区数据，内核区的 PCB 没办自己释放掉（pid ppid 等），需要父进程释放</p><ul><li>在子进程结束运行之后，父进程尚未回收，子进程残留资源(PCB)存放于内核中，即父进程读取其退出状态之前，该子进程就是<strong>僵尸进程</strong></li><li>父进程结束或者异常终止，而子进程继续运行（<strong>孤儿进程</strong>）。此时子进程的 PPID 将被操作系统设置为 1，即 <strong>init 进程</strong>。init 进程接管了该子进程，并等待它结束。</li></ul><p>通过下面的系统调用，在父进程中调用等待子进程的结束，并获取子进程的返回信息，从而避免僵尸进程的产生，或者使子进程的僵尸状态立即结束</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span><span class="token comment">// 阻塞，pid_t 是结束子进程的进程 id，stat_loc 可以保留相关信息，通过相关的宏函数可以查看</span>pid_t <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> stat_loc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 只等待 pid 指定的子进程，为 -1 时与 wait 一样</span><span class="token comment">// options 指定 WNOHANG 参数可以非阻塞：如果 pid 子进程还未结束或者意外终止直接返回 0</span>pid_t <span class="token function">waitpid</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> stat_loc<span class="token punctuation">,</span> <span class="token keyword">int</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>要在事件已经发生的情况下执行非阻塞调用才能提高程序的效率。对 waitpid 函数而言，我们最好在某个子进程退出之后再调用它。那么父进程从何得知某个子进程已经退出了呢？这正是 SIGCHLD 信号的用途。<strong>当一个进程结束时，它将给其父进程发送一个SIGCHLD 信号</strong>。因此，我们可以在父进程中捕获SIGCHLD 信号，并在信号处理函数中调用 waitpid 函数以“彻底结束”一个子进程</p><p><strong>进程退出</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 标准 C 库函数，会刷新缓冲区</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Linux 系统调用，不会刷新缓冲区</span></code></pre><h4 id="13-4-管道"><a href="#13-4-管道" class="headerlink" title="13.4 管道"></a>13.4 管道</h4><p><strong>匿名管道(pipe)</strong> 能在父子进程间传递数据，一般来说是单向的，只能保证父子进程之间一个方向的数据，父子进程必须有一个关闭 fd[0]、另一个关闭 fd[1]，如果要实现父子进程之间的双向数据传输就必须使用两个管道。</p><blockquote><p>书中描述了 squid 如何使用 socketpair 系统调用创建一个全双工管道的</p></blockquote><p>匿名管道默认是阻塞的：如果管道中没有数据，read 阻塞，如果管道满了，write 阻塞</p><p><strong>有名管道(FIFO)</strong> 不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样 即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此 通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。</p><p>有名管道(FIFO) 和 匿名管道(pipe) 有一些特点是相同的，例如默认的阻塞行为：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 默认 FIFO 和 PIPE 都是阻塞的，读写端关闭或者打开时对方的行为是类似的：</span>读管道：    管道中有数据，read返回实际读到的字节数    管道中无数据：        写端被全部关闭，read返回0（相当于读到文件的末尾）        写端没有完全关闭，read阻塞等待写管道：    管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）    管道读端没有全部关闭：        管道已满，write阻塞        管道没有满，write将数据写入，并返回实际写入的字节数</code></pre><p>不一样的地方在于：</p><ul><li>FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中</li><li>当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用</li><li>FIFO 有名字，不相关的进程可以通过打开有名管道进行通信</li></ul><h4 id="13-5-信号量"><a href="#13-5-信号量" class="headerlink" title="13.5 信号量"></a>13.5 信号量</h4><p><strong>信号量原语</strong></p><p>关键代码段/临界区代码会引发进程之间的竞态条件，进程同步需要确保任一时刻只有一个进程能进入关键代码段。Dekker 算法和 Peterson 算法通过忙等待解决同步问题，CPU 利用率低；Dijkstra 提出的信号量（Semaphore）通过 P、V 操作实现。</p><p>信号量取值可以是任何自然数，最常用的 0 1 是Mutex，Linux 相关的系统调用是 semget、semop 和 semctl，内核中与信号量相关联的数据结构是 semid_ds</p><p><strong>semget</strong> </p><p>semget 系统调用创建一个新的信号量集（会修改内核数据结构体 semid_ds），或者获取一个已经存在的信号量集</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/sem.h&gt;</span></span><span class="token comment">// key 参数标识一个全局唯一的信号量集合</span><span class="token comment">// num_sems 指定要创建/获取的信号量集中信号量的数目，0 标识获取已经存在的信号量</span><span class="token comment">// sem_flags 参数指定一组标志</span><span class="token comment">// [return] 成功返回一个正整数表示信号量集的标识符，失败 -1 并设置 errno</span><span class="token keyword">int</span> <span class="token function">semget</span><span class="token punctuation">(</span>ket_t key<span class="token punctuation">,</span> <span class="token keyword">int</span> num_sems<span class="token punctuation">,</span> <span class="token keyword">int</span> sem_flags<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>key 可以传递一个特殊的键值 IPC_PRIVATE（值为0），这样无论信号量是否已经存在，semget 都将创建一个新的信号量。所有其他进程都可以使用这个新创建的信号量</p><p><strong>semop</strong> </p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/sem.h&gt;</span></span><span class="token comment">// sem_id 是 semget 返回的信号量集标识符</span><span class="token comment">// sem_ops 指向一个 sembuf 结构体类型的数组</span><span class="token comment">// num_sem_ops 指定要执行的操作个数</span><span class="token keyword">int</span> <span class="token function">semop</span><span class="token punctuation">(</span><span class="token keyword">int</span> sem_id<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sembuf</span><span class="token operator">*</span> sem_ops<span class="token punctuation">,</span> size_t num_sem_ops<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这个 sembuf 结构体中 sem_flg 和 sem_op 关系有点复杂，没看懂o(╥﹏╥)o</p><p><strong>semctl</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/sem.h&gt;</span></span><span class="token comment">// sem_id 是 semget 返回的信号量集标识符</span><span class="token comment">// sem_num 指定被操作的信号量在信号量集中的编号</span><span class="token comment">// command 指定要执行的命令</span><span class="token keyword">int</span> <span class="token function">semctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> sem_id<span class="token punctuation">,</span> <span class="token keyword">int</span> sem_num<span class="token punctuation">,</span> <span class="token keyword">int</span> command<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>代码参考：<a href="ch13/13-3sem.cpp">13-3sem.cpp</a></p></blockquote><h4 id="13-6-共享内存"><a href="#13-6-共享内存" class="headerlink" title="13.6 共享内存"></a>13.6 共享内存</h4><p>共享内存是最高效的 IPC 机制，他不涉及进程之间的任何数据传输，内核中与共享内存相关联的数据结构是 shmid_ds</p><p><strong>shmget</strong></p><p>和 semget 一样，shmget 系统调用创建一段新的共享内存或者获取一段已经存在的共享内存</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h&gt;</span></span><span class="token comment">// key 表示一段全局唯一的共享内存，非零值，一般是 16 进制</span><span class="token comment">// size 指定共享内存的大小，单位 byte，为 0 表示获取已经存在的共享内存</span><span class="token comment">// shmflg 和 sem_flags 类似</span><span class="token comment">// [return] 成功返回一个正整数标识共享内存的标识符，失败 -1 并设置 errno</span><span class="token keyword">int</span> <span class="token function">shmget</span><span class="token punctuation">(</span>key_t key<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>shmat 和 shmdt</strong></p><p>共享内存创建之后需要先将其关联到进程的地址空间才能使用</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// shm_id 是由 shmget 返回的共享内存标识符</span><span class="token comment">// shm_addr 指定共享内存关联到进程的那块地址空间，为 NULL 就由内核指定</span><span class="token comment">// shmflg 是一些标志 SHM_RND|SHM_RDONLY...</span><span class="token comment">// [return] 成功时返回共享内存被关联到的地址，失败返回 -1 并设置 errno</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span> shm_id<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> shm_addr<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用完共享内存之后还需要将它从进程地址空间分离</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 将关联到的 shm_addr 处的共享内存从进程中分离，失败 -1 并设置 errno</span><span class="token keyword">int</span> <span class="token function">shmdt</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> shm_addr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>shmctl</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.d&gt;</span></span><span class="token comment">// shm_id 是 shmget 返回的共享内存标识符</span><span class="token comment">// command 指定要执行的命令</span><span class="token comment">// [return] 成功返回值取决于 command，失败 -1 并设置 errno</span><span class="token keyword">int</span> <span class="token function">shmctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> shm_id<span class="token punctuation">,</span> <span class="token keyword">int</span> command<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span><span class="token operator">*</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>代码参考：<a href="nowcoder/2.28-shm/write_shm.c">write_shm.c</a> 与 <a href="nowcoder/2.28-shm/read_shm.c">read_shm.c</a> 进程通信传数据</p><p><strong>共享内存的POSIX方法</strong></p><p>mmap 函数利用它的 MAP ANONYMOUS 标志我们可以实现父、子进程之间的匿名内存共享。通过打开同一个文件，mmap 也可以实现无关进程之间的内存共享。Linux 提供了另外一种利用mmap 在无关进程之间共享内存的方式。这种方式无需任何文件的支特，但它需要先使用如下函数来创建或打开一个 POSIX 共享内存对象：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token comment">// 与 open 系统调用完全相同，shm_open 成功时返回一个文件描述符，失败 -1 并设置 errno</span><span class="token keyword">int</span> <span class="token function">shm_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// shm_open 创建的共享内存对象使用完之后需要删除</span><span class="token keyword">int</span> <span class="token function">shm_unlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里实现多进程的聊天服务器：一个子进程处理一个客户连接，所有客户 socket 连接的读缓冲设置为一块共享内存，实现”共享读“，每个子进程在使用共享内存时无需加锁</p><blockquote><p>代码参考：<a href="ch13/13-4shm_talk_server.cpp">13-4shm_talk_server.cpp</a></p></blockquote><h4 id="13-7-消息队列"><a href="#13-7-消息队列" class="headerlink" title="13.7 消息队列"></a>13.7 消息队列</h4><p>消息队列是在两个进程之间传递二进制块数据的一种简单有效的方式。每个数据块都有一个特定的类型，<strong>接收方可以根据类型来有选择地接收数据</strong>，而不一定像管道和命名管道那样必须以先进先出的方式接收数据。</p><p>同样的有 4 个系统调用：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span><span class="token comment">// 创建一个消息队列，或者获取一个已有的消息队列</span><span class="token keyword">int</span> <span class="token function">msgget</span><span class="token punctuation">(</span>key_t key<span class="token punctuation">,</span> <span class="token keyword">int</span> msgflg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将一条消息 msg_ptr 添加到消息队列</span><span class="token keyword">int</span> <span class="token function">msgsnd</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> msg_ptr<span class="token punctuation">,</span> size_t msg_sz<span class="token punctuation">,</span> <span class="token keyword">int</span> msgflg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 从消息队列中获取消息 msg_ptr</span><span class="token keyword">int</span> <span class="token function">msgrcv</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> msg_ptr<span class="token punctuation">,</span> size_t msg_sz<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">int</span> msgtype<span class="token punctuation">,</span> <span class="token keyword">int</span> msgflg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 控制消息队列的某些属性</span><span class="token keyword">int</span> <span class="token function">msgctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">int</span> command<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msqid_ds</span><span class="token operator">*</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="13-8-IPC-命令"><a href="#13-8-IPC-命令" class="headerlink" title="13.8 IPC 命令"></a>13.8 IPC 命令</h4><p>ipcs 命令可以显示 Linux 系统拥有的共享内存、信号量和消息队列资源使用情况</p><h4 id="13-9-在进程间传递文件描述符"><a href="#13-9-在进程间传递文件描述符" class="headerlink" title="13.9 在进程间传递文件描述符"></a>13.9 在进程间传递文件描述符</h4><p>由于 fork 调用之后，父进程中打开的文件描述符在子进程中仍然保持打开，所以文件描述符可以很方便地从父进程传递到子进程。需要注意的是，传递一个文件描述符并不是传递一个文件描述符的值，<strong>而是要在接收进程中创建一个新的文件描述符，并且该文件描述符和发送进程中被传递的文件描述符指向内核中相同的文件表项。</strong></p><p>那么如何把子进程中打开的文件描述符传递给父进程呢？或者更通俗地说，如何在两个不相于的进程之间传递文件描述符呢？在 Linux 下，我们可以利用 UNIX 域 socket 在进程间传递特殊的辅助数据，以实现文件描述符的传递。代码清单 13-5 给出了一个实例，它在子进程中打开一个文件描述符，然后将它传递给父进程，父进程则通过读取该文件描述符来获得文件的内容。</p><blockquote><p>代码参考：<a href="ch13/13-5passfd.cpp">13-5passfd.cpp</a></p></blockquote><h3 id="Ch-14-多线程编程"><a href="#Ch-14-多线程编程" class="headerlink" title="Ch.14 多线程编程"></a>Ch.14 多线程编程</h3><h4 id="14-1-Linux-线程概述"><a href="#14-1-Linux-线程概述" class="headerlink" title="14.1 Linux  线程概述"></a>14.1 Linux  线程概述</h4><p><strong>线程模型</strong></p><ul><li>内核线程：运行在内核空间，内核来调度，数量 M</li><li>用户线程：运行在用户空间，线程库来调度，数量 N</li></ul><p>内核线程相当于用户线程的容器，M &lt;= N，根据 M:N 取值将线程实现方式分为三种模式：完全在用户空间实现、完全由内核调度和双层调度</p><p><strong>Linux 线程库</strong>：LinuxThreads 和 NPTL 线程库</p><h4 id="14-2-创建线程和结束线程"><a href="#14-2-创建线程和结束线程" class="headerlink" title="14.2 创建线程和结束线程"></a>14.2 创建线程和结束线程</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span><span class="token comment">// pthread_t 是 unsigned long int 类型</span><span class="token comment">// attr 设置新线程的属性</span><span class="token comment">// start_routine 是函数指针，就是线程运行的函数，arg 是其参数</span><span class="token comment">// [return] 成功返回 0，失败返回错误码</span><span class="token keyword">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span>pthread_t<span class="token operator">*</span> thread<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_attr_t<span class="token operator">*</span> attr<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通过 retval 参数向线程的回收者传递其退出信息</span><span class="token keyword">void</span> <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> retval<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// thread 是目标线程的标识符</span><span class="token comment">// retval 是目标线程返回的退出信息</span><span class="token comment">// [return] 成功返回 0，失败返回错误码</span><span class="token keyword">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span> retval<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 会一直阻塞，知道被回收的线程结束</span><span class="token comment">// thread 是目标线程的标识符</span><span class="token keyword">int</span> <span class="token function">pthread_cancel</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>代码参考：<a href="nowcoder/3.2-pthread">3.2-pthread</a></p><h4 id="14-3-线程属性"><a href="#14-3-线程属性" class="headerlink" title="14.3 线程属性"></a>14.3 线程属性</h4><p>pthread_attr_t 结构体定义了一套完整的线程属性</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/pthreadtypes.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">union</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> __size<span class="token punctuation">[</span>__SIZEOF_PTHREAD_ATTR_T<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">int</span> __align<span class="token punctuation">;</span><span class="token punctuation">}</span> pthread_attr_t<span class="token punctuation">;</span><span class="token comment">// 初始化线程属性对象</span><span class="token keyword">int</span> <span class="token function">pthread_attr_init</span><span class="token punctuation">(</span>pthread_attr_t<span class="token operator">*</span> attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 销毁线程属性对象，被销毁的线程属性对象只有再次初始化之后才能继续使用</span><span class="token keyword">int</span> <span class="token function">pthread_attr_destroy</span><span class="token punctuation">(</span>pthread_attr_t<span class="token operator">*</span> attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取和设置线程属性对象的某个属性很熟有很多...</span></code></pre><h4 id="14-4-POSIX-信号量-three"><a href="#14-4-POSIX-信号量-three" class="headerlink" title="14.4 POSIX 信号量 :three:"></a>14.4 POSIX 信号量 <span class="github-emoji"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>POSIX 信号量函数都以 sem_ 开头</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span><span class="token comment">// 无名信号量</span><span class="token keyword">int</span> <span class="token function">sem_init</span><span class="token punctuation">(</span>sem_t<span class="token operator">*</span> sem<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sem_destroy</span><span class="token punctuation">(</span>sem_t<span class="token operator">*</span> sem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sem_wait</span><span class="token punctuation">(</span>sem_t<span class="token operator">*</span> sem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 信号量减1</span><span class="token keyword">int</span> <span class="token function">sem_trywait</span><span class="token punctuation">(</span>sem_t<span class="token operator">*</span> sem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// wait 的非阻塞版本</span><span class="token keyword">int</span> <span class="token function">sem_post</span><span class="token punctuation">(</span>sem_t<span class="token operator">*</span> sem<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 信号量加1</span><span class="token comment">// 有名信号量</span>sem_t <span class="token operator">*</span><span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">)</span><span class="token punctuation">;</span>  sem_t <span class="token operator">*</span><span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在选择使用有名信号量还是无名信号量时，需要根据具体的应用需求和场景进行考虑。如果需要在不同进程之间进行信号量共享或需要持久性的信号量，可以选择有名信号量。如果只需要在同一进程内的线程之间进行信号量共享，可以选择无名信号量。具体区别如下： <a href="https://blog.csdn.net/u014426028/article/details/105628740">参考</a></p><ol><li>命名和标识符：<ul><li>有名信号量具有一个唯一的标识符（名称），可以通过该标识符在不同进程之间进行共享。在创建有名信号量时，需要提供一个唯一的名称。</li><li>无名信号量没有名称，仅存在于创建它的进程中，无法在进程之间共享。</li></ul></li><li>共享：<ul><li>有名信号量可以在不同进程之间进行共享，允许多个进程访问同一个有名信号量，以实现进程间的同步和互斥。</li><li>无名信号量只能在同一进程内的线程之间进行共享，不能跨进程使用。</li></ul></li><li>持久性：<ul><li>有名信号量在系统中是持久性的，即创建它的进程终止后仍然存在。其他进程可以通过标识符（名称）访问和使用该信号量。</li><li>无名信号量是进程私有的，当创建它的进程终止时会自动被释放和销毁。</li></ul></li><li>访问控制：<ul><li>有名信号量可以通过权限控制机制（如文件系统权限）进行访问控制，可以限制哪些进程可以打开、读取和修改该信号量。</li><li>无名信号量没有访问控制机制，仅能在创建它的进程内部使用。</li></ul></li></ol><p>代码参考：<a href="nowcoder/3.8-thread-sync/semaphore.c">nowcoder-semaphore.c</a></p><h4 id="14-5-互斥锁-one"><a href="#14-5-互斥锁-one" class="headerlink" title="14.5 互斥锁 :one:"></a>14.5 互斥锁 <span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p><strong>基础 API</strong></p><p>互斥锁（也称互斥量）可以用于保护关键代码段，以确保其独占式的访向，这有点像一个二进制信号量（见 13.5.1 小节）。当进入关键代码段时，我们需要获得互斥锁并将其加锁。这等价于二进制信号量的P操作：当离开关键代码段时，我们需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程，这等价于二进制信号量的V操作。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span>pthread_mutex_t<span class="token operator">*</span> mutex<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_mutexatrr_t<span class="token operator">*</span> mutexattr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span>pthread_mutex_t<span class="token operator">*</span> mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span>pthread_mutex_t<span class="token operator">*</span> mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 互斥锁加锁</span><span class="token keyword">int</span> <span class="token function">pthread_mutex_trylock</span><span class="token punctuation">(</span>pthread_mutex_t<span class="token operator">*</span> mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lock 的非阻塞版本</span><span class="token keyword">int</span> <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span>pthread_mutex_t<span class="token operator">*</span> mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 互斥锁解锁</span></code></pre><p><strong>互斥锁属性</strong></p><p>pthread_mutexattr_t 结构体定义了一套完整的互斥锁属性</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span><span class="token comment">/*初始化互斥锁属性对象*/</span><span class="token keyword">int</span> <span class="token function">pthread_mutexattr_init</span><span class="token punctuation">(</span>pthread_mutexattr_t<span class="token operator">*</span> attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*销毁互斥锁属性对象*/</span><span class="token keyword">int</span> <span class="token function">pthread_mutexattr_destroy</span><span class="token punctuation">(</span>pthread_mutexattr_t<span class="token operator">*</span> attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*获取和设置互斥锁的 pshared 属性*/</span><span class="token keyword">int</span> <span class="token function">pthread_mutexattr_getpshared</span><span class="token punctuation">(</span><span class="token keyword">const</span> pthread_mutexattr_t<span class="token operator">*</span> attr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> pshared<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">pthread_mutexattr_setpshared</span><span class="token punctuation">(</span>pthread_mutexattr_t<span class="token operator">*</span> attr<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*获取和设置互斥锁的 type 属性*/</span><span class="token keyword">int</span> <span class="token function">pthread_mutexattr_gettype</span><span class="token punctuation">(</span><span class="token keyword">const</span> pthread_mutexattr_t<span class="token operator">*</span> attr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">pthread_mutexattr_settype</span><span class="token punctuation">(</span>pthread_mutexattr_t<span class="token operator">*</span> attr<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>pshared 参数指定是否允许跨进程共享互斥锁</li><li>type 参数指定互斥锁类型：普通锁、检错锁、嵌套锁、默认锁</li></ul><p><strong>死锁举例</strong></p><p>主线程获取 mutex_a 之后等待 mutex_b，子线程获取 mutex_b 之后等待 mutex_a</p><blockquote><p>代码参考：<a href="ch14/14-1mutual_lock.c">14-1mutual_lock.c</a></p></blockquote><h4 id="14-6-条件变量-two"><a href="#14-6-条件变量-two" class="headerlink" title="14.6 条件变量 :two:"></a>14.6 条件变量 <span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>条件变量用于在线程之间同步共享数据的值，需要配合互斥锁使用</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span>pthread_cond_t<span class="token operator">*</span> cond<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_condattr_t<span class="token operator">*</span> cond_attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span>pthread_cond_t<span class="token operator">*</span> cond<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">pthread_cond_broadcast</span><span class="token punctuation">(</span>pthread_cond_t<span class="token operator">*</span> cond<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 广播方式唤醒所有等待目标条件变量的线程</span><span class="token keyword">int</span> <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span>pthread_cond_t<span class="token operator">*</span> cond<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 唤醒一个等待目标条件变量的线程</span><span class="token comment">// 当这个函数调用阻塞的时候，会对互斥锁进行解锁，当不阻塞的，继续向下执行，会重新加锁</span><span class="token keyword">int</span> <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span>pthread_cond_t<span class="token operator">*</span> cond<span class="token punctuation">,</span> pthread_mutex_t<span class="token operator">*</span> mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>代码参考：<a href="nowcoder/3.8-thread-sync/cond.c">nowcoder-cond.c</a></p><h4 id="14-7-线程同步机制包装类"><a href="#14-7-线程同步机制包装类" class="headerlink" title="14.7 线程同步机制包装类"></a>14.7 线程同步机制包装类</h4><p>将 sem、mutex 和 cond 封装成类</p><blockquote><p>代码参考：<a href="ch14/14-2locker.h">14-2locker.h</a></p></blockquote><h4 id="14-8-多线程环境"><a href="#14-8-多线程环境" class="headerlink" title="14.8 多线程环境"></a>14.8 多线程环境</h4><p><strong>可重入函数</strong></p><p>一个函数能被多个线程同时调用且不发生竞态条件，那就是线程安全的，该函数就是可重入函数，Linux 库函数中 inet_ntoa、getservbyname 等函数是不可重入的，主要是因为它们内部使用了静态变量。</p><p>不过 Linux 对很多不可重入的库函数提供了对应的可重入版本，原函数尾部加上 _r，多线程编程中一定要使用可重入版本</p><p><strong>线程和进程</strong></p><p>思考这样一个问题：如果一个多线程程序的某个线程调用了 fork 函数，那么新创建的子进程是否将自动创建和父进程相同数量的线程呢？答案是 “否”，</p><p>正如我们期望的那样。<strong>子进程只拥有一个执行线程，它是调用 fork 的那个线程的完整复制。并且子进程将自动继承父进程中互斥锁（条件变量与之类似）的状态。</strong>也就是说，父进程中已经被加锁的互斥锁在子进程中也是被锁住的。</p><p>这就引起了一个问题：子进程可能不清楚从父进程继承而来的互斥锁的具体状态（是加锁状态还是解锁状态）。这个互斥锁可能被加锁了，但并不是由调用 fork 函数的那个线程锁住的，而是由其他线程锁住的。如果是这种情况，则子进程若再次对该互斥锁执行加锁操作就会导致死锁，如代码清单 14-3 所示。</p><blockquote><p>代码参考：<a href="ch14/14-3thread_atfork.c">14-3thread_atfork.c</a></p></blockquote><p><strong>线程与信号</strong></p><p>多线程版本下的信号掩码设置函数为</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">pthread_sigmask</span><span class="token punctuation">(</span><span class="token keyword">int</span> how<span class="token punctuation">,</span> <span class="token keyword">const</span> sigset_t<span class="token operator">*</span> newmask<span class="token punctuation">,</span> sigset_t<span class="token operator">*</span> oldmask<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>由于进程中的所有线程共享该进程的信号，所以线程库将根据<strong>线程掩码</strong>决定把信号发送给哪个具体的线程。因此，如果我们在每个子线程中都单独设登信号掩码，就很容易导致逻辑错误。此外，<strong>所有线程共享信号处理函数</strong>。也就是说，当我们在一个线程中设置了某个信号的信号处理函数后，它将覆盖其他线程为同一个信号设置的信号处理函数。这两点都说明，我们应该定义一个专门的线程来处理所有的信号。这可以通过如下两个步骤来实现：</p><ol><li><p>在主线程创建出其他子线程之前就调用 pthread_sigmask 来设置好信号掩码，所有新创建的子线程都将自动继承这个信号掩码。这样做之后，实际上所有线程都不会响应被屏蔽的信号了</p></li><li><p>在某个线程中调用如下函数来等待信号并处理之：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span><span class="token comment">// set 参数指定需要等待的信号集合</span><span class="token comment">// sig 存储返回值</span><span class="token keyword">int</span> <span class="token function">sigwait</span><span class="token punctuation">(</span><span class="token keyword">const</span> sigset_t<span class="token operator">*</span> set<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 明确讲一个信号 sig 发给 thread 线程，sig = 0 不发送信号</span><span class="token comment">// thread 参数指定目标线程，sig 指定待发送的信号</span><span class="token comment">// 可以用于检查指定线程是否存在，成功返回 0，失败返回错误码</span><span class="token keyword">int</span> <span class="token function">pthread_kill</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>代码参考：<a href="ch14/14-5sigmask.c">14-5sigmask.c</a> 没看懂o(╥﹏╥)o</p></blockquote></li></ol><h3 id="Ch-15-进程池和线程池"><a href="#Ch-15-进程池和线程池" class="headerlink" title="Ch.15 进程池和线程池"></a>Ch.15 进程池和线程池</h3><h4 id="15-1-概述"><a href="#15-1-概述" class="headerlink" title="15.1 概述"></a>15.1 概述</h4><p>进程池中的所有子进程都运行着相同的代码，并具有相同的属性，比如优先级、PGID等。因为进程池在服务器启动之初就创建好了，所以每个子进程都相对 “干净”，即它们没有打开不必要的文件描述符（从父进程继承而来），也不会错误地使用大块的堆内存（从父进程复制得到）。</p><p><strong>当有新的任务到来时，主进程将通过某种方式选择进程池中的某一个子进程来为之服务</strong>。相比于动态创建子进程，选择一个已经存在的子进程的代价显然要小得多。至于主进程选择哪个子进程来为新任务服务，则有两种方式：</p><ul><li>随机算法和 Round Robin 算法、以及更优秀的均匀分配算法</li><li>主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该队列上，有新任务时将任务添加到工作队列，唤醒正在等待的子进程</li></ul><p>选择好子进程之后，可以通过管道实现父子进程之间的数据传递</p><h4 id="15-2-处理多客户"><a href="#15-2-处理多客户" class="headerlink" title="15.2 处理多客户"></a>15.2 处理多客户</h4><ul><li>半同步/半反应堆：主进程接受新的连接以得到连接 socket，然后它需要将该 socket 传递给子进程（对于线程池而言，父线程将socket 传递给子线程必须使用13.9节介绍的 socketpair 系统调用创建的双向管道实现）</li><li>半同步/半异步模式以及领导者/追随者模式，是由主进程管理所有监听 socket，而各个子进程分别管理属于自己的连接 socket 的，子进程自己调用 accept 来接受新的连接</li></ul><h4 id="15-3-半同步-半异步进程池"><a href="#15-3-半同步-半异步进程池" class="headerlink" title="15.3 半同步/半异步进程池"></a>15.3 半同步/半异步进程池</h4><p>为了避免在父子进程之间传递文件描述符，我们将接收新连接的操作放到子进程中</p><blockquote><p>代码参考：<a href="ch15/15-1processpool.h">15-1processpool.h</a></p></blockquote><h4 id="15-4-用进程池实现简单的-CGI-服务器"><a href="#15-4-用进程池实现简单的-CGI-服务器" class="headerlink" title="15.4 用进程池实现简单的 CGI 服务器"></a>15.4 用进程池实现简单的 CGI 服务器</h4><p>复用前面的进程池，构建一个并发的 CGI 服务器</p><blockquote><p>代码参考：<a href="ch15/15-2pool_cgi.cpp">15-2pool_cgi.cpp</a></p></blockquote><h4 id="15-5-半同步-半反应堆线程池"><a href="#15-5-半同步-半反应堆线程池" class="headerlink" title="15.5 半同步/半反应堆线程池"></a>15.5 半同步/半反应堆线程池</h4><p>本节我们实现一个基于图 8-10 所示的半同步/半反应堆并发模式的线程池，如代码清单15-3 所示。相比代码清单 15-1 所示的进程池实现，该线程池的通用性要高得多，因为它使用一个工作队列完全解除了主线程和工作线程的耦合关系：<strong>主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它</strong>。不过，如果要将该线程池应用到实际服务器程序中，那么我们必须保证所有客户请求都是无状态的，因为同一个连接上的不同请求可能会由不同的线程处理。</p><blockquote><p>代码参考：<a href="ch15/15-3threadpool.h">15-3threadpool.h</a></p></blockquote><h4 id="15-6-用线程池实现的简单-web-服务器"><a href="#15-6-用线程池实现的简单-web-服务器" class="headerlink" title="15.6 用线程池实现的简单 web 服务器"></a>15.6 用线程池实现的简单 web 服务器</h4><ul><li><a href="ch15/15-4http_conn.h">15-4http_conn.h</a></li><li><a href="ch15/15-5http_conn.cpp">15-5http_conn.cpp</a></li><li><a href="ch15/15-6main.cpp">15-6main.cpp</a></li></ul><p>类似于一个传输文本服务器，简单测试的客户端可以使用 telnet</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># HTTP 请求格式</span>GET /test.txt HTTP/1.1Connection: keep-aliveContent-Length: <span class="token number">8</span>Host: telnet<span class="token assign-left variable">param1</span><span class="token operator">=</span><span class="token number">1</span></code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>《Linux 高性能服务器编程》- 游双著</li><li>nowcoder - Linux 多进程开发</li><li>源码：<a href="https://github.com/wgfxcu/HPS">注释版-wgfxcu/HPS</a>  <a href="https://github.com/raichen/LinuxServerCodes">无注释版本-raichen/LinuxServerCodes</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Linux </tag>
            
            <tag> WebServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】回溯算法深入浅出，一文吃透！</title>
      <link href="suan-fa/5ca860e38b76.html"/>
      <url>suan-fa/5ca860e38b76.html</url>
      
        <content type="html"><![CDATA[<h2 id="【LeetCode】回溯算法"><a href="#【LeetCode】回溯算法" class="headerlink" title="【LeetCode】回溯算法"></a>【LeetCode】回溯算法</h2><blockquote><p>原文地址：<a href="https://github.com/EricPengShuai/Interview/blob/main/algorithm/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95.md">https://github.com/EricPengShuai/Interview/blob/main/algorithm/回溯算法.md</a></p></blockquote><h3 id="0-概念"><a href="#0-概念" class="headerlink" title="0. 概念"></a>0. 概念</h3><p><strong>回溯法</strong> 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，<strong>它将取消上一步甚至是上几步的计算</strong>，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的 <strong>递归</strong> 方法来实现，在反复重复上述的步骤后可能出现两种情况：</p><ul><li>找到一个可能存在的正确的答案</li><li>在尝试了所有可能的分步方法后宣告该问题没有答案</li></ul><p><strong>深度优先搜索</strong> 算法（Depth-First-Search，DFS）是一种用于 <strong>遍历或搜索树或图</strong> 的算法。这个算法会 <strong>尽可能深</strong> 的搜索树的分支。当结点 v 的所在边都己被探寻过，搜索将 <strong>回溯</strong> 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。</p><blockquote><p>典型的 DFS 但是没有回溯的题目：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></p></blockquote><p><strong>简单比较</strong></p><p>「回溯算法」与「深度优先遍历」都有<strong>「不撞南墙不回头」</strong>的意思。「回溯算法」强调了「深度优先遍历」思想的用途，用一个 <strong>不断变化</strong> 的变量，在尝试各种可能的过程中，搜索需要的结果。</p><ul><li>回溯强调了 <strong>回退</strong> 操作对于搜索的合理性</li><li>DFS 强调一种 <strong>遍历</strong> 的思想，与之对应的遍历思想是 BFS</li></ul><h3 id="1-例题（46-全排列）"><a href="#1-例题（46-全排列）" class="headerlink" title="1. 例题（46.全排列）"></a>1. 例题（<a href="https://leetcode.cn/problems/permutations/">46.全排列</a>）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案</p></blockquote><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h4><p>这是一到回溯算法的入门题，很好的说明了回溯算法在选择回退时的用法，几个比较重要的点是：</p><ol><li>递归的重点条件是排列中数字已经选满，可以使用 <strong>depth 表示递归深度</strong> 或者 <strong>index 表示数组下标</strong></li><li>需要使用 <strong>used</strong> 来标记使用过那些变量</li></ol><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> res<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">permute</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> path<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">used</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">backtrace</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> used<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">backtrace</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> path<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> used<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> dep<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dep <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>used<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">backtrace</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> used<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> dep<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>            used<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 回溯</span>            path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><blockquote><p>另外在 C++ 里，最好还是不要写<code>vector&lt;bool&gt;</code>，因为<code>vector&lt;bool&gt;</code>返回的是一个<code>std::vector&lt;bool&gt;::reference</code>的对象，数据量大时比<code>vector&lt;int&gt;</code>要慢，<a href="https://leetcode.cn/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/478510">参考</a></p></blockquote><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p><strong>有重复元素的全排列（LC.47）</strong></p><ul><li>排序之后再根据 <code>nums[i-1]==nums[i]</code> 判重</li><li>在上一个<strong>相同的元素撤销之后</strong>去重效率更高</li></ul><p><strong>组合问题的排列（LC.39）</strong></p><ul><li><strong>排列问题</strong>：讲究顺序，例如 [LC46.全排列]（即 [2, 2, 3] 与 [2, 3, 2] 视为不同列表时），需要记录哪些数字已经使用过，此时用 <strong>used 数组</strong></li><li><strong>组合问题</strong>：不讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为相同列表时），需要按照某种顺序搜索，此时使用 <strong>begin 变量</strong></li></ul><blockquote><p>有一个小经验就是 <strong>used 数组</strong> 和 <strong>begin 变量</strong> 一般不用一起使用</p></blockquote><h3 id="2-相关问题"><a href="#2-相关问题" class="headerlink" title="2. 相关问题"></a>2. 相关问题</h3><p><strong>排列型回溯</strong></p><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></td><td>回溯入门问题，无重复元素的排列问题</td><td><a href="https://leetcode.cn/submissions/detail/395204984/">通过</a></td></tr><tr><td><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></td><td>去重是关键，排序比较，<strong>上一个相同的元素撤销之后再剪枝</strong></td><td><a href="https://leetcode.cn/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/">剪枝图</a></td></tr></tbody></table><p><strong>组合型回溯</strong></p><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></td><td>组合问题需要按照某种顺序搜索：每一次搜索的时候设置 <strong>下一轮搜索的起点</strong> <code>begin</code>，也可以排序之后加速剪枝</td><td><a href="https://leetcode.cn/submissions/detail/171894367/">通过</a></td></tr><tr><td><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></td><td>和 LC.39 区别是这个有重复元素，需要去掉当前层<strong>第二个数值重复的节点</strong> <span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><a href="https://leetcode.cn/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/225211">剪枝</a></td></tr><tr><td><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></td><td>和 LC.40 类似，这题没有重复元素，两个剪枝：<strong>小于最小的 || 大于最大的</strong> <span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><a href="https://leetcode.cn/problems/combination-sum-iii/solution/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-feme/">0x3F</a></td></tr><tr><td><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></td><td>和 LC.39 类似，按照 begin 为起点遍历然后回溯就可以，注意不能重复</td><td><a href="https://leetcode.cn/submissions/detail/395236585/">通过</a></td></tr></tbody></table><p><strong>子集型回溯</strong></p><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></td><td>和 LC.39 类似，按照 begin 为起点遍历回溯就可以</td><td><a href="https://leetcode.cn/submissions/detail/395238958/">通过</a></td></tr><tr><td><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></td><td>在 LC.78 的基础上有重复元素的考虑，和 LC.40 类似的剪枝 <span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><a href="https://leetcode.cn/submissions/detail/395250094/">通过</a></td></tr><tr><td><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></td><td>枚举字符之间的逗号，按照 idx 顺序回溯，判断回文</td><td><a href="https://leetcode.cn/submissions/detail/395280098/">通过</a></td></tr><tr><td><a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">698. 划分为k个相等的子集</a></td><td><strong>抽象成 k 个桶</strong>，每个桶的容量为子集和大小</td><td><a href="https://leetcode.cn/submissions/detail/396107337/">通过</a></td></tr><tr><td><a href="https://leetcode.cn/problems/matchsticks-to-square/">473. 火柴拼正方形</a></td><td>和 LC.698 一模一样，<strong>抽象成 4 个桶</strong></td><td><a href="https://leetcode.cn/submissions/detail/366042332/">通过</a></td></tr><tr><td><a href="https://leetcode.cn/problems/fair-distribution-of-cookies/">2305. 公平分发饼干</a></td><td>k 个桶，但是桶大小未知，从大到小DFS回溯</td><td><a href="https://leetcode.cn/submissions/detail/396110148/">通过</a></td></tr><tr><td><a href="https://leetcode.cn/problems/k-similar-strings/">854. 相似度为 K 的字符串</a></td><td>DFS 回溯，剪枝，有点难…</td><td><a href="https://leetcode.cn/submissions/detail/396114920/">通过</a></td></tr></tbody></table><h3 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h3><ul><li><a href="https://leetcode.cn/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">回溯算法入门级详解 + 练习（持续更新）</a></li><li><a href="https://www.bilibili.com/video/BV1mG4y1A7Gu/?vd_source=286032bc2c5715c8b50b608028ce57df">回溯算法套路①子集型回溯【基础算法精讲 14】</a></li><li><a href="https://leetcode.cn/link/?target=https://lfool.github.io/LFool-Notes/algorithm/%E7%BB%8F%E5%85%B8%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%EF%BC%9A%E9%9B%86%E5%90%88%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98.html">经典回溯算法：集合划分问题「重要更新 🔥🔥🔥」</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++】HTTP Server 开源库（汇总级别整理）&#39;</title>
      <link href="c-c/039eca2b3cfe.html"/>
      <url>c-c/039eca2b3cfe.html</url>
      
        <content type="html"><![CDATA[<h2 id="【C-】HTTP-Server-开源库整理"><a href="#【C-】HTTP-Server-开源库整理" class="headerlink" title="【C++】HTTP Server 开源库整理"></a>【C++】HTTP Server 开源库整理</h2><h3 id="C-http-server-开源框架"><a href="#C-http-server-开源框架" class="headerlink" title="C++ http server 开源框架"></a>C++ http server 开源框架</h3><blockquote><p>star 统计截止至 2022.12.10</p></blockquote><table><thead><tr><th>名称</th><th>说明</th><th>链接</th><th>star</th></tr></thead><tbody><tr><td><strong>cpp-httplib</strong></td><td>A C++ header-only HTTP/HTTPS server and client library</td><td><a href="https://github.com/yhirose/cpp-httplib">https://github.com/yhirose/cpp-httplib</a></td><td>8.2k</td></tr><tr><td><strong>incubator-brpc</strong></td><td>百度开源的 RPC 框架，比较详细的<a href="https://github.com/apache/incubator-brpc/blob/master/README_cn.md">中文文档</a></td><td><a href="https://github.com/apache/incubator-brpc">https://github.com/apache/incubator-brpc</a></td><td>14.2k+</td></tr><tr><td><strong>sougo/workflow</strong></td><td>C++ Parallel Computing and Asynchronous Networking Engine</td><td><a href="https://github.com/sogou/workflow">sogou/workflow</a></td><td>9.6k</td></tr><tr><td>mongoose</td><td>比较轻量的框架,<a href="https://github.com/tashaxing/CppHttpDemo">Demo</a></td><td><a href="https://github.com/cesanta/mongoose">Embedded Web Server|Github</a></td><td>9k</td></tr><tr><td>crow</td><td>very fast and easy to use C++ micro web framework (inspired by Python Flask)</td><td><a href="https://github.com/ipkn/crow">ipkn/crow: </a></td><td>7k</td></tr><tr><td>cinatra</td><td>一个高性能易用的http框架，它是用modern c++(c++17)开发的（国内维护）</td><td><a href="https://github.com/qicosmos/cinatra">qicosmos/cinatra</a></td><td>1.2k</td></tr><tr><td>wfrest</td><td>基于 workflow 的 RESTful API 项目 比较简洁的异步网络库</td><td><a href="https://github.com/wfrest/wfrest">C++ Web Framework REST API</a></td><td>500+</td></tr><tr><td>Drogon</td><td>C++14/17 based http web application framework，跨平台的</td><td><a href="https://github.com/drogonframework/drogon/blob/master/README.zh-CN.md">README.zh-CN.md</a></td><td>8.4k</td></tr><tr><td>treefrog</td><td>以Qt为基础开发的，MVC，内容较全，包括数据库、会话生管理</td><td><a href="https://github.com/treefrogframework/treefrog-framework">TreeFrog Framework : High-speed C++ MVC Framework for Web Application</a></td><td>1.1k</td></tr><tr><td>Cutelyst</td><td>A C++ Web Framework built on top of Qt, using the simple approach of Catalyst (Perl) framework</td><td><a href="https://github.com/cutelyst/cutelyst">cutelyst/cutelyst</a></td><td>806+</td></tr><tr><td>CPPWebFramework</td><td>a MVC web framework, Open Source, under MIT License, using C++ with Qt to be used in the development of web applications</td><td><a href="https://github.com/HerikLyma/CPPWebFramework">HerikLyma/CPPWebFramework</a></td><td>393+</td></tr><tr><td>cppcms</td><td>以高性能著称，MVC，内容较全，但是不太活跃了</td><td><a href="https://github.com/artyom-beilis/cppcms">https://github.com/artyom-beilis/cppcms</a></td><td>374+</td></tr></tbody></table><p><strong>cpp-httplib 相关博客推荐</strong></p><ul><li>C++ Http/Https 服务器和客户端例子：<a href="https://www.cnblogs.com/MakeView660/p/12777549.html">https://www.cnblogs.com/MakeView660/p/12777549.html</a></li><li>cpp-httplib库简单原理：<a href="https://blog.csdn.net/cckluv/article/details/115109108">https://blog.csdn.net/cckluv/article/details/115109108</a></li><li>httplib库的安装以及使用：<a href="https://blog.csdn.net/sjp11/article/details/127990377">https://blog.csdn.net/sjp11/article/details/127990377</a></li><li>httplib库的使用(支持http/https)（一）：<a href="https://blog.csdn.net/harry49/article/details/115763383">https://blog.csdn.net/harry49/article/details/115763383</a></li><li><strong>GitHub</strong>: <a href="https://github.com/yhirose/cpp-httplib">https://github.com/yhirose/cpp-httplib</a></li></ul><p><strong>brpc 相关博客推荐</strong></p><ul><li>初学者指南：<a href="http://brpc.incubator.apache.org/zh/docs/blogs/shares/brpc-guide-for-beginners/">http://brpc.incubator.apache.org/zh/docs/blogs/shares/brpc-guide-for-beginners/</a></li><li>具体看看 example 示例代码：<a href="https://github.com/apache/incubator-brpc/tree/master/example/http_c%2B%2B">https://github.com/apache/incubator-brpc/tree/master/example/http_c%2B%2B</a></li></ul><blockquote><p>当然还有 google 的 <a href="https://github.com/grpc/grpc">grpc</a>，那个不同语言版本也有很多，有兴趣也可以学学，只不过那个是英文文档</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><table><thead><tr><th>名称</th><th>说明</th><th>链接</th><th>star</th></tr></thead><tbody><tr><td>yazi</td><td>比较新的，写了很多框架的 <a href="https://space.bilibili.com/193137215">天天写乱码</a> 大佬写的</td><td><a href="https://github.com/oldjun/yazi">oldjun/yazi|Github</a></td><td>136+</td></tr><tr><td>http服务器/web服务</td><td>直接手撸的</td><td><a href="https://blog.csdn.net/dxgzg/article/details/113406923">CSDN 博客</a></td><td></td></tr></tbody></table><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://juejin.cn/post/6963596592578297870">https://juejin.cn/post/6963596592578297870</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> HTTP Server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022总结</title>
      <link href="sheng-huo-sui-bi/7c47771eecff.html"/>
      <url>sheng-huo-sui-bi/7c47771eecff.html</url>
      
        <content type="html"><![CDATA[<h2 id="2022总结"><a href="#2022总结" class="headerlink" title="2022总结"></a>2022总结</h2><p>今天是2022年12月30日晚上7点左右，想了一想，还是写一个年终总结吧。总的来说这年过得不是那么如意，有一种“向死而生”的感觉。</p><p>上半年研一下，实验室摸鱼了大半年，一直在做一些调研工作，6月开始刷题。下半年研二上，找到了努力的方向并一直在准备。总的来说这一年前半年就是“摸爬滚打”混日子，后半年就是“艰苦奋斗”寻方向。</p><h3 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h3><p><strong>1月 &amp;&amp; 2月</strong></p><p>我记得是1月上旬放寒假回家了，那时候也写了2021年的年终总结。1月份以及二月份都是在家度过的，中间过了一个年，当时还挺快乐，过年的时候和几个表弟一起打打麻将，看看电影，过年期间大概玩了一周左右吧。</p><p>之后都是每周固定的组会，因为开学的时候华为的项目也要结项了，所以那段时间的实验室活都是弄华为项目的那个系统，我这边主要就是负责视野预测的部署上线，其实总的来说写的还算顺利，主要是Flask后端加一些前端的代码。对了这期间还完善了去年年底写的 J-NaNA 论文，记得是1月份就见刊发表了。然后还帮路哥看看了 ABR 部分相关论文（之后去学校要写一个 MM），主要是用联盟博弈实现的码率自适应算法。</p><p><strong>3月 &amp;&amp; 4月</strong></p><p>这两个月主要是两个事情：一是华为项目的结尾验收，而是帮杨老师写 MM</p><p>我记得是2月底3月初就去了学校，当前其实华为的项目在家基本上就做的差不多了，去学校之后也就是一些收尾工作，所以那段时间也不是很忙。当时好像还收到去年提交的 ICME 论文的结果，结果挺好的（中了，好像是5|4|5|5分），之后也花了点时间弄那个 camera-ready。所以随之而来的就是杨老师那边让我和路哥帮他写一篇论文：ABR 为主体，FoV部分为辅。</p><p>开始一周左右都在想怎样弄一个全新的视野预测框架中，但是想了想时间可能不太够，就在之前那个 ICME 的基础上改改吧，加一个原始的视频帧以及改改参数吧，画画图就这样吧。而且本来论文的主体就是联盟博弈实现的码率自适应部分。最后大概是4月中下旬的时候提交了 MM 论文（不过估计也不太可能中）。</p><p><strong>5月 &amp;&amp; 6月</strong></p><p>论文写完之后就是忙实验室项目的调研了，就是和电信研究院的合作，初期就是一些调研工作。记得5月份的北京疫情很严重，五一小长假整个都是封校状态，当时学校里还有“草地音乐节”等等一系列封校活动~~不过我也没怎么去，可能是不太愿意凑热闹吧。</p><p>记得5月初时候还指导完 zzc 学弟完成了国院的答辩，主要是指导他做显著性方面的实验。当时目哥还和我这边有一些交流，准备是扩一扩 ICME，当时我还跑了跑显著性实验，不过由于之后实验室的活有点多，之后的交流也就搁置了（现在看来那些跑的实验还是有点用的，用在了之后写的IWCMC上）。</p><p>当时6月初的时候好像回家了，因为北京的疫情太严重了，学校乘着窗口期赶我们回家了，“点对点回家”：从学校坐校车去车站，到家之后村里从车站接回家。好在学回家之后没有集中隔离，就居家7天健康监测。之后就开始大概3个月的居家办公。</p><p>最后好像是从6月下旬开始刷力扣的，因为当时回家之后多了一些自己支配的时间，当时也像准备准备找工作方面的东西了。</p><p><img src="https://s2.loli.net/2022/12/31/6JlLfd7SRHqBmZP.png" alt="leetcode"></p><h3 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h3><p><strong>7月 &amp;&amp; 8月</strong></p><p>这两个月主要是就是实验室的一些“杂活”，还有就是刷每日一题。</p><p>实验室的杂活就是和电信研究院那边的交流，什么QUIC调研，单组播调研等等。然后后来和华为的交流又来了，华为那边主要是关于 3D 会议场景的搭建，使用 WebRTC 协议传输音视频，然后结合 VR 来构建一些虚拟会议场景，当时我这边就学了一点关于 A-Frame 框架来学着搭一搭 VR 场景，然后也看了看 Networked-AFrame 这个 VR 场景更新同步库，当时这些东西学起来是比较费时间的，而且感觉对自己找工作也没有多大帮助，所以当时也就是边看这个边刷着题。另外7月底8月上旬还把之前没中的 MM 改了改投了 Infocom（吐槽一下 edas 系统真难用…）</p><p>除了刷题之后当时也像找一些 CPP 实际项目自己啃一啃，大致了解了一些什么 WebServer 服务器、muduo 网络库、leveldb 数据库等等，但也就是了解了一下，你说真真啃进去也是挺难的，就是感觉无法下手，主要是没有一个大致的方向…所以也就搁置了，当时刷着力扣的同时也看看一些 C++ 11 语法新特性，也在维护这 C++ Interview 这个仓库：<a href="https://github.com/EricPengShuai/Interview">https://github.com/EricPengShuai/Interview</a></p><img src="https://img-blog.csdnimg.cn/img_convert/552c0f5e964e20b7f9790394cd1c2eb9.png" alt="logo" style="zoom:50%;"><p>反正当时的一个整体状态就是边刷着题，边看看实验室项目，主要是自己要学点东西进去，学点对找工作有帮助的东西，对了当时还参加了字节的一个“青训营”，参加的是一个“Android开发”的小组，就是上上一些 Android 的基础课然后做一个“抖音”项目，当时也没怎么做（跟了一个大佬，全程大佬带飞做完最后还获奖了），主要是自己主要准备 CPP 方面的知识。</p><p><strong>9月 &amp;&amp; 10月</strong></p><p>8月下旬就回到了学校，当时因为疫情好多同学还没法回来。整个9月好像也没有什么进展，就是看看 WebRTC，学学 NAF，还有在电信那边服务器上部署之前全景视频传输系统，他们说要测什么指标，这一部署就一发不可收拾，一直提出一些需要，什么测试工具，支持并发的开发，内存泄漏的维护等等。回到学校之后的开始一段时间也在写一些算法博客：<a href="https://blog.csdn.net/miracle_ps/category_9859223.html%EF%BC%8C%E5%BD%93%E6%97%B6%E5%A5%BD%E5%83%8F%E8%BF%98%E7%9C%8B%E4%BA%86%E7%82%B9">https://blog.csdn.net/miracle_ps/category_9859223.html，当时好像还看了点</a> CMU 15-445 课程，但也没有坚持下来，总是被一些杂七杂八的事情打断… 总之关于 C++ 实际项目这块一直都是一个遗憾…问了也看了很多C++项目方面的帖子（其中还有一个上过LC热门），但就是很难坚持啃完（主要是实验室杂事以及见效太慢<span class="github-emoji"><span>😞</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f61e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）</p><img src="https://s2.loli.net/2023/01/07/961GgoOXc48ZEPv.png" alt="c++_post.png" style="zoom:40%;"><p>10月就开始忙碌起来了，也不是什么找工作上的，就是开始做电信那边提出的单组播系统架构了。还好那边要求的语言是 C++，正好和我的语言栈相契合，所以做这个系统的过程中也能学一点 C++ 的知识，当时刚开始看的“入坑项目”就是一个 RTSP 服务器，了解了 RTP RTSP 基本原理。10月下旬也开始了奖学金的评定，开始我以为凭着 J-NaNA 期刊（一作）和 ICME B会（二作）可以拿到国奖的，看来是我想多了，最后连一个最低级的企业奖都没拿到，主要的原因就是 J-NaNA 连 EI 都还不是，没想到啊，连 NaNA 都还不如，最好真的是我想多了，听意难平的，还不如发一个 NaNA。而且之后杨老板说你这个最好还发一篇 EI，因为你毕业的时候这个 J-NaNA 可能还不是 EI，最后盲审可能不好说，当时听到这个真是有点急了，也有点不爽吧，感觉自己被骗了…</p><p><strong>11月 &amp;&amp; 12月</strong></p><p>11 月感觉过的很快又感觉很漫长，10月底好像也过了一个生日，当时“请”宿舍同学一起出去吃个饭，但是第二天我竟然发另一个群收款（因为当时我想的是路哥那份我请了，另外也算这和卓远一起过生日，而且想着之后可能需要有大笔花销买个 14 pro，所以当时脑门一热就发了，虽然每个人只收了70吧，但是之后一想起来就感觉很尴尬），唉，之后注意吧，本来就是我请大家吃饭，还收了大伙的部分AA，不想了越想越尴尬…</p><p>11月中下旬收到了自己买的 iPhone 14 pro，pdd 8399 下单的，还好没翻车，好像最近几年的苹果产品都是在 pdd 买，百亿补贴认准了之后还是挺香的…</p><p>11月30号我们楼层出另一个阳性，噩梦就开始来了，我们那一层按照“十字分割法”拉了几个宿舍区沙河健康驿站隔离了，我们宿舍也不例外，也有过反抗，但也无济于事，不然的话我11月底就回家了（当时学校的返乡政策也出了）</p><p>12月初我就在沙河那边隔离，好像隔离了6天吧，随着疫情的二十条以及最后的新十条，全国越来越放开。我一隔离结束就订票回去了（中间来回改了4-5次车票，航班基本不飞），12月7号晚上到岳阳站的，到了之后打车回家，8号凌晨才到家，最后回家之后1点多才睡下</p><p>好像是回家第一天也就是8号左右吧，新十条发布了，回家也不做核酸了，很庆幸在高铁上没有感染（当时紧张的真是连口罩都没摘，水都没喝），在家隔离了7天之后也就正常生活了。但随着政策的放开，我们村里的阳性感染者也在不断出现，周围连着好几户人家都中招了，最后病毒也没放过我们家，20号晚上爷爷开始发烧38°，最后果不其然第二天抗原阳了，最后一家人都感染了。好在爷爷奶奶的症状都还好，没有我的重，我目前还在咳嗽：</p><p><img src="https://s2.loli.net/2022/12/30/3CG64RTnBgAiWOk.png" alt="新冠症状"></p><p>不过总的来说还是有点难受的，真的很担心家里老人抗不过去，现在奶奶还没有完全恢复，身上有点没劲，这几天我也在网上看血氧仪，因为我看网上说老人有静默型缺氧，还是有点担心的。可是真的不好买啊（康泰的预约基本上抢不到，鱼跃的又太坑），看了看就在网上买另一个华为手环测测老人的心率血压啥的，但是应该没有指压式的血氧仪准确，但是我一想着手环还可以监测睡眠啥的，就买了一个，先用着看看，然后看看血氧仪抢不抢得到。</p><p>就先写这么多吧，内心想法还有很多，就不再这里一一写了，主要是这一个月以来心理的打击有点大，总的来说这半年是“向死而生”</p><p><img src="https://s2.loli.net/2023/01/02/rxWHpyFMNgPS4ws.png" alt="2022.png"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>关于爱情，有时也在考虑，会在社交软件上看看，但是这东西真说不好，也聊了几个，但是感觉也没那么愉快…再看看吧，虽然有的时候也会着急，但是忙起来时也没那么往这方面想…</p></li><li><p>关于运动，今年主要就是羽毛球、健身、足球。健身是从今年才开始的，上半年办了张季卡去了大概一个多月健身房吧（后来因为疫情退了），下半年也办了张季卡并且坚持了一两个月吧，练了练腿、胸、背、肱二、肱三、腹等等，但是效果嘛…</p></li><li><p>关于生活，今年给自己换一部手机 iPhone 14 Pro，主要就是想用用苹果的生态，pdd 500优惠券安全下车，不过最近看14pro又降价… 理财真的是一年下来还不如余额宝和货币，一年的白酒和医疗都是绿色的，年底的债基都不断下跌，最终割了白酒，债基是割了之后又入了，总之就是割啥涨啥…</p></li><li><p>关于工作，马上开过年也要找实习了，所以这段时间也比较着急，项目也要做，每周还要开会。上周刚弄完论文（之前显著性那个），抓紧弄完吧也不太拖太久，以后还要看看八股文了，关于项目也是挺头大，现在电信那个系统开发起来还有点障碍，以后面试还要好好准备下项目…</p></li><li><p>关于人生，其实这一年还是挺魔幻的：年初的“浑水摸鱼”，心态摆烂；年中的着手刷题，寻找方向；年后的“认清现实”，学会接受。这些无一不是在“教我生活“，也许人的一生就是这样吧…</p></li></ul><div align="right">    <b>ericps 写于 2022.12.30 晚</b></div>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】二叉树路径问题深入浅出，一文吃透！</title>
      <link href="suan-fa/65c543f63eb3.html"/>
      <url>suan-fa/65c543f63eb3.html</url>
      
        <content type="html"><![CDATA[<h2 id="【LeetCode】二叉树路径问题总结"><a href="#【LeetCode】二叉树路径问题总结" class="headerlink" title="【LeetCode】二叉树路径问题总结"></a>【LeetCode】二叉树路径问题总结</h2><blockquote><p>原文同步在：<a href="https://github.com/EricPengShuai/Interview/blob/main/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98.md">https://github.com/EricPengShuai/Interview/blob/main/algorithm/二叉树路径问题.md</a></p></blockquote><h3 id="0-引言"><a href="#0-引言" class="headerlink" title="0. 引言"></a>0. 引言</h3><p>二叉树路径问题就是解决从一个节点出发寻找某个路径或者到某一个节点，以满足题目要求。核心就是二叉树遍历问题，总的来说就是<strong>深度优先遍历</strong>（DFS）和<strong>广度优先遍历</strong>（BFS），更具体来说前者就是<strong>递归</strong>，后者就是<strong>迭代</strong>。</p><h3 id="1-问题分类"><a href="#1-问题分类" class="headerlink" title="1. 问题分类"></a>1. 问题分类</h3><p>按照 <a href="https://leetcode.cn/u/eh-xing-qing/">星晴pro</a> 大佬的整理，路径问题大致可以分为两类：</p><h4 id="1-1-自顶向下"><a href="#1-1-自顶向下" class="headerlink" title="1.1 自顶向下"></a>1.1 自顶向下</h4><p>从某一个节点（不一定是根节点），从上向下寻找路径，到某一个节点（不一定是叶节点）结束，解决此类问题往往使用 DFS 和 BFS，一般来说 DFS 代码更加简洁。</p><p><strong>DFS 模板</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> res<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> path<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 加入节点</span>    path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token operator">-&gt;</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 继续递归</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 指定路径和</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> path<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 处理节点</span>    sum <span class="token operator">-=</span> root<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>    path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token operator">-&gt;</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>root<span class="token operator">-&gt;</span>right <span class="token operator">&amp;&amp;</span> sum <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 继续递归</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>这类题型DFS注意点：</strong></p><ol><li><p>如果是找路径和等于给定 target 的路径的，那么可以不用新增一个临时变量cursum来判断当前路径和，只需要用给定和 target 减去节点值，最终结束条件判断 <code>target==0</code> 即可</p></li><li><p>是否要回溯：二叉树的问题大部分是不需要回溯的，原因如下：<strong>二叉树的递归部分：dfs(root-&gt;left),dfs(root-&gt;right)已经把可能的路径穷尽了</strong>，因此到任意叶节点的路径只可能有一条，绝对不可能出现另外的路径也到这个满足条件的叶节点的</p><p>而对比<strong>二维数组(例如迷宫问题)的 DFS</strong>，for循环向四个方向查找每次只能朝向一个方向，并没有穷尽路径，因此某一个满足条件的点可能是有多条路径到该点的，并且visited数组标记已经走过的路径是会受到另外路径是否访问的影响，这时候必须回溯</p></li><li><p><strong>找到路径后是否要return</strong>：取决于题目是否要求找到叶节点满足条件的路径，如果必须到叶节点，那么就要return; 但如果是到任意节点都可以，那么必不能return,因为这条路径下面还可能有更深的路径满足条件，还要在此基础上继续递归</p></li><li><p>是否要双重递归（即调用根节点的dfs函数后，继续调用根左右节点的pathsum函数）：看题目要不要求从根节点开始的，还是从任意节点开始</p></li></ol><p><strong>BFS 模板</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">bfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> res<span class="token punctuation">;</span>    <span class="token comment">// 维护两个队列：节点队列和数组队列</span>    queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">&gt;</span> qu_node<span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> qu_path<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    qu_node<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    qu_path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>qu_node<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> qu_node<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> path <span class="token operator">=</span> qu_path<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        qu_node<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        qu_path<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token operator">-&gt;</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// 注意这里需要一个副本，为了左右子树都使用这个 path</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> tmp <span class="token operator">=</span> path<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                qu_node<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                qu_path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                qu_node<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                qu_path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>力扣中类似题目整理如下：</p><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></td><td>BFS代码比较复杂，DFS简练</td><td><a href="https://leetcode.cn/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode-solution/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/paths-with-sum-lcci/">面试题 04.12. 求和路径</a></td><td>没有要求起点和终点，需要使用双重DFS</td><td><a href="https://leetcode.cn/submissions/detail/358317287/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></td><td>简单DFS</td><td><a href="https://leetcode.cn/submissions/detail/358318248/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></td><td>BFS 挺好理解的，DFS 模板不需要回溯但不能用引用</td><td><a href="https://leetcode.cn/problems/path-sum-ii/solution/lu-jing-zong-he-ii-by-leetcode-solution/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></td><td>双重DFS</td><td><a href="">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/smallest-string-starting-from-leaf/">988. 从叶结点开始的最小字符串</a></td><td>DFS 不能引用传参</td><td><a href="https://leetcode.cn/submissions/detail/358344110/">解</a></td></tr></tbody></table><h4 id="1-2-非自顶向下"><a href="#1-2-非自顶向下" class="headerlink" title="1.2 非自顶向下"></a>1.2 非自顶向下</h4><p>设计一个辅助函数 <code>maxpath</code>，调用自身求出以一个节点为根节点的左侧最长路径 <code>left</code> 和右侧最长路径<code>right</code>，那么经过该节点的最长路径就是 <code>left+right</code><br>接着只需要从根节点开始dfs,不断比较更新全局变量即可</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">maxPath</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token comment">// 以root为路径起始点的最长路径</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">maxPath</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">maxPath</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> left <span class="token operator">+</span> right <span class="token operator">+</span> root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新全局变量  </span>    <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 返回左右路径较长者</span><span class="token punctuation">}</span></code></pre><p>这类题型DFS注意点：</p><ol><li>left，right 代表的含义要根据题目所求设置，比如最长路径、最大路径和等等</li><li>全局变量 res 的初值设置是 0 还是 INT_MIN 要看题目<strong>节点是否存在负值</strong>，如果存在就用 INT_MIN，否则就是 0</li><li>注意两点之间路径为1，因此一个点是不能构成路径的</li></ol><p>力扣中类似题目整理如下：</p><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></td><td>内部最大路径要包含当前子树的根节点，外部返回结果只能选择一个分支的最大值返回</td><td><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/solution/shou-hui-tu-jie-hen-you-ya-de-yi-dao-dfsti-by-hyj8/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/longest-univalue-path/">687. 最长同值路径</a></td><td>DFS 返回的值就是左右子树同值路径中最大的</td><td><a href="https://leetcode.cn/submissions/detail/358214147/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></td><td>不能直接判断根节点是否为空，因为单个节点提供的路径也为0，当然也可以理解成高度问题</td><td><a href="https://leetcode.cn/submissions/detail/358906228/">解1</a> <a href="https://leetcode.cn/problems/diameter-of-binary-tree/solution/hot-100-9er-cha-shu-de-zhi-jing-python3-di-gui-ye-/">解2</a></td></tr></tbody></table><h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h3><p>二叉树的所有遍历问题无非就是 DFS 和 BFS，DFS 代码简单但是递归理解起来有些许复杂，写递归不能自己陷到递归栈里面去，需要仔细分析题意，搞清楚递归的三步走策略：</p><ol><li>知道递归出口是什么，一般而言有如：<code>root == nullptr</code></li><li>明白递归的时候做什么，也就是处理左右子树时需要怎样维护我们需要的结果</li><li>明确递归的返回值是什么，也就是对 DFS 而言的返回值，一般而言就是贡献给父节点的中间结果</li></ol><h3 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h3><ul><li><a href="https://leetcode.cn/problems/longest-univalue-path/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-94j7/">一篇文章解决所有二叉树路径问题（问题分析+分类模板+题目剖析）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】差分数组深入浅出，一文吃透！</title>
      <link href="suan-fa/9c1c32b3eab8.html"/>
      <url>suan-fa/9c1c32b3eab8.html</url>
      
        <content type="html"><![CDATA[<h2 id="【LeetCode】差分数组"><a href="#【LeetCode】差分数组" class="headerlink" title="【LeetCode】差分数组"></a>【LeetCode】差分数组</h2><blockquote><p>原文同步在：<a href="https://github.com/EricPengShuai/Interview/blob/main/algorithm/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84.md">https://github.com/EricPengShuai/Interview/blob/main/algorithm/差分数组.md</a></p></blockquote><h3 id="0-概念"><a href="#0-概念" class="headerlink" title="0. 概念"></a>0. 概念</h3><p>区间更新问题除了最适用的线段树维护之后，还可以使用差分数组维护，顾名思义，差分数组元素就是原数组中两个元素之差，例如假设原数组为 <code>arr=[7, 1, 5, 6, 3, 2, 4, 8]</code>，那么查分数组就是 <code>arr1=[0, -6, 4, 1, -3, -1, 2, 4]</code>，arr1[0] 默认为 0，如下图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dbd3d9bfe45c8187213c84cd081b0125.png" alt="差分数组"></p><p>差分数组是把原数组中后一个元素减前一个元素的差构成一个新的数组，作为辅助数组使用。具体来说：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// nums 是原数组，diff 是差分数组</span>diff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>diff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>diff<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> diff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> diff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span>  diff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> diff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> diff<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span>  diff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> diff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> diff<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h3 id="1-应用"><a href="#1-应用" class="headerlink" title="1. 应用"></a>1. 应用</h3><p>一般来说，将原数组 nums 中 [0, 3] 的值都加2，我们需要遍历对应区间：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>但是使用差分数组我们就只需要更新端点就可以了：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">diff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// 0 往后的所有值都加 2</span>diff<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// 4 往后的所有值都减 2</span></code></pre><p>这样就省去了遍历操作，因为原数组的值可以通过差分数组两端的数求得。</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h3><p>以 <a href="https://leetcode.cn/problems/my-calendar-iii/">732. 我的日程安排表 III</a> 为例，我们维护<strong>有序的STL map</strong>，因为我们还原数组时候需要从头开始，是有顺序的，也就是使用 map 代替了数组，注意初始数组都为0，每次 book 都需要将区间内元素加1表示预定次数，然后求得区间元素最大值即为所求</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyCalendarThree</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">MyCalendarThree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">book</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">// 注意题目中是前开后闭区间</span>        diff<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// start 开始的值都加 1</span>        diff<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>   <span class="token comment">// end 开始的值都减 1</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>kv <span class="token operator">:</span> diff<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cur <span class="token operator">+=</span> kv<span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token comment">// 还原原数组，由于初始值都是0所以这里就只是加差分值</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 求预定次数的最大值</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> diff<span class="token punctuation">;</span> <span class="token comment">//差分数组</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">/** * Your MyCalendarThree object will be instantiated and called as such: * MyCalendarThree* obj = new MyCalendarThree(); * int param_1 = obj-&gt;book(start,end); */</span></code></pre><p>另外类似题还有：</p><ul><li><p><a href="https://leetcode.cn/problems/my-calendar-i/">729. 我的日程安排表 I</a></p></li><li><p><a href="https://leetcode.cn/problems/my-calendar-ii/">731. 我的日程安排表 II</a></p></li></ul><h3 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h3><ul><li><a href="https://leetcode.cn/problems/my-calendar-iii/solution/c-by-li-zhi-chao-4-k89h/">C++ 差分数组，注释详细</a></li><li><a href="https://leetcode.cn/problems/my-calendar-iii/solution/wo-de-ri-cheng-an-pai-biao-by-jiang-hui-yac60/">我的日程安排表 III【差分数组+线段树动态开点(带lazy)】</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 差分数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】线段树深入浅出，一文吃透！</title>
      <link href="suan-fa/7f2e4d9cef89.html"/>
      <url>suan-fa/7f2e4d9cef89.html</url>
      
        <content type="html"><![CDATA[<h2 id="【LeetCode】线段树"><a href="#【LeetCode】线段树" class="headerlink" title="【LeetCode】线段树"></a>【LeetCode】线段树</h2><blockquote><p>本文大部分内容来自 <a href="https://leetcode.cn/link/?target=https://lfool.github.io/LFool-Notes/algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%AF%A6%E8%A7%A3.html">LFool⚡</a> 的力扣题解：<a href="https://leetcode.cn/problems/my-calendar-ii/solution/by-lfool-nodi/">https://leetcode.cn/problems/my-calendar-ii/solution/by-lfool-nodi/</a> </p><p>另外小部分参考 <a href="https://leetcode.cn/problems/my-calendar-iii/solution/xian-duan-shu-by-xiaohu9527-rfzj/">线段树 – 新手篇</a></p><p>在此记录只为学习留用，另外同步在个人仓库：<a href="https://github.com/EricPengShuai/Interview/blob/main/algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91.md">https://github.com/EricPengShuai/Interview/blob/main/algorithm/线段树.md</a></p></blockquote><h3 id="0-定义"><a href="#0-定义" class="headerlink" title="0. 定义"></a>0. 定义</h3><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点，**对于线段树中的每一个非叶子节点 [a, b], 它的左儿子表示的区间为 [a, (a+b)/2], 右儿子表示的区间为 [(a+b)/2+1, b]**。因此线段树是平衡二叉树，最后的子节点数目为 N，即为整个线段区间的长度。</p><p>使用线段树可以快速的查找一个节点在若干条线段中出现的次数，时间复杂度为 O(logN)，而未优化的空间复杂度为 2N，因此有时需要离散化让空间压缩</p><p><strong>线段树解决的是「区间和」问题，并且该「区间」会被修改</strong>。例如对于一个数组，多次求某个区间的和，可以使用「前缀和」实现，但是如果区间里面的元素经常变化时「前缀和」的效率就没那么高效。为此引入线段树，<strong>线段树中的每个节点代表一个区间</strong>，对于数组 <code>nums=[1, 2, 3, 4, 5]</code> 对应的线段树为：</p><p><img src="https://img-blog.csdnimg.cn/a39194386877480eb43193260904a84c.png#pic_center" alt="线段树结构"></p><p><strong>说明：</strong></p><ol><li>每个节点代表一个区间，节点的值就是该区间的和</li><li>节点的值可以根据题目要求换成自己满足<strong>「区间加法」</strong>的表示，例如<ul><li>最大公因数 GCD：总GCD = gcd (左区间GCD，右区间GCD)</li><li>最大值：总最大值 = max (左区间最大值，右区间最大值)</li></ul></li><li>有些不符合 <strong>「区间加法」</strong> 的表示需要注意，例如：<ul><li>众数：根据左右区间的众数不能求出总区间的众数</li><li>01序列的最长连续零：根据左右区间的最长连续零，没法知道总的最长连续零</li></ul></li><li>根节点代表的区间是问题的总区间，例如上图中数据的长度就是 [0, 4]</li><li>线段树是一棵近似的完全二叉树，如上图，但也有不是完全二叉树的情况</li><li>建立线段树的过程就是不断把区间<strong>「平分」</strong>的过程，直到区间长度为1</li></ol><h3 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h3><p><strong>数据结构</strong>：由于线段树是一棵近似的完全二叉树，因此可以使用二叉树的结构表示</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>           <span class="token comment">// 当前节点值</span>    Node <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span> <span class="token comment">// 左右孩子节点</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">delete</span> left<span class="token punctuation">;</span>        <span class="token keyword">delete</span> right<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>建立线段树</strong></p><ol><li><p>如果题目中给了具体的区间范围，我们可以根据范围建立线段树</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 到达叶子节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        node<span class="token operator">-&gt;</span>val <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">buildTree</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">buildTree</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 向上更新</span>    <span class="token function">pushUp</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">pushUp</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>    node<span class="token operator">-&gt;</span>val <span class="token operator">=</span> node<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>val <span class="token operator">+</span> node<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>对于没有具体范围的情况，一般只有数据的取值范围，一般都很大，可以使用<strong>「动态开点」</strong>，例如刚开始我们只知道数组的长度为5，不知道数组内每个元素的大小，元素都是一个一个添加进去的，此时需要动态开点，例如刚开始的节点就只能是 <code>[0, 4]; val = 0</code>，此时添加元素 <code>[2, 2]; val = 3</code>，线段树变为：</p><p><img src="https://img-blog.csdnimg.cn/310f91075aa9458b9da0a29c44778e25.png#pic_center" alt="动态开点1"></p><p>这里需要解释一下，如果一个节点没有左右孩子，会一下子把左右孩子节点都给创建出来，如上图橙色节点所示，具体代码可见方法 <code>pushDown()</code></p><p>两个橙色的叶子节点仅仅只是被创建出来了，并无实际的值，均为 0；而另外一个橙色的非叶子节点，值为 3 的原因是下面的孩子节点的值向上更新得到的</p><p><strong>下面给出依次添加剩余节点的过程：(注意观察值的变化！！)</strong></p><p><img src="https://img-blog.csdnimg.cn/3f91e62b8d8142499e876a23ac531414.png#pic_center" alt="动态开点2"></p></li></ol><blockquote><p>「动态开点」一般是在「更新」或「查询」的时候动态的建立节点，具体可见下面的<strong>更新</strong>和<strong>查询</strong>操作</p></blockquote><p><strong>更新线段树</strong>：将指定区间如 [2, 4] 的元素都增加1</p><p><img src="https://img-blog.csdnimg.cn/f847d1f390e3430db0a8277dbbd6c2a0.png#pic_center" alt="更新线段树"></p><p>更新的前提是查询需要更新的区间，首先查找到区间 [2, 2] 和 [3, 4]，然后更新节点，但是如果只是更新这两个节点的话也有问题，因为 [3, 3] 和 [4, 4] 也需要更新，当查询它们时才可以得到更新之后的值。</p><p>为此，我们给节点添加一个「懒惰标记」，给更新区间的对应节点添加一个懒惰标记，<strong>表示该节点所有对应的孩子节点都应该有此次更新</strong>，当向孩子节点遍历的时候会把「懒惰标记」下推给孩子节点，如果节点不存在最优孩子节点时需要创建左右孩子节点，最终我们修改 Node 的数据结构：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>           <span class="token comment">// 当前节点值</span>    <span class="token keyword">int</span> lazy<span class="token punctuation">;</span>          <span class="token comment">// 添加的懒惰标记</span>    Node <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span> <span class="token comment">// 左右孩子节点</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">delete</span> left<span class="token punctuation">;</span>        <span class="token keyword">delete</span> right<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>『下推懒惰标记』函数：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// leftNum 和 rightNum 表示左右孩子区间的叶子节点数量</span><span class="token keyword">void</span> <span class="token function">pushDown</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">int</span> leftNum<span class="token punctuation">,</span> <span class="token keyword">int</span> rightNum<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        node<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        node<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 没有标记直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>lazy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 如果是「加减」更新操作就需要使用：标记值 * 子树所有叶子节点数量</span>    node<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>val <span class="token operator">+=</span> node<span class="token operator">-&gt;</span>lazy <span class="token operator">*</span> leftNum<span class="token punctuation">;</span>    node<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>val <span class="token operator">+=</span> node<span class="token operator">-&gt;</span>lazy <span class="token operator">*</span> rightNum<span class="token punctuation">;</span>    <span class="token comment">// 对区间进行「加减」的更新操作，下推懒惰标记时需要累加起来，不能直接覆盖</span>    node<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>lazy <span class="token operator">+=</span> node<span class="token operator">-&gt;</span>lazy<span class="token punctuation">;</span>    node<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>lazy <span class="token operator">+=</span> node<span class="token operator">-&gt;</span>lazy<span class="token punctuation">;</span>    <span class="token comment">// 取消当前节点的标记</span>    node<span class="token operator">-&gt;</span>lazy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>「更新最终函数」：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 在 start...end 范围内更新 l...r 区间中的每个元素，都加 val</span><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 找到满足要求的区间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> start <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">// 区间节点加上子树所有叶子节点</span>        node<span class="token operator">-&gt;</span>val <span class="token operator">+=</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> val<span class="token punctuation">;</span>        <span class="token comment">// 累计添加懒惰标记</span>        node<span class="token operator">-&gt;</span>lazy <span class="token operator">+=</span> val<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">// 下推标记，mid - start + 1 表示左孩子区间叶子节点数量，end - mid 表示右孩子区间叶子节点数量</span>    <span class="token function">pushDown</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> mid <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">-</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span>        <span class="token function">update</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;</span> mid<span class="token punctuation">)</span>        <span class="token function">update</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 向上更新</span>    <span class="token function">pushUp</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>查询线段树</strong>：查询某一个区间如 [2, 4] 的结果（图中红色标记）并返回</p><p><img src="https://img-blog.csdnimg.cn/f8429c714cf04761b4c7320988c7d9a5.png#pic_center" alt="查询线段树"></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 在区间 [start, end] 中查询区间 [l, r] 的结果，注意 [l, r] 保持不变</span><span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 区间 [l ,r] 完全包含区间 [start, end]</span>    <span class="token comment">// 例如：[2, 4] = [2, 2] + [3, 4]，当 [start, end] = [2, 2] 或者 [start, end] = [3, 4]，直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> start <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> node<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 把当前区间 [start, end] 均分得到左右孩子的区间范围</span>    <span class="token comment">// node 左孩子区间 [start, mid]</span>    <span class="token comment">// node 左孩子区间 [mid + 1, end]</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">pushDown</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> mid <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">-</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        ans <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;</span> mid<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        ans <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="2-完整模板"><a href="#2-完整模板" class="headerlink" title="2. 完整模板"></a>2. 完整模板</h3><p><strong>基于求「区间和」以及对区间进行「加减」的更新操作的常规模板</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 线段树代码</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">// node_idx 为线段树下标，从1开始取</span><span class="token keyword">void</span> <span class="token function">build_tree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> tree<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> node_idx<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//递归的出口，也就是到了叶子节点</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">[</span>node_idx<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">//找到左子树的节点(2*node_idx)</span>        <span class="token comment">//找到右子树的节点(2*node_idx+1)</span>        <span class="token keyword">int</span> left_node <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>node_idx<span class="token punctuation">,</span> right_node <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>node_idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">//将树进行分割，然后左右递归建树</span>        <span class="token function">build_tree</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> left_node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">build_tree</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> right_node<span class="token punctuation">)</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>node_idx<span class="token punctuation">]</span> <span class="token operator">=</span> tree<span class="token punctuation">[</span>left_node<span class="token punctuation">]</span> <span class="token operator">+</span> tree<span class="token punctuation">[</span>right_node<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 查询 [l, r] 的区间和，node_idx 从1开始</span><span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> tree<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> node_idx<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//情况一</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&gt;</span> end <span class="token operator">||</span> r <span class="token operator">&lt;</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> start <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//情况二</span>        <span class="token keyword">return</span> tree<span class="token punctuation">[</span>node_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">//递归查询</span>        <span class="token comment">//找到左子树的节点(2*node_idx)</span>        <span class="token comment">//找到右子树的节点(2*node_idx+1)</span>        <span class="token keyword">int</span> left_node <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>node_idx<span class="token punctuation">,</span> right_node <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>node_idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">//将树进行分割，然后左右递归查询</span>        <span class="token keyword">int</span> left_sum <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> left_node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right_sum <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> right_node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> left_sum <span class="token operator">+</span> right_sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 更新指定下标 update_idx 的元素，node_idx 从1开始取</span><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> tree<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> node_idx<span class="token punctuation">,</span> <span class="token keyword">int</span> update_idx<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//递归的出口，也就是到了叶子节点, 更新其值</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">[</span>node_idx<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">//找到左子树的节点(2*node_idx)</span>        <span class="token comment">//找到右子树的节点(2*node_idx+1)</span>        <span class="token keyword">int</span> left_node <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>node_idx<span class="token punctuation">,</span> right_node <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>node_idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">//如果要更新节点在右边</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>update_idx <span class="token operator">&gt;</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">update</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> right_node<span class="token punctuation">,</span> update_idx<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">//要更新节点在左边</span>            <span class="token function">update</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> left_node<span class="token punctuation">,</span> update_idx<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//要注意更新当前节点！！！！！！</span>        tree<span class="token punctuation">[</span>node_idx<span class="token punctuation">]</span> <span class="token operator">=</span> tree<span class="token punctuation">[</span>left_node<span class="token punctuation">]</span> <span class="token operator">+</span> tree<span class="token punctuation">[</span>right_node<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">93</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">tree</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">build_tree</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"更新前的树:"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> x <span class="token operator">:</span> tree<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token comment">//更新 idx = 4的元素值为 2</span>    <span class="token function">update</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"更新后的树:"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> x <span class="token operator">:</span> tree<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"查询区间[2,4]的和为："</span> <span class="token operator">&lt;&lt;</span> <span class="token function">query</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>基于求「区间和」以及对区间进行「加减」的更新操作，且为「动态开点」的模板</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> lazy<span class="token punctuation">;</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    Node <span class="token operator">*</span>left<span class="token punctuation">;</span>    Node <span class="token operator">*</span>right<span class="token punctuation">;</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lazy</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SegmentTree</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    Node <span class="token operator">*</span>root<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">SegmentTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 更新 [l, r] 区间里面元素</span>    <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> start <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            node<span class="token operator">-&gt;</span>val <span class="token operator">+=</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> val<span class="token punctuation">;</span>            node<span class="token operator">-&gt;</span>lazy <span class="token operator">+=</span> val<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">// 下推懒惰标记</span>        <span class="token function">pushDown</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> mid <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">-</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span>            <span class="token function">update</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;</span> mid<span class="token punctuation">)</span>            <span class="token function">update</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pushUp</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> start <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>            <span class="token keyword">return</span> node<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">pushDown</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> mid <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">-</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span>            ans <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;</span> mid<span class="token punctuation">)</span>            ans <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">pushDown</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">int</span> leftNum<span class="token punctuation">,</span> <span class="token keyword">int</span> rightNum<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            node<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            node<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>lazy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        node<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>val <span class="token operator">+=</span> node<span class="token operator">-&gt;</span>lazy <span class="token operator">*</span> leftNum<span class="token punctuation">;</span>        node<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>val <span class="token operator">+=</span> node<span class="token operator">-&gt;</span>lazy <span class="token operator">*</span> rightNum<span class="token punctuation">;</span>        <span class="token comment">// 更新懒惰标记</span>        node<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>lazy <span class="token operator">+=</span> node<span class="token operator">-&gt;</span>lazy<span class="token punctuation">;</span>        node<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>lazy <span class="token operator">+=</span> node<span class="token operator">-&gt;</span>lazy<span class="token punctuation">;</span>        node<span class="token operator">-&gt;</span>lazy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 这里如果不是维护区间和需要注意改变</span>    <span class="token keyword">void</span> <span class="token function">pushUp</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        node<span class="token operator">-&gt;</span>val <span class="token operator">=</span> node<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>val <span class="token operator">+</span> node<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="3-常见题型"><a href="#3-常见题型" class="headerlink" title="3. 常见题型"></a>3. 常见题型</h3><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/my-calendar-i/">729. 我的日程安排表 I</a></td><td>维护<strong>区间最值</strong>并对区间进行<strong>加减更新</strong>，暴力维护，<strong>差分数组</strong></td><td><a href="https://leetcode.cn/problems/my-calendar-i/solution/by-lfool-xvpv/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/my-calendar-ii/">731. 我的日程安排表 II</a></td><td>维护<strong>区间最值</strong>并对区间进行<strong>加减更新</strong>，暴力维护，<strong>差分数组</strong></td><td><a href="https://leetcode.cn/problems/my-calendar-ii/solution/by-lfool-nodi/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/my-calendar-iii/">732. 我的日程安排表 III</a></td><td>维护<strong>区间最值</strong>并对区间进行<strong>加减更新</strong>，<strong>差分数组</strong></td><td><a href="https://leetcode.cn/problems/my-calendar-iii/solution/xian-duan-shu-by-xiaohu9527-rfzj/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a></td><td>维护<strong>区间和</strong>并对区间进行<strong>覆盖更新</strong>，参考题解的第二份cpp代码</td><td><a href="https://leetcode.cn/problems/my-calendar-iii/solution/xian-duan-shu-by-xiaohu9527-rfzj/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/number-of-recent-calls/">933. 最近的请求次数</a></td><td>维护<strong>区间和</strong>并对区间进行<strong>加减更新</strong>，直接<strong>队列</strong>就可以</td><td><a href="https://leetcode.cn/problems/number-of-recent-calls/solution/by-nehzil-9het/">解</a></td></tr></tbody></table><ul><li>对于表示为<strong>「区间和」</strong>且对区间进行<strong>「加减」</strong>的更新操作的情况，我们在更新节点值的时候『需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『需要累加』！！(这种情况和模版一致！！) 如题目 933.最近的请求次数</li><li>对于表示为<strong>「区间和」</strong>且对区间进行<strong>「覆盖」</strong>的更新操作的情况，我们在更新节点值的时候『需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『不需要累加』！！(因为是覆盖操作！！) 如题目 307.区域和检索 - 数组可修改</li><li>对于表示为<strong>「区间最值」</strong>且对区间进行<strong>「加减」</strong>的更新操作的情况，我们在更新节点值的时候『不需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『需要累加』！！ 如题目 729.我的日程安排表 I、732.我的日程安排表 III</li></ul><blockquote><p>注意：对于题目 <a href="https://leetcode.cn/problems/number-of-recent-calls/">最近的请求次数</a> 和 <a href="https://leetcode.cn/problems/range-sum-query-mutable/">区域和检索 - 数组可修改</a> 可以「不用✖️左右孩子区间叶子节点的数量」</p><p>因为这两个题目是「点更新」，「点更新」和「区间更新」可以合并成一种，「点更新」就是更新长度为 1 的「区间更新」</p></blockquote><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>线段数在多次求取「区间和」问题上具有优势，但是实际面试比较难想出来，而且实际体型中使用常规的方法如暴力维护、差分数组等可能比直接维护 [0, 1e9] 上的线段树时间复杂度低，因此这个数据结构先简单了解就好，具体熟练掌握可能有点难度。</p><blockquote><p>面试中可能很难写出完整线段树，所以这类题如果可以使用差分数组的话尽量直接用差分数组来写，再不济暴力维护也不是不行</p></blockquote><h3 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h3><ul><li><a href="https://leetcode.cn/problems/my-calendar-ii/solution/by-lfool-nodi/">线段树详解「汇总级别整理 🔥🔥🔥」</a></li><li><a href="https://leetcode.cn/problems/my-calendar-iii/solution/xian-duan-shu-by-xiaohu9527-rfzj/">小虎：线段树 – 新手篇</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】字典树深入浅出，一文吃透！</title>
      <link href="suan-fa/10f45ffa0d67.html"/>
      <url>suan-fa/10f45ffa0d67.html</url>
      
        <content type="html"><![CDATA[<h2 id="【LeetCode】字典树"><a href="#【LeetCode】字典树" class="headerlink" title="【LeetCode】字典树"></a>【LeetCode】字典树</h2><p>原文地址：<a href="https://github.com/EricPengShuai/Interview/blob/main/algorithm/%E5%AD%97%E5%85%B8%E6%A0%91.md">https://github.com/EricPengShuai/Interview/blob/main/algorithm/字典树.md</a></p><h3 id="0-定义"><a href="#0-定义" class="headerlink" title="0. 定义"></a>0. 定义</h3><p>字典树又称单词查找数、前缀树、Trie [trai] 树，是一种哈希树的变种，常用于统计、排序和保存大量的字符串（也不限于字符串），所以经常被搜索引擎用于文本词频统计，很直观的用处就在我们在百度和google搜索某个词汇时往往会有“联想提示”。<strong>字典树可以利用字符串的公共前缀减少查询时间，最大限度地减小无用的字符串比较，所以查询效率比哈希树高。</strong></p><p>基本操作有：<strong>查找</strong>、<strong>插入</strong>和删除（比较少）</p><p>Trie 是一颗非典型的多叉树模型，多叉就是每个结点的分支数量可以为多个，为什么说非典型呢？因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，比如一般的多叉树的结点是这样的</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span><span class="token keyword">char</span> value<span class="token punctuation">;</span><span class="token comment">// 结点值</span>TreeNode<span class="token operator">*</span> children<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 指向孩子结点</span><span class="token punctuation">}</span></code></pre><p>Trie 的结点为</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{</span><span class="token keyword">bool</span> isEnd<span class="token punctuation">;</span><span class="token comment">// 该结点是否是一个串的结束</span>TrieNoe<span class="token operator">*</span> next<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 字母映射表</span><span class="token punctuation">}</span></code></pre><p>其中**字符映射表<code>next</code>**的用处在于TrieNode结点中不用直接保存字符值，通过包含 a-z 26个字符的字母映射表标识当前结点下一个可能出现的所有字符的链接，因此我们可以通过一个父节点来预知它所有子结点的值</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parentNode<span class="token operator">-&gt;</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        说明父结点的后一个字母不可为 ch    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        说明父结点的后一个字母可以是 ch    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们来看一个例子：对于包含三个单词 “sea”,”sells”,”she” 的字典树可以是如下的结构：</p><p><img src="https://img-blog.csdnimg.cn/3e72b1ea6ce14653962f26cf2e875836.png#pic_center" alt="Trie"></p><p>字典树中一般还有大量的空链接，因此在绘制一颗单词查找树时一般会忽略空链接，同时为了方便理解我们通常将字典树简化如下：</p><p><img src="https://img-blog.csdnimg.cn/d99f350f7378455d98c45617eb442a53.png#pic_center" alt="SimpledTrie"></p><h3 id="1-常见操作"><a href="#1-常见操作" class="headerlink" title="1. 常见操作"></a>1. 常见操作</h3><p><strong>定义类</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>vector<span class="token operator">&lt;</span>TrieNode<span class="token operator">*</span><span class="token operator">&gt;</span> next<span class="token punctuation">;</span>    <span class="token keyword">bool</span> isEnd<span class="token punctuation">;</span>    <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">isWord</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">children</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>  <span class="token comment">// 手动释放内存</span>    <span class="token operator">~</span><span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> n <span class="token operator">:</span> next<span class="token punctuation">)</span>            <span class="token keyword">delete</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token comment">// 插入和查询操作</span><span class="token punctuation">}</span></code></pre><p><strong>插入</strong></p><p>目的：向 Trie 中插入一个单词 word</p><p>实现：和链表类似，首先从根结点的子结点开始与 word 第一个字符进行匹配，一直匹配到前缀链上没有对应的字符，此时开始<strong>不断开辟新的结点</strong>，直到插入完 word 的最后一个字符，同时还要**将最后一个结点 <code>isEnd = true</code>**，表示它是一个单词的末尾</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>string word<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Trie<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token operator">:</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>next<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          node<span class="token operator">-&gt;</span>next<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">new</span> <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      node <span class="token operator">=</span> node<span class="token operator">-&gt;</span>next<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  node<span class="token operator">-&gt;</span>isEnd <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>查找</strong></p><p>目的：在 Trie 中查找某个单词 word</p><p>实现：从根结点的子结点开始，一直向下匹配即可，<strong>如果没有匹配完就出现结点值为空，返回 <code>false</code>；如果匹配到最后一个字符，直接判断结点 <code>node-&gt;isEnd</code></strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">search</span> <span class="token punctuation">(</span>string word<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Trie<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token operator">:</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node <span class="token operator">=</span> node<span class="token operator">-&gt;</span>next<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> node<span class="token operator">-&gt;</span>isEnd<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>前缀匹配</strong></p><p>目的：判断 Trie 中是否有以 prefix 为前缀的单词</p><p>实现：和 <code>search</code> 操作类似，只是不需要判断最后一个字符结点的 <code>isEnd</code>，因为既然能匹配到最后一个字符，那后面一定有单词是以它为前缀的</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">startsWith</span><span class="token punctuation">(</span>string prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Trie<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node <span class="token operator">=</span> node<span class="token operator">-&gt;</span>next<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>总结</strong></p><p>Trie树 的宗旨是 <strong>一次建树，多次查询</strong>，具有如下特点</p><ul><li><strong>形状唯一</strong>： Trie 的形状和单词的插入或删除顺序无关，也就说对于任意给定的一组单词，Trie 的形状都是唯一的</li><li><strong>查询次数与单词长度相关</strong>：查找或插入一个长度为 <code>L</code> 的单词，访问 next 数组的次数最多为 <code>L+1</code>，和 Trie 中包含多少单词无关</li><li><strong>空间复杂度高</strong>：Trie 的每个结点中都保留一个字母表，这是很耗费空间的。如果 Trie 的高度为 n，字母表大小为 m，最坏的情况是 Trie 中还不存在前缀相同的单词，那么空间复杂度就位 $O(m^n)$</li></ul><h3 id="2-扩展延生"><a href="#2-扩展延生" class="headerlink" title="2. 扩展延生"></a>2. 扩展延生</h3><p>前面说到使用字典树空间复杂度较高，因为用到了 next 数组，每个数组包含 m 个字母 （一般 <code>m=26</code>），另外 m 很大时复杂度就更大。因此可以使用哈希表来存储元素，使用哈希表代替数组进行基本操作时就需要判断是否存在对应的 key，一个很典型的题目如下：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 648.单词替换</span><span class="token keyword">class</span> <span class="token class-name">Trie</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> Trie <span class="token operator">*</span><span class="token operator">&gt;</span> children<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment">// 插入单词建立前缀树</span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>string word<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Trie <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">&amp;</span>c <span class="token operator">:</span> word<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cur<span class="token operator">-&gt;</span>children<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                cur<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cur<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span><span class="token string">'#'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置结束标志</span>    <span class="token punctuation">}</span>    <span class="token comment">// 查询前缀树</span>    string <span class="token function">findRoot</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>word<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        string root<span class="token punctuation">;</span>        Trie <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">&amp;</span>c <span class="token operator">:</span> word<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>children<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token string">'#'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">return</span> root<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cur<span class="token operator">-&gt;</span>children<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">return</span> word<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            root<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">replaceWords</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>dictionary<span class="token punctuation">,</span> string sentence<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Trie <span class="token operator">*</span>trie <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 建立前缀树</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>word <span class="token operator">:</span> dictionary<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            trie<span class="token operator">-&gt;</span><span class="token function">insert</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> words <span class="token operator">=</span> <span class="token function">split</span><span class="token punctuation">(</span>sentence<span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        string ans<span class="token punctuation">;</span>        <span class="token comment">// 对于 sentence 中的每个单词查询前缀</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>word <span class="token operator">:</span> words<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            ans <span class="token operator">+=</span> trie<span class="token operator">-&gt;</span><span class="token function">findRoot</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            ans <span class="token operator">+=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// C++ split 函数</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">split</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>str<span class="token punctuation">,</span> <span class="token keyword">char</span> ch<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> ret<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">==</span> ch<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                pos<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            start <span class="token operator">=</span> pos<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">!=</span> ch<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                pos<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> pos <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>参考：<a href="https://leetcode.cn/problems/replace-words/solution/dan-ci-ti-huan-by-leetcode-solution-pl6v/">单词替换官方题解</a></p><p><strong>另外为了方便管理内存，可以只用<a href="https://github.com/EricPengShuai/Interview/tree/main/c%2B%2B2.0#5-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">智能指针</a>加以优化，例如<a href="https://leetcode.cn/submissions/detail/351429060/">211.添加与搜索单词</a></strong></p><h3 id="3-常见题型"><a href="#3-常见题型" class="headerlink" title="3. 常见题型"></a>3. 常见题型</h3><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></td><td>最基础的构建前缀树题目：通过插入建树，查询操作</td><td><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solution/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/replace-words/">648. 单词替换</a></td><td>暴力法可以，C++需要自己写split函数，通过dictionary建树，对每个单词使用查询前缀操作</td><td><a href="https://leetcode.cn/submissions/detail/351319378/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></td><td>注意对于通配符<code>.</code>的判断最好使用<a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/comments/31808"><strong>递归回溯</strong></a></td><td><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/solution/fu-xue-ming-zhu-qian-zhui-shu-xiang-xi-r-rty2/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/map-sum-pairs/">677. 键值映射</a></td><td>前缀树叶子结点增加 val 属性记录，其实暴力哈希表更简单</td><td><a href="https://leetcode.cn/problems/map-sum-pairs/solution/jian-zhi-ying-she-by-leetcode-solution-j4xy/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/implement-magic-dictionary/">676. 实现一个魔法字典</a></td><td>暴力法，前缀树在查询必须修改一个字母时很绕</td><td><a href="https://leetcode.cn/problems/implement-magic-dictionary/comments/70533">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/prefix-and-suffix-search/">745. 前缀和后缀搜索</a></td><td>注意题目是返回具有前缀和后缀的<strong>单词在字典中的最大下标</strong></td><td><a href="https://leetcode.cn/problems/prefix-and-suffix-search/solution/qian-zhui-he-hou-zhui-sou-suo-by-jiang-h-whm9/">解</a></td></tr></tbody></table><p><strong>说明</strong>：</p><ul><li>「211.添加与搜索单词」这题如果考虑“优化内存”时，可以手动写析构函数，注释如果使用智能指针需要独占的智能指针 <code>unique_ptr</code>，而不能使用共享内存的智能指针 <code>shared_ptr</code>，另外<strong>注意，一般传参的时候用裸指针，尤其是只读情况下，很少直接传智能指针。但也非绝对，也有传智能指针的场景。</strong>传裸指针比智能指针耗时少，参考：<a href="https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/8693">https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/8693</a></li><li>对于『745.前缀和后缀搜索』需要构建一个前缀树和一个后缀树，然后另外需要维护一个<strong>下标数组</strong>用户标识具有指定前缀和后缀的单词下标，具体可以参考：<a href="https://leetcode.cn/problems/prefix-and-suffix-search/solution/qian-zhui-he-hou-zhui-sou-suo-by-jiang-h-whm9/1652146">C++ 前缀后缀树</a></li></ul><h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h3><ol><li><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solution/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/">[路漫漫我不畏] Trie Tree 的实现 (适合初学者)🌳</a></li><li><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solution/by-lfool-k6hb/">详解前缀树「TrieTree 汇总级别整理 🔥🔥🔥」</a></li><li><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/solution/fu-xue-ming-zhu-qian-zhui-shu-xiang-xi-r-rty2/">【负雪明烛】「前缀树」详细入门教程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】二分查找深入浅出，一文吃透！</title>
      <link href="suan-fa/da4545859690.html"/>
      <url>suan-fa/da4545859690.html</url>
      
        <content type="html"><![CDATA[<h2 id="【LeetCode】二分查找"><a href="#【LeetCode】二分查找" class="headerlink" title="【LeetCode】二分查找"></a>【LeetCode】二分查找</h2><blockquote><p>原文地址：<a href="https://github.com/EricPengShuai/Interview/blob/main/algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md">https://github.com/EricPengShuai/Interview/blob/main/algorithm/二分查找.md</a></p></blockquote><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ol><li>基本概念：二分查找就是从一个排好序的序列中查找一个元素，和顺序查找不同的是，二分查找通过逐步缩小搜索区间的方式将搜索范围逐渐缩小，最终定位到我们的目标值或者目标位置，<strong>在STL中，<code>lower_bound()</code> 和 <code>upper_bound()</code> 就是利用二分的思想，前者在有序数组中找到第一个大于等于的目标值的位置，后者找到第一个大于目标值的位置</strong></li><li>排版说明：<ul><li>首先是<strong>套用模板法</strong>，这个很简单，就是记住一个二分查找的模板，然后根据题意套用即可，可以解决99%的问题，但对于个别特殊的问题无法解决，主要参考的是 <a href="https://leetcode.cn/problems/search-insert-position/solution/by-carlsun-2-2dlr/">代码随想录</a> 和 <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/tu-jie-er-fen-zui-qing-xi-yi-dong-de-jia-ddvc/">图解二分</a></li><li>其次是<strong>直接分析法</strong>，这个方法需要忘记所有的模板，没有所谓的「左闭右开」「左闭右闭」的概念，重点是认真理解题意，根据题目的条件分析如何缩减区间，主要参考的是 <a href="https://leetcode.cn/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">liweiwei</a></li></ul></li></ol><h3 id="套用模板法1"><a href="#套用模板法1" class="headerlink" title="套用模板法1"></a>套用模板法1</h3><p>首先说明两个概念：</p><ol><li><p><strong>左闭右闭</strong>：搜索区间范围是 <code>[left, right]</code>，此时循环条件是<code>left &lt;= right</code>，因为<code>left == right</code>时区间也是存在的</p><p>参考代码：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// 定义target在左闭右闭的区间里，[left, right]</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> middle <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            right <span class="token operator">=</span> middle <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在左区间，在[left, middle-1]中</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            left <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在右区间，在[middle+1, right]中</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> middle<span class="token punctuation">;</span> <span class="token comment">// 数组中找到目标值的情况，直接返回下标</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">// 这里需要根据题意分析！！</span>    <span class="token keyword">return</span> right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><ol start="2"><li><p><strong>左闭右开</strong>：搜索区间范围是 <code>[left, right)</code>，此时循环条件是<code>left &lt; right</code>，因为<code>left == right</code>时区间不存在</p><p>参考代码：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// 定义target在左闭右开的区间里，[left, right) </span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> middle <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            right <span class="token operator">=</span> middle<span class="token punctuation">;</span> <span class="token comment">// target 在左区间，在[left, middle)中</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            left <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在右区间，在 [middle+1, right)中</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> middle<span class="token punctuation">;</span> <span class="token comment">// 数组中找到目标值的情况，直接返回下标</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">// 循环结束时有 right&gt;=left，大多数情况下 left == right，但是为了不越界往往返回right</span>    <span class="token keyword">return</span> right<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="套用模板法2"><a href="#套用模板法2" class="headerlink" title="套用模板法2"></a>套用模板法2</h3><blockquote><p>统一将判断条件定位 <code>while(left &lt; right)</code>，根据划分区间的不同选择不同的模板</p></blockquote><ol><li><p><strong>模板一</strong></p><p>将区间 <code>[left, right]</code>划分为分成 <code>[left, mid]</code> 和 <code>[mid + 1, right]</code>，此时计算 mid 不需要 +1</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">bsearch_1</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token keyword">else</span> l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> l<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><ol start="2"><li><p><strong>模板二</strong></p><p>将区间 <code>[left, right]</code>划分为分成 <code>[left, mid-1]</code> 和 <code>[mid, right]</code>，此时计算 mid 需要 +1</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">bsearch_2</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span> l <span class="token operator">+</span> r <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> l <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token keyword">else</span> r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> l<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><p><strong>说明：在大多数情况下，这里使用模板一可以求出左边界，使用模板二可以求出右边界，为什么是大多数情况呢？因为有的题目很特殊需要特别注意判断条件</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">searchRange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 二分范围</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>        <span class="token comment">// 查找元素的开始位置</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> target<span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token keyword">else</span> l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">!=</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 查找失败</span>    <span class="token keyword">int</span> L <span class="token operator">=</span> r<span class="token punctuation">;</span>        l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// 二分范围</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>                   <span class="token comment">// 查找元素的结束位置</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token punctuation">)</span> l <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token keyword">else</span> r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>L<span class="token punctuation">,</span>r<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="直接分析法"><a href="#直接分析法" class="headerlink" title="直接分析法"></a>直接分析法</h3><blockquote><p>这里需要忘记前面提到的左闭右闭和左闭右开区间，根据题意分析 right 的初始值，然后分析下一轮的搜索区间是左侧还是右侧</p><p>这里根据经验，往往设置的是<code> while(left &lt; right)</code>，因为只有这样退出循环时才有 <code>left &gt;= right</code>，往往会有 <code>left == right</code>成立， 为了不越界就使用 right 作为目标位置</p></blockquote><p><strong>常见问题</strong></p><blockquote><ol><li>二分查找不一定要求数组有序</li></ol></blockquote><p>力扣上如「山脉数组」「选择有序数组」等可以<strong>根据 <code>nums[mid]</code> 的值推测两侧元素的性质，进而缩小搜索区间</strong>，这类数组都是接近有序的数组</p><p>还有如「<a href="https://leetcode.cn/problems/find-the-duplicate-number/">寻找重复数</a>」不在输入数组上做二分，而是<strong>在输入数组的最小值 min 和最大值 max 组成的连续整数数组上查找一个数</strong>，也就是搜索区间是 <code>[min...max]</code></p><blockquote><ol start="2"><li>二分查找取 mid 时何时+1</li></ol></blockquote><p>首先何时+1何时不+1是为了避免<strong>死循坏</strong>，对于有偶数个元素的区间来说，使用 <code>mid = (left+right)/2</code> 只能取到<strong>左边的中位数</strong>，如果想要取到<strong>右边的中位数</strong>就必须+1</p><p>再来看为什么有时需要取到右边的首位数，考虑只有两个元素的区间，利用 mid 将区间分为 <code>[left, mid-1]</code> 和 <code>[mid, right]</code>时，如果不+1则无法缩减区间，进而进入死循环</p><p><strong>总结</strong></p><ul><li><p>写成 <code>while(left &lt; right)</code>，退出循环的时候有 <code>left == right</code> 成立，好处是：不用判断应该返回 left 还是 right；</p></li><li><p>区间 <code>[left..right]</code> 划分只有以下两种情况：</p><ul><li>分成 <code>[left..mid]</code> 和 <code>[mid + 1..right]</code>，分别对应 <code>right = mid</code> 和 <code>left = mid + 1</code>；</li><li>分成 <code>[left..mid - 1]</code> 和 <code>[mid..right]</code>，分别对应 <code>right = mid - 1</code> 和 <code>left = mid</code>，这种情况下。需要使用 <code>int mid = (left + right + 1) / 2</code>，否则会出现死循环，这一点不用记，出现死循环的时候，把 left 和 right 的值打印出来看一下就很清楚了；</li></ul></li><li><p>退出循环 <code>left == right</code>，如果可以确定区间 <code>[left...right]</code> 一定有解，直接返回 left 就可以，否则还需要对 left 这个位置单独做一次判断；</p></li><li><p>始终保持不变的是：在区间 <code>[left...right]</code> 里查找目标元素。</p></li></ul><h3 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h3><h4 id="1-二分求下标"><a href="#1-二分求下标" class="headerlink" title="1. 二分求下标"></a>1. 二分求下标</h4><p>在给定数组中查找符合条件的元素下标</p><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/binary-search/">704.二分查找</a></td><td>简单的二分即可，常规思路</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/search-insert-position/">35.搜索插入位置</a></td><td>找到插入位置的索引，可以是len，因此可以设置right=len</td><td><a href="https://leetcode.cn/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/longest-increasing-subsequence/solution/">300.最长上分子序列</a></td><td>这题DP思路比较简单，二分查找比较难</td><td><a href="https://leetcode.cn/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34.排序数组查找第一个和最后一个位置</a></td><td>可以总结为两个模板：<strong>查找左边界</strong>和<strong>查找右边界</strong></td><td><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/tu-jie-er-fen-zui-qing-xi-yi-dong-de-jia-ddvc/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/valid-triangle-number/">611.有效三角形的个数</a></td><td><strong>二分有两种思路</strong>：左边界和右边界，<strong>双指针</strong>：固定最长边逆序</td><td><a href="https://leetcode.cn/problems/valid-triangle-number/solution/ming-que-tiao-jian-jin-xing-qiu-jie-by-jerring/">解1</a> <a href="https://leetcode.cn/problems/valid-triangle-number/solution/er-fen-cha-zhao-python-dai-ma-java-dai-ma-by-liwei/">解2</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-k-closest-elements/">659.找到K个最接近的元素</a></td><td>二分找到左边界，双指针</td><td><a href="https://leetcode.cn/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-right-interval/">436.寻找右区间</a></td><td>使用哈希表记录第一个元素位置之后在[:][0]二分查找[:][1]</td><td><a href="https://leetcode.cn/problems/find-right-interval/solution/by-fuxuemingzhu-98m1/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-positive-integer-solution-for-a-given-equation/">1237.找出给定方程的正整数解</a></td><td>二分利用一个变量递增，双指针利用两个变量都递增</td><td><a href="https://leetcode.cn/problems/find-positive-integer-solution-for-a-given-equation/solution/xiang-jie-bao-li-er-fen-yu-shuang-zhi-zhen-fa-by-q/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4.寻找两个正序数组的中位数</a></td><td>直接归并比较简单，通过二分找到__分割线__比较难</td><td><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/he-bing-yi-hou-zhao-gui-bing-guo-cheng-zhong-zhao-/">解</a></td></tr></tbody></table><p><strong>「选择数组」和「山脉数组」：局部单调性</strong></p><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33.搜索旋转排序数组</a></td><td>直接在循环里面定位比较直接，<strong>在外面定位<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/solution/er-fen-fa-python-dai-ma-java-dai-ma-by-liweiwei141/129291">思考</a>很细节</strong></td><td><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/solution/er-fen-fa-python-dai-ma-java-dai-ma-by-liweiwei141/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">81.搜索旋转排序树组II</a></td><td>在 33 基础上通过<code>++left</code>去重，或者直接 <a href="https://leetcode.cn/submissions/detail/170342574/">while去重</a></td><td><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/solution/er-fen-cha-zhao-by-liweiwei1419/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153.旋转排列数组最小值</a></td><td>通过<strong>比较 mid 和 right</strong> 判断最小值在左还是右</td><td><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">154.旋转排序数组最小值II</a></td><td>在 153 基础上通过 <code>-- right</code> 去重</td><td><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/solution/154-find-minimum-in-rotated-sorted-array-ii-by-jyd/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/">852.山脉数组的峰顶索引</a></td><td>找到<strong>最小满足</strong> <code>nums[i] &gt; nums[i+1]</code> 的下标</td><td><a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/solution/shan-mai-shu-zu-de-feng-ding-suo-yin-by-dtqvv/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-in-mountain-array/">1095.山脉数组找目标值</a></td><td><strong>三个二分</strong>：找到峰顶下标，升序找target，降序找target</td><td><a href="https://leetcode.cn/problems/find-in-mountain-array/solution/shi-yong-chao-hao-yong-de-er-fen-fa-mo-ban-python-/">解</a></td></tr></tbody></table><h4 id="2-二分找答案"><a href="#2-二分找答案" class="headerlink" title="2. 二分找答案"></a>2. 二分找答案</h4><p>在给定的序列中找一个满足条件的答案，通过二分查找逐渐缩小范围，最后逼近到一个数</p><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/sqrtx/">69.x的平方根</a></td><td>使用除法可以避免溢出，另有一个 <a href="https://leetcode.cn/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/">牛顿迭代法</a></td><td><a href="https://leetcode.cn/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287.寻找重复数</a></td><td>二分思路有点绕，<a href="https://leetcode.cn/problems/find-the-duplicate-number/solution/287xun-zhao-zhong-fu-shu-by-kirsche/">循环链表</a>思路比较直接</td><td><a href="https://leetcode.cn/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/guess-number-higher-or-lower/">374.猜数字大小</a></td><td>比较简单的二分，注意一下题意就好</td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/h-index-ii/">275.H指数 II</a></td><td>注意向左找还是向右找的条件</td><td><a href="https://leetcode-cn.com/problems/h-index-ii/solution/jian-er-zhi-zhi-er-fen-cha-zhao-by-liweiwei1419-2/">解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold/">1283.使结果不超过阈值的最小除数</a></td><td>注意不整除才+1</td><td><a href="https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold/solution/er-fen-cha-zhao-ding-wei-chu-shu-by-liweiwei1419/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/">1292. 元素和小于等于阈值的正方形的最大边长</a></td><td>二维前缀和，遍历二分</td><td><a href="https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/solution/yuan-su-he-xiao-yu-deng-yu-yu-zhi-de-zheng-fang-2/">解</a></td></tr></tbody></table><ul><li><input disabled="" type="checkbox"> 其实按照 liweiwei 的总结还有第三个题型，这里就不继续刷了，先消化消化</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实二分的题目刷多了就有经验了，最主要的分析出<strong>二分判断的条件</strong>，根据题意判断出是在左区间还是右区间查找元素。另外对于二分意图不明显的题目需要尝试分析出题目的<strong>隐藏题意</strong></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>大部分参考自：<a href="https://leetcode.cn/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">写对二分查找不是套模板并往里面填空，需要仔细分析题意</a></li><li>另模板1参考自：<a href="https://leetcode.cn/problems/search-insert-position/solution/by-carlsun-2-2dlr/">代码随想录</a></li><li>另模板2参考自：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/tu-jie-er-fen-zui-qing-xi-yi-dong-de-jia-ddvc/">图解二分</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++】lambda表达式</title>
      <link href="bian-cheng-bei-wang/868f1faa4d10.html"/>
      <url>bian-cheng-bei-wang/868f1faa4d10.html</url>
      
        <content type="html"><![CDATA[<h2 id="【C-】lambda-表达式"><a href="#【C-】lambda-表达式" class="headerlink" title="【C++】lambda 表达式"></a>【C++】lambda 表达式</h2><blockquote><p>源代码：<a href="https://github.com/EricPengShuai/Interview/blob/main/c%2B%2B2.0/lambda.cpp">https://github.com/EricPengShuai/Interview/blob/main/c%2B%2B2.0/lambda.cpp</a></p></blockquote><p>lambda 表达式C++11引入的，可以编写内嵌的匿名函数，代替独立函数等。在C++14中添加新特性，又加以强化。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 完整语法</span><span class="token punctuation">[</span> capture<span class="token operator">-</span>list <span class="token punctuation">]</span> <span class="token punctuation">(</span> params <span class="token punctuation">)</span> <span class="token keyword">mutable</span><span class="token punctuation">(</span>optional<span class="token punctuation">)</span> <span class="token keyword">constexpr</span><span class="token punctuation">(</span>optional<span class="token punctuation">)</span><span class="token punctuation">(</span>c<span class="token operator">++</span><span class="token number">17</span><span class="token punctuation">)</span> exception attribute <span class="token operator">-&gt;</span> ret <span class="token punctuation">{</span> body <span class="token punctuation">}</span> <span class="token comment">// 可选的简化语法</span><span class="token punctuation">[</span> capture<span class="token operator">-</span>list <span class="token punctuation">]</span> <span class="token punctuation">(</span> params <span class="token punctuation">)</span> <span class="token operator">-&gt;</span> ret <span class="token punctuation">{</span> body <span class="token punctuation">}</span>     <span class="token punctuation">[</span> capture<span class="token operator">-</span>list <span class="token punctuation">]</span> <span class="token punctuation">(</span> params <span class="token punctuation">)</span> <span class="token punctuation">{</span> body <span class="token punctuation">}</span>    <span class="token punctuation">[</span> capture<span class="token operator">-</span>list <span class="token punctuation">]</span> <span class="token punctuation">{</span> body <span class="token punctuation">}</span> </code></pre><p><strong>参数说明：</strong></p><ul><li><p><strong>capture-list</strong>：捕捉列表，这个不用多说，前面已经讲过，记住它不能省略；</p></li><li><p><strong>params</strong>：参数列表，可以省略（但是后面必须紧跟函数体）；</p></li><li><p><strong>mutable</strong>：可选，将<code>lambda</code>表达式标记为<code>mutable</code>后，函数体就可以修改传值方式捕获的变量；</p></li><li><p><strong>constexpr</strong>：可选，C++17，可以指定<code>lambda</code>表达式是一个常量函数；</p></li><li><p><strong>exception</strong>：可选，指定<code>lambda</code>表达式可以抛出的异常；</p></li><li><p><strong>attribute</strong>：可选，指定<code>lambda</code>表达式的特性；</p></li><li><p><strong>ret</strong>：可选，返回值类型；</p></li><li><p><strong>body</strong>：函数执行体</p></li></ul><h3 id="常见写法"><a href="#常见写法" class="headerlink" title="常见写法"></a>常见写法</h3><ol><li><p>基本表达式</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> basicLambda <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Basic Lambda Express!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">basicLambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><ol start="2"><li><p>带参数</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> add <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><ol start="3"><li><p>捕获变量</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// [] 其实就是一个闭包，用来定义捕捉模式以及变量，表示的是lambda捕捉块</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">auto</span> add_x <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">// 复制捕捉x，不可以修改x</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> multiply_x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 引用捕捉x，可以修改x</span>    <span class="token keyword">return</span> a <span class="token operator">*</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">add_x</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token function">multiply_x</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">// mutbale 关键字可以让复制捕捉方式的表示修改参数</span><span class="token keyword">auto</span> add_x_mutable <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">{</span>    x <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">add_x_mutable</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre></li></ol><ol start="4"><li><p>lambda 表达式禁用了辅助操作符，但是没有禁用复制构造函数</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// add_x_mutable 是上面定义的</span><span class="token keyword">auto</span> add_copy <span class="token operator">=</span> add_x_mutable<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">add_copy</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre></li></ol><ol start="5"><li><p>lambda 表达式作为传递的参数</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token function">count_if</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> x <span class="token operator">&gt;</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">vt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">generate</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> value <span class="token operator">=</span> b<span class="token punctuation">;</span>    b <span class="token operator">=</span> b <span class="token operator">+</span> a<span class="token punctuation">;</span>    a <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> element<span class="token operator">:</span> vt<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> element <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre></li></ol><ol start="6"><li><p>常见捕获形式</p><ul><li><p><code>[]</code>：默认不捕获任何变量；</p></li><li><p><code>[=]</code>：默认以值捕获所有变量；</p></li><li><p><code>[&amp;]</code>：默认以引用捕获所有变量；</p></li><li><p><code>[x]</code>：仅以值捕获x，其它变量不捕获；</p></li><li><p><code>[&amp;x]</code>：仅以引用捕获x，其它变量不捕获；</p></li><li><p><code>[=, &amp;x]</code>：默认以值捕获所有变量，但是x是例外，通过引用捕获；</p></li><li><p><code>[&amp;, x]</code>：默认以引用捕获所有变量，但是x是例外，通过值捕获；</p></li><li><p><code>[this]</code>：通过引用捕获当前对象（其实是复制指针）；</p></li><li><p><code>[*this]</code>：通过传值方式捕获当前对象；</p></li></ul><blockquote><p>最好不要使用 [=] [&amp;] 捕获所有变量，可能会出现悬挂引用</p></blockquote></li></ol><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><h4 id="捕捉表达式"><a href="#捕捉表达式" class="headerlink" title="捕捉表达式"></a>捕捉表达式</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">auto</span> y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>r <span class="token operator">=</span> x1<span class="token punctuation">,</span> x1 <span class="token operator">=</span> x1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    r <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x1 <span class="token operator">*</span> x1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> x1 <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">auto</span> z <span class="token operator">=</span> <span class="token punctuation">[</span>str <span class="token operator">=</span> <span class="token string">"string"</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre><h4 id="泛型表达式"><a href="#泛型表达式" class="headerlink" title="泛型表达式"></a>泛型表达式</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span>  add1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token punctuation">,</span> <span class="token keyword">auto</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span>  <span class="token function">add1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token function">add1</span><span class="token punctuation">(</span><span class="token number">2.3</span><span class="token punctuation">,</span> <span class="token number">2.3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre><h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">for_each</span><span class="token punctuation">(</span>vt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vt<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/d686ad9de817">https://www.jianshu.com/p/d686ad9de817</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021总结</title>
      <link href="sheng-huo-sui-bi/3ed2242071f5.html"/>
      <url>sheng-huo-sui-bi/3ed2242071f5.html</url>
      
        <content type="html"><![CDATA[<h2 id="2021总结"><a href="#2021总结" class="headerlink" title="2021总结"></a>2021总结</h2><p>这一年总的来说要比2020年要好，2020年由于保研之后自己的心理斗争下半年过得很糟糕，今年继续研究生生活之后感觉也没有那么糟糕，超出了我预期的研究生生活。这里我记录一下2021生活，分为面试打工的上半年以及生活打工的下半年。</p><h3 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h3><p>2020年年末我写了一份年终总结，记得当时也是由于疫情放假比较早，12月底就回家了，当时怀着“沉重”的心情写了那份总结（在生活随笔中可以找到：<code>2020总结</code>）。2021上半年是我面试打工的半年。当时由于保研之后自己的想直接工作的心理，所以当时回家之后就 想着是在家准备面试技巧，刷题，看面经……与此同时还需要在实验室某个项目里面看看论文，做做项目。所以整个上半年就是边面试边打工的时期，虽然最后面试没有一个成功通过的<span class="github-emoji"><span>😅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，但是那段时间也是在面试实习和实验室打工之间相当矛盾！</p><p>自从学校回家之后有一直有准备面试的想法，所以2021年1月就开始着手准备了，这个博客也是当时搭建。我的实验室打工生活还要从那天一个阳光明媚的下午，那天我刚打完游戏（记得还是在幺幺家的阳台上晒着太阳），接到了杨老师的电话说：“你最近在是忙什么吗？”，我说在就在实验室华为那个项目的基础上做做毕设，然后他说：“哦，你们毕业之后就要入学了，现在我想着是和一个在清华读博后的师兄带着你和HJL看看论文，然后着手开始上手研究生生活的论文，我们就就着移动流媒体这个方向先开始读读论文，然后着手开始写！”，当时我也就随口答应了。当时事后还想着：唉，我这边的面试还要继续准备啊，又要着手干着实验室项目，真是太难了，不过还是读论文也对我的毕业设计有点帮助，就这样吧！随后我和JL就开始差不多每周一次的论文汇报工作。那段时间虽说比较难受，但是现在回过头来想想看也是有收获的，知道如何阅读论文、如何检索论文，了解到了目前我们这个方向有哪些会议和期刊可以试着看看。我当时的方向和毕设的方向也是一致：全景视频中的视野预测方向，当时也是接着论文中的方向一步一步走下去，入门了PyTorch（这里推荐一下B站刘二大人的PyTorch实践），维护了一个仓库：<a href="https://github.com/EricPengShuai/Pytorch-Learning">https://github.com/EricPengShuai/Pytorch-Learning</a> 到现在竟然有6个<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，现在也在维护，如果有自己学习PyTorch的心得也会不断的记录</p><p>上半年也坚持着在LeetCode上刷题，想着准备面试，然后暑期去实习赚点钱，所以当时在准备看论文做实验室项目的同时还需要刷刷题，看看面经，这里是我当时刷题记录：</p><img src="https://s2.loli.net/2022/01/14/lbzGSg4Z52dPTq3.png" alt="leetcodeRecord.png" style="zoom:80%;"><p>可以看到基本上做到了每天一题，后半年入学之后就没有刷了，并且之前刷的题也都忘记了。当时是3月中旬去的学校，记得我面试的公司有：字节、快手、百度等等，当时自己也在维护一个仓库：<a href="https://github.com/EricPengShuai/Interview">https://github.com/EricPengShuai/Interview</a> 记录自己的面试经历以及一些八股文，记得当时最有把握的两个面试是一个字节的火山引擎部门，一面之后HR就问我能实习多久，面试官给的反馈也比较好，但是当时自己唯唯诺诺不敢多说：两个月（那边要求是三个月及以上），所以连二面都没有就直接给我拒了；还有一个自己很有把握的面试快手的社科部门，一二面都过了，三面回答的也还行（最后被那个几个脑筋急转弯的智力题给弄崩了），随后而来的也是“很遗憾”的短信通知<span class="github-emoji"><span>😞</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f61e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>一连着准备和面试了一个多月，我的面试最终结束于百度用户质量效能部门的测试开发工程师，当时搞笑的还是那个面试官以为我是参加春招补招（6月份春招也基本结束了），谁知道我只是想找一个实习，所以进入到如流和面试官简单聊了几句之后就下了，这之后我也就没怎么准备面试了，其他时候就准备毕设论文了，记得毕设答辩时间是5月底，记得答辩那天得知到袁隆平爷爷永远的离开了我们<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><img src="https://s2.loli.net/2022/01/14/oMWBcq2NugAspPX.jpg" alt="pyq.jpg" style="zoom:80%;"><p>当时答辩之后我申请了一个优秀学士学位论文，最终获得了一个校级奖项。再然后我就毕业了，和舍友一起拍了毕业照，和好兄弟也拍了几张照，全院同学也合了照，唯一遗憾的就是没有和女同学合照🥺，再然后就毕业了，拿到了毕业证书和学士学位证书，再然后就没有然后了，然后也写一些关于本科期间的感受（在生活随笔中可以找到：<code>毕业了？</code>）</p><h3 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h3><p>2021年9月1号我们开学了，以研究生的新身份再次来到北邮。再开始来的时候以为研究生生活是“很难受”的（论文上各种吐槽加上自己心理上的低预期），但是当我自己真正经历过之后感觉也不是我想象中那么糟糕，反而超出了我的预期。</p><p><strong>9月份</strong>，开学那天忙着帮宿舍，登记信息，那天晚上和JL他们一起在新食堂四楼吃了晚饭，然后那天好像杨老师开了一个会。记得开学没几天好兄弟奔总叫我和Wei哥一起去他那吃另一个饭。之后开始了选课，上课，实验室项目等等常规的研究生生活，记得当时参加了计院的足球队，最后是进入了二队，虽然实际比赛中没能首发踢上几场，但是每次踢球的时候好开心啊<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，也是从那段时间开始我研究生生活的体育活动就丰富了起来，经常和实验室同学师兄师姐一起打打乒乓球，周二和周五晚上打打羽毛球，周末的时候被路哥带着健健身（立个Flag：下学期办卡去<span class="github-emoji"><span>😤</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f624.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，争取一周三次健身）；<strong>10月份</strong>印象最深的是我们组去了郑州“出差”，人生第一次“出差”（实际上就是做项目），我们去了河南的郑州轻工业大学，辅助那边的老师完成他们申报的一个河南省科技进步一等奖，很开心和Han哥、Feng哥、Lu哥、RenJie的一周出差生活，感觉也是从那段时间开始自己和师兄们聊得开了，也了解了同学的性格，总的来说，收获很大！最后我们10月中旬回到了学校，10月底就是参加足球赛了，虽然只作为替补上场了一次，但是也认识了很多好兄弟。<strong>11月份</strong>可能就是艺馨杯了，那也是我第一次参加这种文艺活动，虽然没有一点经验，但是还是“主演”了那个话剧（可能是研究生大家对于这种活动都不太感冒吧，当时我是想着多交几个朋友的念头去的，说白了就是结交一下），也是从那次开始我认识好几个朋友，和YunPeng逐渐熟悉了起来，认识了Li姐，LiXue，YiBing，和Jing姐也熟悉了起来……那次艺馨杯我们计院在研究生组竟然还是第一名，最后成功碰杯🎉，那晚我们几个和工作人员一起出去唱歌，吃饭（我没吃，太晚了），晚上1点多才回到学校。对了11月我还过一个很快乐的生日，又老了一岁🎂；<strong>12月份</strong>可以说是论文月和考试月，月初到月中写了一篇实验室的JNNA论文，帮助Mu哥完成了ConVLSTM的仿真，投了ICME。之后就是准备了大作业和考试了，大数据作业当时有点头秃🤯，图论考试全是选择题，感觉有点凉（到现在还没出分<span class="github-emoji"><span>😨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f628.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）……流水账记得差不多了，最后来一张照片吧</p><p><img src="https://s2.loli.net/2022/01/14/Vq1ZYCd5QPAxeE6.jpg" alt="0123.jpg"></p><p>2022年我们一起跨年了！1月4号我们成功举办了实验室的年会，很成功！</p><h3 id="来年愿望"><a href="#来年愿望" class="headerlink" title="来年愿望"></a>来年愿望</h3><ul><li>写好论文</li><li>夯实语言，准备面试</li><li>交朋友！！！谈对象</li><li>做好锻炼，健康生活</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Git】一个主机上Git同时配置两个GitHub账号</title>
      <link href="xiao-ji-qiao/adc772553d7d.html"/>
      <url>xiao-ji-qiao/adc772553d7d.html</url>
      
        <content type="html"><![CDATA[<h2 id="【Git】一个主机配置多个GitHub账号（Windows，MacOS，Linux都适用）"><a href="#【Git】一个主机配置多个GitHub账号（Windows，MacOS，Linux都适用）" class="headerlink" title="【Git】一个主机配置多个GitHub账号（Windows，MacOS，Linux都适用）"></a>【Git】一个主机配置多个GitHub账号（Windows，MacOS，Linux都适用）</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><blockquote><p>我开始的需要求是投稿论文的时候由于是<strong>匿名审稿</strong>，而我又需要上传源代码，所以打算把代码提交到GitHub上，匿名审稿不能用暴露自己个人信息的账号，所以就新建了一个账号，但是当我commit的时候发现提交人依然是自己之前的账号信息，而当我push的时候出现no permission，所以就需要配置一下新账号的信息</p></blockquote><p>我的环境是 windows 10，之前已经有了github账号，该账号的ssh已经配置，之前使用https和ssh都可以push，但是新账号没有配置所以没办法提交</p><p>下面我的方法<strong>使用ssh方式提交代码</strong>，需要配置新账号的公钥和私钥</p><h3 id="2-配置-ssh文件"><a href="#2-配置-ssh文件" class="headerlink" title="2. 配置.ssh文件"></a>2. 配置<code>.ssh</code>文件</h3><h4 id="2-1-在-ssh文件夹目录下面生成公钥和私钥"><a href="#2-1-在-ssh文件夹目录下面生成公钥和私钥" class="headerlink" title="2.1 在.ssh文件夹目录下面生成公钥和私钥"></a>2.1 在.ssh文件夹目录下面生成公钥和私钥</h4><p>windows中<code>.ssh</code>文件的路径为：<code>C:\Users\用户名\.ssh</code><br>生成公钥和私钥的命令为：<code>ssh-keygen -t rsa -f id_rsa_new</code>，然后一直按回车就可以了，这个时候会在ssh文件夹目录下面生两个文件（公钥和私钥文件），如下图（<font color="red">其中以.pub结尾的文件是公钥，没有后缀的是私钥，config是自己创建的配置文件，know_hosts好像没用？</font>）：<br><img src="https://img-blog.csdnimg.cn/img_convert/49b953ba27c07738d9e3278460cfca1e.png" alt=".ssh dir"></p><h4 id="2-2-将公钥复制粘贴到github的SSH-and-GPG-keys中"><a href="#2-2-将公钥复制粘贴到github的SSH-and-GPG-keys中" class="headerlink" title="2.2 将公钥复制粘贴到github的SSH and GPG keys中"></a>2.2 将公钥复制粘贴到github的SSH and GPG keys中</h4><ul><li>首先创建进入github的<strong>setting</strong>页面，然后点击<strong>SSH and GPG keys</strong>，新建一个<strong>SSH keys</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/3eecd5b323620612ee2847748e6e050d.png" alt="SSH"></li><li>然后随便去一个名字，将生成的**.pub公钥**粘贴到下面：<br><img src="https://img-blog.csdnimg.cn/img_convert/761d16b0f24592aeb2eb40602f0f0fb4.png" alt="SSH Add"><h3 id="3-将私钥添加到本地的git账户中"><a href="#3-将私钥添加到本地的git账户中" class="headerlink" title="3. 将私钥添加到本地的git账户中"></a>3. 将私钥添加到本地的git账户中</h3><h4 id="3-1-添加两个私钥到本地git账户"><a href="#3-1-添加两个私钥到本地git账户" class="headerlink" title="3.1 添加两个私钥到本地git账户"></a>3.1 添加两个私钥到本地git账户</h4><pre class="language-bash" data-language="bash"><code class="language-bash">ssh-agent <span class="token function">bash</span>ssh-add id_rsa_github<span class="token comment"># 之前已有的github账号信息</span>ssh-add id_rsa_new<span class="token comment"># 新生成的账号信息</span></code></pre><blockquote><p>其中<code>ssh-agent bash</code>（或<code>eval $(ssh-agent)</code>）会启动一个进程在内存里管理这些私钥，可以把它理解成一个私钥管理中心<br>添加之后可以使用<code>ssh-add -l</code>命令查看一下是否添加成功</p></blockquote></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/7487963d1a4b1c3c027c44afce8879a6.png" alt="ssh-add"></p><h4 id="3-2-创建config文件"><a href="#3-2-创建config文件" class="headerlink" title="3.2 创建config文件"></a>3.2 创建config文件</h4><p>自己在ssh文件夹新建一个txt文件，然后重命名为config，具体内容如下：<br><img src="https://img-blog.csdnimg.cn/img_convert/b9bfadd1cbeb6c7ac0c15d734a4c4838.png" alt="config"><br>config文件中部分参数含义：</p><pre class="language-none"><code class="language-none"># Host: 主机别名# HostName: 托管平台域名地址，如github.com# IdentityFile : 指明上面User对应的identityFile路径# User: 托管平台用户名# Port: 端口号，可不填（如果不是默认22号端口则需要指定）# PreferredAuthentications publickey</code></pre><h3 id="4-测试是否连通"><a href="#4-测试是否连通" class="headerlink" title="4. 测试是否连通"></a>4. 测试是否连通</h3><p>使用ssh -T测试一下：记住前面设置的<strong>hostname</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/d3fa0b1d31efb4fbf04ce40171009021.png" alt="ssh -T"><br>出现 <font color="red">“Hi ……”</font> 就说明新账号的公钥和私钥都配置成功了</p><h3 id="5-使用新账号提交代码"><a href="#5-使用新账号提交代码" class="headerlink" title="5. 使用新账号提交代码"></a>5. 使用新账号提交代码</h3><h4 id="5-1-新建仓库"><a href="#5-1-新建仓库" class="headerlink" title="5.1 新建仓库"></a>5.1 新建仓库</h4><p>首先在新建的文件夹中初始化仓库: <code>git init .</code></p><h4 id="5-2-设置新仓库的用户信息"><a href="#5-2-设置新仓库的用户信息" class="headerlink" title="5.2 设置新仓库的用户信息"></a>5.2 设置新仓库的用户信息</h4><p>设置新账号的用户信息，因为你的电脑中git账号信息都是之前的，所有的仓库建立之后的账户信息都是默认之前的，所以需要在新仓库中设置新的用户名和邮箱，具体命令如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config user.name <span class="token string">"userName"</span>       <span class="token comment"># 你的用户名</span><span class="token function">git</span> config user.email <span class="token string">"email address"</span> <span class="token comment"># 你的邮箱地址</span></code></pre><h4 id="5-3-设置新仓库的地址"><a href="#5-3-设置新仓库的地址" class="headerlink" title="5.3 设置新仓库的地址"></a>5.3 设置新仓库的地址</h4><p>之前都是配置ssh，所以这里添加仓库的ssh地址就可以（当然https地址也可以），<font color="red"><strong>修改ssh地址的hostname为config文件中设置host就可以了</strong></font></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">add</span> <span class="token function">ssh</span> <span class="token punctuation">[</span>URL<span class="token punctuation">]</span></code></pre><p>对于你的新账号，这里的URL比如可以是：<code>git@host:username/repository_name.git</code> (<strong>就是将下图中的github.com改成config文件中你新账号的hostname</strong>)<br><img src="https://img-blog.csdnimg.cn/img_convert/0dbec0f78500c542e8dcfd02f597f526.png" alt="SSH url"></p><h4 id="5-4-提交代码"><a href="#5-4-提交代码" class="headerlink" title="5.4 提交代码"></a>5.4 提交代码</h4><p>最后就可以使用新账号的信息提交代码了，什么git add，git commit 都可以，最后<code>git push ssh master</code>即可</p><hr><p>参考：<a href="https://blog.51cto.com/u_4160094/2912836">https://blog.51cto.com/u_4160094/2912836</a></p><hr><p><font face="黑体" color="black" size="5"><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 码字不易，如果对你有帮助，求三连支持！<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></font></p>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业了？</title>
      <link href="sheng-huo-sui-bi/0410ac902f84.html"/>
      <url>sheng-huo-sui-bi/0410ac902f84.html</url>
      
        <content type="html"><![CDATA[<p>现在是2021年7月底，本科毕业已经一个多月了，“距离开学还有一个多月时间”，现在想总结一下我的本科生活以及现在的一些所闻所感。</p><img src="https://i.loli.net/2021/07/23/eHlv1xKTptXNShf.jpg" alt="微信图片_20210723142115.jpg" style="zoom:50%;"><h2 id="本科四年"><a href="#本科四年" class="headerlink" title="本科四年"></a>本科四年</h2><p>总的来说大一懵懵懂懂，大二继续探索，大三干劲十足，大四有些落寞…</p><p>2017年9月来到北邮，以为大学生活是多姿多彩、十分轻松的，结果没过几个月就感觉有点压力：生活上有点不适应、学习上感觉跟不上、朋友之间相处的不是那么融洽……（也许也和自己的性格相关）。很是感谢当时的高中同学兼大学同学，谢谢她在我刚刚来到北邮的照顾。</p><p>2018年下半年到了大二，相应的专业课也比较多，这学年参加了较多的志愿活动，和大奔、英杰一起的夕阳再晨志愿活动很是充实（这也想我们的志愿德育分直接拿满）。这一年自己也在不断探索大学生活，由于自己处理不了学习和学生工作之间的关系，辞去了班长的职务。年底学校发了大一学年的二等奖学金3000。</p><p>2019年下半年到了大三，为了最后的保研努力冲刺专业课，提升绩点。这一年的相应的课外活动就减少了许多，年底拿到了学校发的大二学年励志奖学金5000。2020年初疫情爆发，开启了在家的学习生活，当时还想着找一个线上实习，想借此能帮助自己保研。</p><p>2020年下半年开学到了学校，也就是保研的9推活动开始，当时自己的心路历程十分复杂（具体记录在2020年底的那一晚）。</p><img src="https://i.loli.net/2021/07/23/BP1Yl8RX2buvaCo.jpg" alt="微信图片_20210723142125.jpg" style="zoom:50%;"><img src="https://i.loli.net/2021/07/23/dlhcZW51jrtQ2AU.jpg" alt="微信图片_20210723142130.jpg" style="zoom:50%;"><p>2021年6月毕业季，是的，我也毕业了，很快乐也很不安（自己究竟要不要读这个研究生，但是总感觉自己没有底气也没有勇气不读，不知道读三年之后会不会有提升，是不是还不如现在就业的同学们，说不定到时候我找工作的时候人接直接成为我的leader，心理想直接工作，但是实际上有需要完成实验室的搬砖工作，所以左右为难，而且随着实验室任务的增多会逐渐消磨直接的工作的想法，也许这就是生活吧：生活总是会在你不经意的时候消磨你生活的意志）</p><p>我不知道这四年我到底学到了多少有用的知识，也不知道未来的我能否达到预期的目标。但是我很喜欢一句话：你只管努力，剩下的交给时间！</p><p>不管未来怎样好吧，毕业快乐🎓，朋友们👩‍🎓，希望“苟富贵，勿相忘”。</p><img src="https://i.loli.net/2021/07/23/li9bwxXa2JUkIKE.jpg" alt="d0d5a39674b93bcd67111b254579ba1.jpg" style="zoom:50%;"><h2 id="未来三年？"><a href="#未来三年？" class="headerlink" title="未来三年？"></a>未来三年？</h2><p>目前我想的是：应该还是会在小破邮待上三年吧。</p><p>想有自己的规划：</p><ul><li><input disabled="" type="checkbox"> 希望自己GitHub项目逐渐丰富🤯</li><li><input disabled="" type="checkbox"> 希望自己入门的C++到“精通”🧑‍🦲</li><li><input disabled="" type="checkbox"> 希望自己学点机器学习深度学习发个小论文😶‍🌫️</li><li><input disabled="" type="checkbox"> 希望自己找个女朋友🤗</li><li><input disabled="" type="checkbox"> 希望自己希望的都实现（🈲套娃）</li></ul><p>先这样吧，心里还有许多想说但没说的话</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Saliency】显著性评价指标</title>
      <link href="shen-du-xue-xi/507732ac59dc.html"/>
      <url>shen-du-xue-xi/507732ac59dc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果公式不正常显示可以使用Chrome浏览器或者重新刷新试试</p></blockquote><p>一般分为两种显著性目标检测（salient object detection）和眼注视点显著性（eye fixation saliency），虽然两者都能展现吸引用户注意力的物体或者区域，但是侧重点不同。<strong>物体的显著性</strong>主要在于图像中各个物体轮廓的检测，例如目标检测，语义分割等等都涉及到物体的显著性；<strong>眼注视点的显著性</strong>更多是关注用户观看的区域，和用户的观看行为有联系。由于用户在观看全景视频时，往往会关注视频中比较突出的部分，所以两者也有交集。</p><img src="https://img-blog.csdnimg.cn/20181219165952369.jpg" alt="Saliency" style="zoom:80%;"><ul><li>参考1：<a href="https://blog.csdn.net/stupidautofan/category_7507356.html">显著性目标检测</a></li><li>参考2：<a href="https://blog.csdn.net/u010736662/article/details/85099853">图像显著性检测算法的评价指标介绍</a></li></ul><h2 id="1-眼注视点显著性"><a href="#1-眼注视点显著性" class="headerlink" title="1. 眼注视点显著性"></a>1. 眼注视点显著性</h2><h3 id="Receiver-Operating-Characteristic-curve（ROC）"><a href="#Receiver-Operating-Characteristic-curve（ROC）" class="headerlink" title="Receiver Operating Characteristic curve（ROC）"></a>Receiver Operating Characteristic curve（ROC）</h3><h3 id="Area-Under-Curve（AUC）"><a href="#Area-Under-Curve（AUC）" class="headerlink" title="Area Under Curve（AUC）"></a>Area Under Curve（AUC）</h3><p>Viewport-based Saliency Prediction提到这个不太好？</p><h3 id="shuffled-AUC（sAUC）"><a href="#shuffled-AUC（sAUC）" class="headerlink" title="shuffled AUC（sAUC）"></a>shuffled AUC（sAUC）</h3><p>ROC 曲线又称受试者受试者工做特征曲线，以假正例率（False Positive Rate, FPR）为横轴，真正例率（True Positive Rate, TPR）为纵轴所组成的坐标图，以0~255不一样的阈值对预测的眼注视点显著图分类描点，从而绘制成曲线图。从直观上看，曲线越接近左上角，说明该算法检测性能越好；曲线下面积称之为AUC, AUC越大说明算法检测性能越好。因为AUC会受中心误差（center bias）的影响，研究者又提出更加鲁棒的sAUC评价指标。</p><h3 id="Pearsons-Linear-Correlation-Coefficient（CC）"><a href="#Pearsons-Linear-Correlation-Coefficient（CC）" class="headerlink" title="Pearsons Linear Correlation Coefficient（CC）"></a>Pearsons Linear Correlation Coefficient（CC）</h3><p><strong>CC$\uparrow$是指皮尔逊相关系数，也是线性相关系数，用来评价预测的眼关注点显著图和参考图ground truth之间的线性相关性，CC越大说明该模型性能越好</strong></p><p>协方差：$Cov(X,Y)=\frac{\Sigma_{i=1}^n(x_i-E(X))(y_i-E(Y))}{n}$</p><blockquote><p>感性的理解，如果数据杂乱，正负抵消，那么这个协方差就很小，就谈不上二者相关；如果数据很一致，想么协方差就负的比较多（负相关），要么就是正的比较多（正相关）</p></blockquote><p>消除x和y的量差，引用皮尔逊相关系数：$\sigma_{X,Y}=\frac{Cov(X,Y)}{\sigma_X·\sigma_Y}$</p><ul><li><p>具体对于显著性而言，P和D分别代表saliency map和fixation map，被视为随机变量</p><p>$CC(P,Q)=\frac{Cov(P,Q)}{\sigma(P)\times\sigma(Q)}$</p></li></ul><p>参考：<a href="https://blog.csdn.net/limiyudianzi/article/details/103437093">https://blog.csdn.net/limiyudianzi/article/details/103437093</a></p><h3 id="Normalized-Scanpath-Saliency（NSS）"><a href="#Normalized-Scanpath-Saliency（NSS）" class="headerlink" title="Normalized Scanpath Saliency（NSS）"></a>Normalized Scanpath Saliency（NSS）</h3><p><strong>NSS$\uparrow$是指标准化扫描路径显着性，用来评价二者之间的差别值，NSS越大说明模型性能越好；</strong></p><p>$NSS(P，Q)=\frac{1}{N}·\Sigma_i({\overline P_i}\times Q_i)$</p><p>其中P是saliency map，Q是fixation map的二值图，其中i是像素的下标，N是所有的像素值总数，<em>N is the total number of ﬁxated pixels</em>，$\overline P=\frac{P-\mu(P)}{\sigma(P)}$</p><blockquote><p>这里说明一下，一般论文中NSS指标都是5.0+左右，很显然如果我们将预测saliency map归一化在0-1之间，我们得到的NSS只能在0-1之间，因此我觉得论文中计算NSS值可能是将saliency map归一化至0-10之后再计算的</p></blockquote><h3 id="Kullback-Leibler-Divergence-（KLDiv）"><a href="#Kullback-Leibler-Divergence-（KLDiv）" class="headerlink" title="Kullback-Leibler Divergence （KLDiv）"></a>Kullback-Leibler Divergence （KLDiv）</h3><p><strong>KLDiv$\downarrow$是指KL散度，Kullback-Leibler (KL) 是一种广泛使用的信息论度量，用于衡量两个概率分布之间的差异。KLDiv越小说明该模型检测性能越好。</strong></p><p>$KL(P,Q)=\Sigma_iQ_ilog(\epsilon+\frac{Q_i}{\epsilon+P_i})$</p><p>其中$\epsilon$表示正则化常数，KL是非对称差异度量</p><p>具体再参考：<a href="https://blog.csdn.net/matrix_space/article/details/80550561">https://blog.csdn.net/matrix_space/article/details/80550561</a></p><ul><li><p>参考1：What Do Different Evaluation Metrics Tell Us About Saliency Models? IEEE TPAMI 2019</p></li><li><p>参考2：Deep Visual Attention Prediction IEEE TIP 2018</p></li></ul><h2 id="2-显著性目标检测"><a href="#2-显著性目标检测" class="headerlink" title="2. 显著性目标检测"></a>2. 显著性目标检测</h2><h3 id="Mean-Absolute-Error"><a href="#Mean-Absolute-Error" class="headerlink" title="Mean Absolute Error"></a>Mean Absolute Error</h3><p>MAE是指平均绝对值偏差，用于评价预测的显著图和参考图之间的差别，MAE越小说明该算法性能越好；</p><p>$ MAE \downarrow =\dfrac{1}{W\times H}\sum{W}<em>{x=1}\sum{H}</em>{y=1}| \overline{S}(x,y)-\overline{G}(x,y) | $</p><h3 id="PR曲线"><a href="#PR曲线" class="headerlink" title="PR曲线"></a>PR曲线</h3><p>Precise是差准率，Recall是查全率，将图像二值化之后计算：</p><p><img src="https://i.loli.net/2021/07/23/HUswzIFu9We3b7N.png" alt="TP"></p><p>$Precision=\frac{TP}{TP+FP}$ 以及 $Recall=\frac{TP}{TP+FN}$</p><p>将输出图片S进行二值化时，阈值选择为从0到255，每取一个阈值，即可对所有输出图S算得一组相对应的Precision值与Recall值。最后将所有图像在该阈值下的Precision值与Recall值分别求平均，最后将会得到256对P,R值，以Recall为横坐标，Precision为纵坐标绘制曲线图即可得到precision-recall (PR)曲线。</p><h3 id="F-measure"><a href="#F-measure" class="headerlink" title="F-measure"></a>F-measure</h3><p><strong>查全率</strong>和<strong>查准率</strong>在非负权重β下的加权调和平均值(Weighted Harmonic Mean) ，计算公式如下：</p><p>$F_\beta \uparrow =\frac{(1+\beta^2)Precision*Recall}{\beta^2Precision+Recall}$</p><p>$\beta^2$一般取值为0.3，即增加了Precision的权重值，<strong>认为查准率比查全率要重要些</strong>。因为当模型将输出图全部标为目标区域时，查全率Recall将等于100%，但是查准率Precision却很低。</p><ul><li>ROC (Receiver Operating Characteristic curve)</li><li>AUC (Area Under Curve)</li><li>MAP (Mean Average Precision)</li><li>MAR (Mean Average Recall)</li></ul><p>上述评价指标中，ROC与AUC相似于眼注视点任务，都是用不一样的阈值来肯定描点位置，而后将全部点链接起构成ROC曲线；</p><p>MAP是指平均精度率，MAR是指平均召回率，MAR和MAP越大说明算法性能越好。</p><h2 id="3-如何得到fixation-map"><a href="#3-如何得到fixation-map" class="headerlink" title="3. 如何得到fixation map"></a>3. 如何得到fixation map</h2><p>根据用户实际的注视点，统计得到（可能需要去除那些saccade场景的注视点）</p><p>可以参考：A Saliency Dataset for 360-Degree Videos</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> saliency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】背包问题</title>
      <link href="suan-fa/2de3bef2abb4.html"/>
      <url>suan-fa/2de3bef2abb4.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-起源"><a href="#0-起源" class="headerlink" title="0. 起源"></a>0. 起源</h2><h3 id="0-1背包：最大最小问题"><a href="#0-1背包：最大最小问题" class="headerlink" title="0-1背包：最大最小问题"></a><code>0-1</code>背包：最大最小问题</h3><ul><li><p><strong>概念</strong>：一共有N件物品，第<code>i</code>（i从1开始）件物品的重量为<code>w[i]</code>，价值为<code>v[i]</code>。在总重量不超过背包承载上限<code>W</code>的情况下，能够装入背包的最大价值是多少？</p></li><li><p><strong>思路</strong>：定义一个二维数组<code> dp</code> 存储最大价值，其中<code>dp[i][j]</code>表示<strong>前<code>i</code>件物品体积不超过<code> j</code> 的情况下能达到的最大价值</strong>。设第<code>i</code>件物品体积为<code> w</code>，价值为<code> v</code>，根据第<code>i</code>件物品是否添加到背包中，可以分两种情况讨论：</p><ul><li><strong>第<code>i</code>件物品没添加到背包</strong>，总体积不超过<code> j</code> 的前<code> i</code> 件物品的最大价值就是总体积不超过<code>j</code>的前<code>i-1</code>件物品的最大价值，$dp[i][j] = dp[i-1][j]$</li><li><strong>第<code>i</code>件物品添加到背包中</strong>，$dp[i][j] = dp[i-1][j-w[i]] + v[i]$</li></ul></li><li><p>状态转换方程：$dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i]) , j &gt;= w[i]$</p></li><li><p>源代码：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// w 表示背包总体积</span><span class="token comment">// weights 表示物体的重量</span><span class="token comment">// values 表示物体的价值，和 weights 一一对应</span><span class="token keyword">int</span> <span class="token function">backpack</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>weights<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>values<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> n <span class="token operator">=</span> weights<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> w<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 背包承受力足够放下第 i 个物体</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// 背包承受力不够放下第 i 个物体</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>最后：可以优化一下空间的，这里不细说了，注意第二个循环需要倒叙遍历，具体参考：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#0-1-%E8%83%8C%E5%8C%85">CyC2018</a></p></blockquote></li></ul><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><ul><li><p><strong>概念</strong>：和0-1背包问题相似，只是每个重量的物体有无数多个，也就可以重复放某个价值的物体，最终目的就是让背包的总价值最大</p></li><li><p><strong>思路</strong>：总体思想和0-1背包一样</p><ul><li><strong>第<code>i</code>件物品没添加到背包</strong>，同上，$dp[i][j] = dp[i-1][j]$</li><li><strong>第<code>i</code>件物品添加到背包中</strong>，此时和01背包不太一样，因为每种物品有无限个（但注意书包限重是有限的），所以此时不应该转移到<code>dp[i−1][j−w[i]]</code>而应该转移到<code>dp[i][j−w[i]]</code>，即装入第i种商品后还可以再继续装入第种商品。$dp[i][j] = dp[i][j-w[i]] + v[i]$</li></ul></li><li><p>状态转换方程：$dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]]+v[i]) , j &gt;= w[i]$</p></li><li><p>源代码：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// w 表示背包总体积</span><span class="token comment">// weights 表示物体的重量</span><span class="token comment">// values 表示物体的价值，和 weights 一一对应</span><span class="token keyword">int</span> <span class="token function">backpack</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>weights<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>values<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> n <span class="token operator">=</span> weights<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> w<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 背包承受力足够放下第 i 个物体</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// 背包承受力不够放下第 i 个物体</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>同理可以优化空间，好像需要注意：第二个循环正序遍历，不太懂，具体参考<a href="https://zhuanlan.zhihu.com/p/93857890?utm_source=wechat_session">完全背包-知乎</a></p></blockquote></li></ul><h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><ul><li>先不整理了，有点费脑子</li></ul><h3 id="混合背包或者多维度背包"><a href="#混合背包或者多维度背包" class="headerlink" title="混合背包或者多维度背包"></a>混合背包或者多维度背包</h3><ul><li>太难了，🤮了，具体可以参考<a href="https://github.com/tianyicui/pack/blob/master/V2.pdf">九讲背包问题</a></li></ul><h2 id="1-LeetCode实战"><a href="#1-LeetCode实战" class="headerlink" title="1. LeetCode实战"></a>1. LeetCode实战</h2><blockquote><p>参考：<a href="https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/">力扣-澜山</a></p></blockquote><h3 id="0-组合问题"><a href="#0-组合问题" class="headerlink" title="0. 组合问题"></a>0. 组合问题</h3><pre class="language-python" data-language="python"><code class="language-python">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token punctuation">]</span>  <span class="token operator">//</span> 组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> target<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span></code></pre><p><strong>377.组合总和 Ⅳ、494.目标和、518.零钱兑换 II</strong></p><ul><li><p>这里展示一下<a href="https://leetcode-cn.com/problems/combination-sum-iv/description/">377.组合总和 Ⅳ</a>，这是需要考虑每个数字之间的顺序的，所以是组合问题</p><ul><li>用 <strong>dp[x]</strong> 表示选取的元素之和等于 <strong>x</strong>的方案数，目标是求 **dp[target]**。</li><li>动态规划的边界是<strong>dp[0]=1</strong>，有当不选取任何元素时，元素之和才为 0，因此只有 1 种方案。</li><li>当$1 &lt;= i &lt;= target$，如果存在一种排列，其中的元素之和等于 i，则该排列的最后一个元素一定是数组 nums 中的一个元素，假设该排列的最后一个元素是 num，则一定有$num &lt;= i$，对于元素之和等于 <strong>i−num</strong>的每一种排列，在最后添加 <strong>num</strong>之后即可得到一个元素之和等于 <strong>i</strong> 的排列，因此在计算 <strong>dp[i]**时，应该计算所有的 **dp[i−num]</strong> 之和。</li><li>参考：<a href="https://leetcode-cn.com/problems/combination-sum-iv/solution/zu-he-zong-he-iv-by-leetcode-solution-q8zv/">力扣官方-题解</a></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">combinationSum4</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>target <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> num<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> num <span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><blockquote><p>说明一下：这里使用unsigned long long是为了防止测试数据的溢出，其实这个测试用例有点内个，<a href="https://leetcode-cn.com/problems/combination-sum-iv/solution/zu-he-zong-he-iv-by-leetcode-solution-q8zv/908055">我的疑问解答</a></p></blockquote></li></ul><h3 id="1-True、False问题公式"><a href="#1-True、False问题公式" class="headerlink" title="1. True、False问题公式"></a>1. True、False问题公式</h3><pre class="language-python" data-language="python"><code class="language-python">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">or</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token punctuation">]</span></code></pre><p><strong>139.单词拆分、416.分割等和子集</strong></p><ul><li><p>这里展示<a href="https://leetcode-cn.com/problems/word-break/">139.单词拆分</a>：<strong>dp[i]</strong> 表示 <strong>s</strong> 的前 <strong>i</strong> 位是否可以用 <strong>wordDict</strong> 中的单词表示</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">&amp;</span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 这里使用set容器是为方便查找</span>      unordered_set<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">m</span><span class="token punctuation">(</span>wordDict<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> wordDict<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment">// 这里做一个优化，每次j不需要从0开始遍历，wordDict里面有一个最小长度的串</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> s<span class="token operator">:</span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxL <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxL<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>i <span class="token operator">-</span> maxL<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> start<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> m<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> m<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ul><h3 id="2-最大最小问题"><a href="#2-最大最小问题" class="headerlink" title="2. 最大最小问题"></a>2. 最大最小问题</h3><pre class="language-python" data-language="python"><code class="language-python">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">or</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><p><strong>474.一和零、322.零钱兑换</strong></p><ul><li><p>这里展示<a href="https://leetcode-cn.com/problems/coin-change/">322.零钱兑换</a>：让找的零钱数最少</p><ul><li><p>假设 <code>f(n)</code> 代表要凑齐金额为 n 所要用的最少硬币数量，那么有：</p><p>$f(n) = min(f(n - c1), f(n - c2), … f(n - cn)) + 1$</p><p>其中 <code>c1 ~ cn</code> 为硬币的所有面额。</p></li><li><p>再具体解释一下这个公式吧，例如这个示例：</p><pre class="language-angelscript" data-language="angelscript"><code class="language-angelscript">输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1</code></pre><p>题目求的值为 <code>f(11)</code>，第一次选择硬币时我们有三种选择。</p><p>假设我们取面额为 1 的硬币，那么接下来需要凑齐的总金额变为 <code>11 - 1 = 10</code>，即 <code>f(11) = f(10) + 1</code>，这里的 <code>+1</code> 就是我们取出的面额为 1 的硬币。</p><p>同理，如果取面额为 2 或面额为 5 的硬币可以得到：</p><ul><li><code>f(11) = f(9) + 1</code></li><li><code>f(11) = f(6) + 1</code></li></ul><p>所以：</p><pre class="language-lisp" data-language="lisp"><code class="language-lisp">f<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> = min<span class="token punctuation">(</span><span class="token car">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>, f<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>, f<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span> + 1</code></pre></li><li><p>参考：<a href="https://leetcode-cn.com/problems/coin-change/comments/78252">力扣-江不知</a></p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">// 两种遍历方式都可以</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> amount<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> c<span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> c <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>c<span class="token punctuation">]</span> <span class="token operator">!=</span> INT_MAX<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>c<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">// for (int c: coins) {</span>        <span class="token comment">//     for(int j = c; j &lt;= amount; ++ j) {</span>        <span class="token comment">//         if(dp[j- c] != INT_MAX) {</span>        <span class="token comment">//             dp[j] = min(dp[j], dp[j-c] + 1);</span>        <span class="token comment">//         }</span>        <span class="token comment">//     }</span>        <span class="token comment">// }</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> INT_MAX <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ul><h2 id="2-Trick"><a href="#2-Trick" class="headerlink" title="2. Trick"></a>2. Trick</h2><blockquote><p>参考：<a href="https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/">力扣-澜山</a></p><p>不过好像不是很理解，🤒</p></blockquote><h3 id="背包问题技巧："><a href="#背包问题技巧：" class="headerlink" title="背包问题技巧："></a>背包问题技巧：</h3><ul><li><p>如果是0-1背包，即数组中的元素不可重复使用，nums放在外循环，target在内循环，且内循环倒序；</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> nums<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span></code></pre></li></ul><ul><li><p>如果是完全背包，即数组中的元素可重复使用，nums放在外循环，target在内循环。且内循环正序。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span></code></pre></li></ul><ul><li><p>如果组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> target<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【PyTorch】RNN--高级篇</title>
      <link href="shen-du-xue-xi/20548f8be3b8.html"/>
      <url>shen-du-xue-xi/20548f8be3b8.html</url>
      
        <content type="html"><![CDATA[<p><strong>来源：<a href="https://www.bilibili.com/video/BV1Y7411d7Ys?t=3&amp;p=13">https://www.bilibili.com/video/BV1Y7411d7Ys?t=3&amp;p=13</a></strong></p><h2 id="RNN-Classifier-model"><a href="#RNN-Classifier-model" class="headerlink" title="RNN_Classifier model"></a>RNN_Classifier model</h2><p><img src="/pic/model.png" alt="model"></p><h3 id="1-准备数据"><a href="#1-准备数据" class="headerlink" title="1. 准备数据"></a>1. 准备数据</h3><ol><li><p>对于每个名字需要得到一个向量</p></li><li><p>通过ASCII对于每个名字的每个字符都得到一个<code>one-hot vector</code><br><img src="/pic/data.png" alt="data"></p></li><li><p>由于输入是矩阵所以需要<code>padding</code></p></li></ol><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> Dataset<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoader<span class="token keyword">import</span> gzip<span class="token keyword">import</span> csv<span class="token keyword">class</span> <span class="token class-name">NameDataset</span><span class="token punctuation">(</span>Dataset<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> is_train_set<span class="token punctuation">)</span><span class="token punctuation">:</span>        filename <span class="token operator">=</span> <span class="token string">'./names_train.csv.gz'</span> <span class="token keyword">if</span> is_train_set <span class="token keyword">else</span> <span class="token string">'./names_test.csv.gz'</span>        <span class="token keyword">with</span> gzip<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">'rt'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token comment"># r表示只读，从文件头开始 t表示文本模式</span>            reader <span class="token operator">=</span> csv<span class="token punctuation">.</span>reader<span class="token punctuation">(</span>f<span class="token punctuation">)</span>            rows <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>names <span class="token operator">=</span> <span class="token punctuation">[</span>row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> row <span class="token keyword">in</span> rows<span class="token punctuation">]</span>        self<span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>names<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>countries <span class="token operator">=</span> <span class="token punctuation">[</span>row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> row <span class="token keyword">in</span> rows<span class="token punctuation">]</span>        self<span class="token punctuation">.</span>country_list <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">sorted</span><span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>countries<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>country_dict <span class="token operator">=</span> self<span class="token punctuation">.</span>getCountryDict<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>country_num <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>country_list<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span>       <span class="token comment"># 根据索引拿到的是 名字，国家的索引</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>names<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>country_dict<span class="token punctuation">[</span>self<span class="token punctuation">.</span>countries<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">__len__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">len</span>    <span class="token keyword">def</span> <span class="token function">getCountryDict</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        country_dict <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> idx<span class="token punctuation">,</span> country_name <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>country_list<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            country_dict<span class="token punctuation">[</span>country_name<span class="token punctuation">]</span> <span class="token operator">=</span> idx        <span class="token keyword">return</span> country_dict    <span class="token keyword">def</span> <span class="token function">idx2country</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>country_list<span class="token punctuation">[</span>index<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">getCountriesNum</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>country_numHIDDEN_SIZE <span class="token operator">=</span> <span class="token number">100</span>BATCH_SIZE <span class="token operator">=</span> <span class="token number">256</span>N_LAYER <span class="token operator">=</span> <span class="token number">2</span>N_EPOCHS <span class="token operator">=</span> <span class="token number">50</span>N_CHARS <span class="token operator">=</span> <span class="token number">128</span>   <span class="token comment"># 这个是为了构造嵌入层</span>trainSet <span class="token operator">=</span> NameDataset<span class="token punctuation">(</span>is_train_set<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>trainLoader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>trainSet<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>BATCH_SIZE<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>testSet <span class="token operator">=</span> NameDataset<span class="token punctuation">(</span>is_train_set<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>testLoader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>testSet<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>BATCH_SIZE<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>N_COUNTRY <span class="token operator">=</span> trainSet<span class="token punctuation">.</span>getCountriesNum<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="2-构建模型"><a href="#2-构建模型" class="headerlink" title="2. 构建模型"></a>2. 构建模型</h3><h4 id="GRU的维度"><a href="#GRU的维度" class="headerlink" title="GRU的维度"></a>GRU的维度</h4><ol><li>输入维度</li></ol><ul><li>𝑖𝑛𝑝𝑢𝑡: (𝑠𝑒𝑞𝐿𝑒𝑛, 𝑏𝑎𝑡𝑐ℎ𝑆𝑖𝑧𝑒, ℎ𝑖𝑑𝑑𝑒𝑛𝑆𝑖𝑧𝑒) </li><li>hidden: (nLayers * nDirections, batchSize, hiddenSize)</li></ul><ol start="2"><li>输出维度</li></ol><ul><li>output: (seqLen, batchSize, hiddenSize * nDirections)</li><li>hidden: (nLayers * nDirections, batchSize, hiddenSize)</li></ul><ol start="3"><li>示意图<br><img src="/pic/model-show.png" alt="model示意图"></li></ol><h4 id="GRU处理时可以使用pack-padded-sequence提高效率"><a href="#GRU处理时可以使用pack-padded-sequence提高效率" class="headerlink" title="GRU处理时可以使用pack_padded_sequence提高效率"></a>GRU处理时可以使用<code>pack_padded_sequence</code>提高效率</h4><p><img src="/pic/pack_padded_sequence.png" alt="pack_padded"></p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">RNNClassifier</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">,</span> output_size<span class="token punctuation">,</span> n_layers<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bidirectional<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>RNNClassifier<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>         self<span class="token punctuation">.</span>hidden_size <span class="token operator">=</span> hidden_size         self<span class="token punctuation">.</span>n_layers <span class="token operator">=</span> n_layers         self<span class="token punctuation">.</span>n_directions <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">if</span> bidirectional <span class="token keyword">else</span> <span class="token number">1</span>   <span class="token comment"># 使用双向的GRU</span>                <span class="token comment"># 嵌入层（𝑠𝑒𝑞𝐿𝑒𝑛, 𝑏𝑎𝑡𝑐ℎ𝑆𝑖𝑧𝑒） --&gt; (𝑠𝑒𝑞𝐿𝑒𝑛, 𝑏𝑎𝑡𝑐ℎ𝑆𝑖𝑧𝑒, hidden_size)</span>        self<span class="token punctuation">.</span>embedding <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Embedding<span class="token punctuation">(</span>input_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">)</span>         self<span class="token punctuation">.</span>gru <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>GRU<span class="token punctuation">(</span>hidden_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">,</span> n_layers<span class="token punctuation">,</span> bidirectional<span class="token operator">=</span>bidirectional<span class="token punctuation">)</span>         self<span class="token punctuation">.</span>fc <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>hidden_size <span class="token operator">*</span> self<span class="token punctuation">.</span>n_directions<span class="token punctuation">,</span> output_size<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_init_hidden</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>        hidden <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_layers <span class="token operator">*</span> self<span class="token punctuation">.</span>n_directions<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>         <span class="token keyword">return</span> hidden    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">,</span> seq_lengths<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># input shape : B x S -&gt; S x B</span>        <span class="token builtin">input</span> <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">.</span>t<span class="token punctuation">(</span><span class="token punctuation">)</span>         batch_size <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        hidden <span class="token operator">=</span> self<span class="token punctuation">.</span>_init_hidden<span class="token punctuation">(</span>batch_size<span class="token punctuation">)</span>         embedding <span class="token operator">=</span> self<span class="token punctuation">.</span>embedding<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span>        <span class="token comment"># pack them up</span>        gru_input <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>rnn<span class="token punctuation">.</span>pack_padded_sequence<span class="token punctuation">(</span>embedding<span class="token punctuation">,</span> seq_lengths<span class="token punctuation">)</span>        output<span class="token punctuation">,</span> hidden <span class="token operator">=</span> self<span class="token punctuation">.</span>gru<span class="token punctuation">(</span>gru_input<span class="token punctuation">,</span> hidden<span class="token punctuation">)</span>         <span class="token keyword">if</span> self<span class="token punctuation">.</span>n_directions <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>            hidden_cat <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>hidden<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> hidden<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            hidden_cat <span class="token operator">=</span> hidden<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        fc_output <span class="token operator">=</span> self<span class="token punctuation">.</span>fc<span class="token punctuation">(</span>hidden_cat<span class="token punctuation">)</span>         <span class="token keyword">return</span> fc_output    </code></pre><h3 id="3-数据转化成Tensor"><a href="#3-数据转化成Tensor" class="headerlink" title="3. 数据转化成Tensor"></a>3. 数据转化成Tensor</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">name2list</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>    arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">ord</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">for</span> c <span class="token keyword">in</span> name<span class="token punctuation">]</span>    <span class="token keyword">return</span> arr<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">make_tensors</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> countries<span class="token punctuation">)</span><span class="token punctuation">:</span>    sequences_and_lengths <span class="token operator">=</span> <span class="token punctuation">[</span>name2list<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">for</span> name <span class="token keyword">in</span> names<span class="token punctuation">]</span>    name_sequences <span class="token operator">=</span> <span class="token punctuation">[</span>s1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> s1 <span class="token keyword">in</span> sequences_and_lengths<span class="token punctuation">]</span>    seq_lengths <span class="token operator">=</span> torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">(</span><span class="token punctuation">[</span>s1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> s1 <span class="token keyword">in</span> sequences_and_lengths<span class="token punctuation">]</span><span class="token punctuation">)</span>    countries <span class="token operator">=</span> countries<span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># make tensor of name, BatchSize * seqLen</span>    <span class="token comment"># 他这里补零的方式先将所有的0 Tensor给初始化出来，然后在每行前面填充每个名字</span>    seq_tensor <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>name_sequences<span class="token punctuation">)</span><span class="token punctuation">,</span> seq_lengths<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># print("seq_lengths.max:", seq_lengths.max())</span>    <span class="token keyword">for</span> idx<span class="token punctuation">,</span> <span class="token punctuation">(</span>seq<span class="token punctuation">,</span> seq_len<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span><span class="token builtin">zip</span><span class="token punctuation">(</span>name_sequences<span class="token punctuation">,</span> seq_lengths<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        seq_tensor<span class="token punctuation">[</span>idx<span class="token punctuation">,</span> <span class="token punctuation">:</span>seq_len<span class="token punctuation">]</span> <span class="token operator">=</span> torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">(</span>seq<span class="token punctuation">)</span>    <span class="token comment"># sort by length to use pack_padded_sequence</span>    <span class="token comment"># 将名字长度降序排列，并且返回降序之后的长度在原tensor中的小标perm_idx</span>    seq_lengths<span class="token punctuation">,</span> perm_idx <span class="token operator">=</span> seq_lengths<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> descending<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment"># 这个Tensor中的类似于列表中切片的方法神奇啊，直接返回下标对应的元素，相等于排序了</span>    seq_tensor <span class="token operator">=</span> seq_tensor<span class="token punctuation">[</span>perm_idx<span class="token punctuation">]</span>    countries <span class="token operator">=</span> countries<span class="token punctuation">[</span>perm_idx<span class="token punctuation">]</span>    <span class="token comment"># 返回排序之后名字Tensor，排序之后的名字长度Tensor，排序之后的国家名字Tensor</span>    <span class="token keyword">return</span> seq_tensor<span class="token punctuation">,</span> seq_lengths<span class="token punctuation">,</span> countries</code></pre><h3 id="4-训练数据"><a href="#4-训练数据" class="headerlink" title="4. 训练数据"></a>4. 训练数据</h3><pre class="language-python" data-language="python"><code class="language-python">classifier <span class="token operator">=</span> RNNClassifier<span class="token punctuation">(</span>N_CHARS<span class="token punctuation">,</span> HIDDEN_SIZE<span class="token punctuation">,</span> N_COUNTRY<span class="token punctuation">,</span> N_LAYER<span class="token punctuation">)</span> criterion <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span> optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>classifier<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span><span class="token keyword">import</span> time<span class="token keyword">import</span> math<span class="token keyword">def</span> <span class="token function">trainModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">time_since</span><span class="token punctuation">(</span>since<span class="token punctuation">)</span><span class="token punctuation">:</span>        s <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> since        m <span class="token operator">=</span> math<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>s <span class="token operator">/</span> <span class="token number">60</span><span class="token punctuation">)</span>        s <span class="token operator">-=</span> m <span class="token operator">*</span> <span class="token number">60</span>        <span class="token keyword">return</span> <span class="token string">'%dm %ds'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>m<span class="token punctuation">,</span> s<span class="token punctuation">)</span>    total_loss <span class="token operator">=</span> <span class="token number">0</span>     <span class="token keyword">for</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span>names<span class="token punctuation">,</span> countries<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>trainLoader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># print(type(names), type(countries))</span>        <span class="token comment"># print(len(names), countries.shape)</span>        inputs<span class="token punctuation">,</span> seq_lengths<span class="token punctuation">,</span> target <span class="token operator">=</span> make_tensors<span class="token punctuation">(</span>names<span class="token punctuation">,</span> countries<span class="token punctuation">)</span>                output <span class="token operator">=</span> classifier<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> seq_lengths<span class="token punctuation">)</span>         <span class="token comment"># print("Shape:", output.shape, target.shape)</span>        <span class="token comment"># 注意输出和目标的维度：Shape: torch.Size([256, 18]) torch.Size([256])</span>        loss <span class="token operator">=</span> criterion<span class="token punctuation">(</span>output<span class="token punctuation">,</span> target<span class="token punctuation">)</span>         optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>         loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>         optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        total_loss <span class="token operator">+=</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token keyword">if</span> i <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'[</span><span class="token interpolation"><span class="token punctuation">{</span>time_since<span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">] Epoch </span><span class="token interpolation"><span class="token punctuation">{</span>epoch<span class="token punctuation">}</span></span><span class="token string"> '</span></span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'[</span><span class="token interpolation"><span class="token punctuation">{</span>i <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>inputs<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">/</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token builtin">len</span><span class="token punctuation">(</span>trainSet<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">] '</span></span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'loss=</span><span class="token interpolation"><span class="token punctuation">{</span>total_loss <span class="token operator">/</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>inputs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>     <span class="token keyword">return</span> total_loss<span class="token keyword">def</span> <span class="token function">testModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    correct <span class="token operator">=</span> <span class="token number">0</span>    total <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>testSet<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"evaluating trained model ... "</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span>names<span class="token punctuation">,</span> countries<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>testLoader<span class="token punctuation">)</span><span class="token punctuation">:</span>            inputs<span class="token punctuation">,</span> seq_lengths<span class="token punctuation">,</span> target <span class="token operator">=</span> make_tensors<span class="token punctuation">(</span>names<span class="token punctuation">,</span> countries<span class="token punctuation">)</span>            output <span class="token operator">=</span> classifier<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> seq_lengths<span class="token punctuation">)</span>            <span class="token comment"># 注意这个keepdim的使用，为了直接和target计算loss</span>            pred <span class="token operator">=</span> output<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> keepdim<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token comment"># 注意这个view_as 和 eq</span>            correct <span class="token operator">+=</span> pred<span class="token punctuation">.</span>eq<span class="token punctuation">(</span>target<span class="token punctuation">.</span>view_as<span class="token punctuation">(</span>pred<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>                percent <span class="token operator">=</span> <span class="token string">'%.2f'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">*</span> correct <span class="token operator">/</span> total<span class="token punctuation">)</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Test set: Accuracy </span><span class="token interpolation"><span class="token punctuation">{</span>correct<span class="token punctuation">}</span></span><span class="token string">/</span><span class="token interpolation"><span class="token punctuation">{</span>total<span class="token punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token punctuation">{</span>percent<span class="token punctuation">}</span></span><span class="token string">%'</span></span><span class="token punctuation">)</span>    <span class="token keyword">return</span> correct <span class="token operator">/</span> total  N_EPOCHS <span class="token operator">=</span> <span class="token number">50</span>start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Training for %d epochs..."</span> <span class="token operator">%</span> N_EPOCHS<span class="token punctuation">)</span> acc_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> N_EPOCHS <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Train cycle</span>    trainModel<span class="token punctuation">(</span><span class="token punctuation">)</span>     acc <span class="token operator">=</span> testModel<span class="token punctuation">(</span><span class="token punctuation">)</span>     acc_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>acc<span class="token punctuation">)</span></code></pre><blockquote><p>训练结果：</p><pre class="language-none"><code class="language-none">Training for 50 epochs...[0m 2s] Epoch 1 [2560/13374] loss=0.00895661092363298[0m 4s] Epoch 1 [5120/13374] loss=0.007739758561365306[0m 6s] Epoch 1 [7680/13374] loss=0.0069853457777450485[0m 8s] Epoch 1 [10240/13374] loss=0.006530495395418256[0m 11s] Epoch 1 [12800/13374] loss=0.006135637713596225evaluating trained model ... Test set: Accuracy 4535/6700 67.69%[0m 15s] Epoch 2 [2560/13374] loss=0.004228085093200207[0m 17s] Epoch 2 [5120/13374] loss=0.0041014277492649855[0m 19s] Epoch 2 [7680/13374] loss=0.004011582878107826[0m 22s] Epoch 2 [10240/13374] loss=0.0038964587613008915[0m 24s] Epoch 2 [12800/13374] loss=0.0038181920163333416evaluating trained model ... ......（中间省略若干）[12m 46s] Epoch 49 [2560/13374] loss=0.00016357196727767587[12m 49s] Epoch 49 [5120/13374] loss=0.0001682748734310735[12m 51s] Epoch 49 [7680/13374] loss=0.00017566338913942067[12m 54s] Epoch 49 [10240/13374] loss=0.0001776946208337904[12m 57s] Epoch 49 [12800/13374] loss=0.00018831568930181676evaluating trained model ... Test set: Accuracy 5627/6700 83.99%[13m 2s] Epoch 50 [2560/13374] loss=0.00016892087151063607[13m 5s] Epoch 50 [5120/13374] loss=0.00015529338124906645[13m 7s] Epoch 50 [7680/13374] loss=0.00017500294488854707[13m 11s] Epoch 50 [10240/13374] loss=0.00017692927776806754[13m 14s] Epoch 50 [12800/13374] loss=0.00018558732335804962evaluating trained model ... Test set: Accuracy 5613/6700 83.78%</code></pre></blockquote><h3 id="5-可视化"><a href="#5-可视化" class="headerlink" title="5. 可视化"></a>5. 可视化</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npepoch <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>acc_list<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>acc_list <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>acc_list<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>epoch<span class="token punctuation">,</span> acc_list<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Epoch'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Accuracy'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>grid<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="/pic/EPOCH_ACC.png" alt="EPOCH_ACC"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【PyTorch】RNN</title>
      <link href="shen-du-xue-xi/791cc4c6eb51.html"/>
      <url>shen-du-xue-xi/791cc4c6eb51.html</url>
      
        <content type="html"><![CDATA[<h1 id="Pytorch-for-RNN"><a href="#Pytorch-for-RNN" class="headerlink" title="Pytorch for RNN"></a>Pytorch for RNN</h1><p>来源：<a href="https://www.bilibili.com/video/BV1Y7411d7Ys?p=12">https://www.bilibili.com/video/BV1Y7411d7Ys?p=12</a></p><h2 id="How-to-use-RNNCell"><a href="#How-to-use-RNNCell" class="headerlink" title="How to use RNNCell"></a>How to use RNNCell</h2><h3 id="注意几个参数"><a href="#注意几个参数" class="headerlink" title="注意几个参数"></a>注意几个参数</h3><ol><li><p>输入和隐层（输出）维度</p></li><li><p>序列长度</p></li><li><p>批处理大小</p></li></ol><ul><li><strong>注 调用RNNCell这个需要循环，循环长度就是序列长度</strong></li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchbatch_size <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment"># 批处理大小</span>seq_len <span class="token operator">=</span> <span class="token number">3</span>     <span class="token comment"># 序列长度</span>input_size <span class="token operator">=</span> <span class="token number">4</span>  <span class="token comment"># 输入维度</span>hidden_size <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment"># 隐层维度</span>cell <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>RNNCell<span class="token punctuation">(</span>input_size<span class="token operator">=</span>input_size<span class="token punctuation">,</span> hidden_size<span class="token operator">=</span>hidden_size<span class="token punctuation">)</span><span class="token comment"># (seq, batch, features)</span>dataset <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>seq_len<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> input_size<span class="token punctuation">)</span>hidden <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">)</span><span class="token comment"># 这个循环就是处理seq_len长度的数据</span><span class="token keyword">for</span> idx<span class="token punctuation">,</span> data <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>dataset<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'='</span> <span class="token operator">*</span> <span class="token number">20</span><span class="token punctuation">,</span> idx<span class="token punctuation">,</span> <span class="token string">'='</span> <span class="token operator">*</span> <span class="token number">20</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Input size:'</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> data<span class="token punctuation">)</span>    hidden <span class="token operator">=</span> cell<span class="token punctuation">(</span>data<span class="token punctuation">,</span> hidden<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hidden size:'</span><span class="token punctuation">,</span> hidden<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> hidden<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>hidden<span class="token punctuation">)</span></code></pre><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>Input size: torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">1.9129</span>, -0.7440,  <span class="token number">0.2329</span>,  <span class="token number">1.3065</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>hidden size: torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>-0.0790, -0.8957<span class="token punctuation">]</span><span class="token punctuation">]</span>, <span class="token assign-left variable">grad_fn</span><span class="token operator">=</span><span class="token operator">&lt;</span>TanhBackward<span class="token operator">&gt;</span><span class="token punctuation">)</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>-0.0790, -0.8957<span class="token punctuation">]</span><span class="token punctuation">]</span>, <span class="token assign-left variable">grad_fn</span><span class="token operator">=</span><span class="token operator">&lt;</span>TanhBackward<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>Input size: torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>-0.6290, -0.2338, -0.2949,  <span class="token number">0.3956</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>hidden size: torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0.0170</span>, -0.0005<span class="token punctuation">]</span><span class="token punctuation">]</span>, <span class="token assign-left variable">grad_fn</span><span class="token operator">=</span><span class="token operator">&lt;</span>TanhBackward<span class="token operator">&gt;</span><span class="token punctuation">)</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0.0170</span>, -0.0005<span class="token punctuation">]</span><span class="token punctuation">]</span>, <span class="token assign-left variable">grad_fn</span><span class="token operator">=</span><span class="token operator">&lt;</span>TanhBackward<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>Input size: torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>-0.6959,  <span class="token number">1.0590</span>, -0.6798,  <span class="token number">0.6989</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>hidden size: torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0.4216</span>, <span class="token number">0.6813</span><span class="token punctuation">]</span><span class="token punctuation">]</span>, <span class="token assign-left variable">grad_fn</span><span class="token operator">=</span><span class="token operator">&lt;</span>TanhBackward<span class="token operator">&gt;</span><span class="token punctuation">)</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0.4216</span>, <span class="token number">0.6813</span><span class="token punctuation">]</span><span class="token punctuation">]</span>, <span class="token assign-left variable">grad_fn</span><span class="token operator">=</span><span class="token operator">&lt;</span>TanhBackward<span class="token operator">&gt;</span><span class="token punctuation">)</span></code></pre><h2 id="How-to-use-RNN"><a href="#How-to-use-RNN" class="headerlink" title="How to use RNN"></a>How to use RNN</h2><h3 id="确定几个参数"><a href="#确定几个参数" class="headerlink" title="确定几个参数"></a>确定几个参数</h3><ol><li>input_size和hidden_size: 输入维度和隐层维度</li><li>batch_size: 批处理大小</li><li>seq_len: 序列长度</li><li>num_layers: 隐层数目</li></ol><ul><li><strong>注 直接调用RNN这个不用循环</strong></li><li><strong>注：如果使用batch_first: if True, the input and output tensors are provided as:(batch_size, seq_len, input_size)</strong></li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchbatch_size <span class="token operator">=</span> <span class="token number">1</span>seq_len <span class="token operator">=</span> <span class="token number">3</span>input_size <span class="token operator">=</span> <span class="token number">4</span>hidden_size <span class="token operator">=</span> <span class="token number">2</span>num_layers <span class="token operator">=</span> <span class="token number">1</span>cell <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>RNN<span class="token punctuation">(</span>input_size<span class="token operator">=</span>input_size<span class="token punctuation">,</span> hidden_size<span class="token operator">=</span>hidden_size<span class="token punctuation">,</span> num_layers<span class="token operator">=</span>num_layers<span class="token punctuation">)</span><span class="token comment"># (seqLen, batchSize, inputSize)</span>inputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>seq_len<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> input_size<span class="token punctuation">)</span>hidden <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>num_layers<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">)</span>out<span class="token punctuation">,</span> hidden <span class="token operator">=</span> cell<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> hidden<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Output size:'</span><span class="token punctuation">,</span> out<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>        <span class="token comment"># (seq_len, batch_size, hidden_size)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Output:'</span><span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Hidden size:'</span><span class="token punctuation">,</span> hidden<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>     <span class="token comment"># (num_layers, batch_size, hidden_size)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Hidden:'</span><span class="token punctuation">,</span> hidden<span class="token punctuation">)</span></code></pre><h3 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h3><pre class="language-bash" data-language="bash"><code class="language-bash">Output size: torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span>, <span class="token number">1</span>, <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Output: tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0.3689</span>,  <span class="token number">0.5982</span><span class="token punctuation">]</span><span class="token punctuation">]</span>,        <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0.1233</span>,  <span class="token number">0.2617</span><span class="token punctuation">]</span><span class="token punctuation">]</span>,        <span class="token punctuation">[</span><span class="token punctuation">[</span>-0.3517, -0.7246<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>, <span class="token assign-left variable">grad_fn</span><span class="token operator">=</span><span class="token operator">&lt;</span>StackBackward<span class="token operator">&gt;</span><span class="token punctuation">)</span>Hidden size: torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">1</span>, <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Hidden: tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span>-0.3517, -0.7246<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>, <span class="token assign-left variable">grad_fn</span><span class="token operator">=</span><span class="token operator">&lt;</span>StackBackward<span class="token operator">&gt;</span><span class="token punctuation">)</span></code></pre><h2 id="Example-Using-RNNCell"><a href="#Example-Using-RNNCell" class="headerlink" title="Example: Using RNNCell"></a>Example: Using RNNCell</h2><h3 id="Hello-–-gt-ohlol"><a href="#Hello-–-gt-ohlol" class="headerlink" title="Hello –> ohlol"></a>Hello –&gt; ohlol</h3><ol><li>首先需要将输入的单词转成向量<code>one-hot vector</code></li><li>注意input_size，如下图</li></ol><p><img src="/pic/RNN_example.png" alt="转化成向量"></p><h3 id="注意交叉熵在计算loss的时候维度关系"><a href="#注意交叉熵在计算loss的时候维度关系" class="headerlink" title="注意交叉熵在计算loss的时候维度关系"></a>注意交叉熵在计算loss的时候维度关系</h3><p><strong>这里的hidden是<code>([1, 4])</code>, label是 <code>([1])</code></strong></p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchinput_size <span class="token operator">=</span> <span class="token number">4</span>hidden_size <span class="token operator">=</span> <span class="token number">4</span>batch_size <span class="token operator">=</span> <span class="token number">1</span>idx2char <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">]</span>x_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>    <span class="token comment"># hello中各个字符的下标</span>y_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>    <span class="token comment"># ohlol中各个字符的下标</span>one_hot_lookup <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>x_one_hot <span class="token operator">=</span> <span class="token punctuation">[</span>one_hot_lookup<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> x_data<span class="token punctuation">]</span> <span class="token comment"># (seqLen, inputSize)</span>inputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span>x_one_hot<span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> input_size<span class="token punctuation">)</span>labels <span class="token operator">=</span> torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">(</span>y_data<span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment"># torch.Tensor默认是torch.FloatTensor是32位浮点类型数据，torch.LongTensor是64位整型</span><span class="token keyword">print</span><span class="token punctuation">(</span>inputs<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> labels<span class="token punctuation">.</span>shape<span class="token punctuation">)</span></code></pre><blockquote><p>输出结果：</p><pre class="language-bash" data-language="bash"><code class="language-bash">torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span>, <span class="token number">1</span>, <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span>, <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></blockquote><h4 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h4><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">class</span> <span class="token class-name">Model</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>Model<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>batch_size <span class="token operator">=</span> batch_size        self<span class="token punctuation">.</span>input_size <span class="token operator">=</span> input_size        self<span class="token punctuation">.</span>hidden_size <span class="token operator">=</span> hidden_size        self<span class="token punctuation">.</span>rnncell <span class="token operator">=</span> nn<span class="token punctuation">.</span>RNNCell<span class="token punctuation">(</span>input_size<span class="token operator">=</span>self<span class="token punctuation">.</span>input_size<span class="token punctuation">,</span> hidden_size<span class="token operator">=</span>self<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> hidden<span class="token punctuation">)</span><span class="token punctuation">:</span>        hidden <span class="token operator">=</span> self<span class="token punctuation">.</span>rnncell<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> hidden<span class="token punctuation">)</span>   <span class="token comment"># (batch_size, hidden_size)</span>        <span class="token keyword">return</span> hidden    <span class="token keyword">def</span> <span class="token function">init_hidden</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>self<span class="token punctuation">.</span>batch_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>net <span class="token operator">=</span> Model<span class="token punctuation">(</span>input_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span>criterion <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span></code></pre><h4 id="训练数据"><a href="#训练数据" class="headerlink" title="训练数据"></a>训练数据</h4><pre class="language-python" data-language="python"><code class="language-python">epochs <span class="token operator">=</span> <span class="token number">15</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>    loss <span class="token operator">=</span> <span class="token number">0</span>    optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    hidden <span class="token operator">=</span> net<span class="token punctuation">.</span>init_hidden<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Predicted string:'</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token builtin">input</span><span class="token punctuation">,</span> label <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">:</span>        hidden <span class="token operator">=</span> net<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">,</span> hidden<span class="token punctuation">)</span>        <span class="token comment"># 注意交叉熵在计算loss的时候维度关系，这里的hidden是([1, 4]), label是 ([1])</span>        loss <span class="token operator">+=</span> criterion<span class="token punctuation">(</span>hidden<span class="token punctuation">,</span> label<span class="token punctuation">)</span>        _<span class="token punctuation">,</span> idx <span class="token operator">=</span> hidden<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>dim <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>idx2char<span class="token punctuation">[</span>idx<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>    loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">', Epoch [%d/15] loss=%.4f'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>epoch<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><blockquote><p>输出结果：</p><pre class="language-bash" data-language="bash"><code class="language-bash">Predicted string:lhlhh, Epoch <span class="token punctuation">[</span><span class="token number">1</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">6.8407</span>Predicted string:lllll, Epoch <span class="token punctuation">[</span><span class="token number">2</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">5.2957</span>Predicted string:lllol, Epoch <span class="token punctuation">[</span><span class="token number">3</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">4.9344</span>Predicted string:lllol, Epoch <span class="token punctuation">[</span><span class="token number">4</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">4.7035</span>Predicted string:oolol, Epoch <span class="token punctuation">[</span><span class="token number">5</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">4.4781</span>Predicted string:oolol, Epoch <span class="token punctuation">[</span><span class="token number">6</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">4.2419</span>Predicted string:ohlol, Epoch <span class="token punctuation">[</span><span class="token number">7</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">3.9733</span>Predicted string:ohlol, Epoch <span class="token punctuation">[</span><span class="token number">8</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">3.6942</span>Predicted string:ohlol, Epoch <span class="token punctuation">[</span><span class="token number">9</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">3.4917</span>Predicted string:ohloo, Epoch <span class="token punctuation">[</span><span class="token number">10</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">3.3837</span>Predicted string:ohloo, Epoch <span class="token punctuation">[</span><span class="token number">11</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">3.2953</span>Predicted string:ohlol, Epoch <span class="token punctuation">[</span><span class="token number">12</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">3.1331</span>Predicted string:ohlol, Epoch <span class="token punctuation">[</span><span class="token number">13</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">2.9294</span>Predicted string:ohlol, Epoch <span class="token punctuation">[</span><span class="token number">14</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">2.7344</span>Predicted string:ohlol, Epoch <span class="token punctuation">[</span><span class="token number">15</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">2.5680</span></code></pre></blockquote><h2 id="Example-Using-RNN"><a href="#Example-Using-RNN" class="headerlink" title="Example: Using RNN"></a>Example: Using RNN</h2><h3 id="注意inputs和labels的维度"><a href="#注意inputs和labels的维度" class="headerlink" title="注意inputs和labels的维度"></a>注意<code>inputs</code>和<code>labels</code>的维度</h3><ul><li><code>inputs</code>维度是: (seqLen, batch_size, input_size)</li><li><code>labels</code>维度是: (seqLen * batch_size)</li></ul><h3 id="注意outputs维度，对应和labels做交叉熵的维度"><a href="#注意outputs维度，对应和labels做交叉熵的维度" class="headerlink" title="注意outputs维度，对应和labels做交叉熵的维度"></a>注意<code>outputs</code>维度，对应和<code>labels</code>做交叉熵的维度</h3><ul><li><code>outputs</code>维度是: (seqLen, batch_size, hidden_size)</li><li>为了能和labels做交叉熵，需要reshape一下: outputs.view(-1, hidden_size)</li></ul><h3 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h3><h4 id="数据准备-1"><a href="#数据准备-1" class="headerlink" title="数据准备"></a>数据准备</h4><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchinput_size <span class="token operator">=</span> <span class="token number">4</span>hidden_size <span class="token operator">=</span> <span class="token number">4</span>batch_size <span class="token operator">=</span> <span class="token number">1</span>seq_len <span class="token operator">=</span> <span class="token number">5</span>num_layers <span class="token operator">=</span> <span class="token number">1</span>idx2char <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">]</span>x_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>    <span class="token comment"># hello中各个字符的下标</span>y_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>    <span class="token comment"># ohlol中各个字符的下标</span>one_hot_lookup <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>x_one_hot <span class="token operator">=</span> <span class="token punctuation">[</span>one_hot_lookup<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> x_data<span class="token punctuation">]</span> <span class="token comment"># (seqLen, inputSize)</span>inputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span>x_one_hot<span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span>seq_len<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> input_size<span class="token punctuation">)</span>labels <span class="token operator">=</span> torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">(</span>y_data<span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>inputs<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> labels<span class="token punctuation">.</span>shape<span class="token punctuation">)</span></code></pre><blockquote><p>输出结果：</p><pre class="language-bash" data-language="bash"><code class="language-bash">torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span>, <span class="token number">1</span>, <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></blockquote><h4 id="构建模型-1"><a href="#构建模型-1" class="headerlink" title="构建模型"></a>构建模型</h4><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">class</span> <span class="token class-name">Model</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> num_layers<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>Model<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>num_layers <span class="token operator">=</span> num_layers        self<span class="token punctuation">.</span>batch_size <span class="token operator">=</span> batch_size        self<span class="token punctuation">.</span>input_size <span class="token operator">=</span> input_size        self<span class="token punctuation">.</span>hidden_size <span class="token operator">=</span> hidden_size        self<span class="token punctuation">.</span>rnn <span class="token operator">=</span> nn<span class="token punctuation">.</span>RNN<span class="token punctuation">(</span>input_size<span class="token operator">=</span>self<span class="token punctuation">.</span>input_size<span class="token punctuation">,</span> hidden_size<span class="token operator">=</span>self<span class="token punctuation">.</span>hidden_size<span class="token punctuation">,</span> <span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">)</span><span class="token punctuation">:</span>        hidden <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>self<span class="token punctuation">.</span>num_layers<span class="token punctuation">,</span> self<span class="token punctuation">.</span>batch_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>        out<span class="token punctuation">,</span> _ <span class="token operator">=</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> hidden<span class="token punctuation">)</span>    <span class="token comment"># 注意维度是(seqLen, batch_size, hidden_size)</span>        <span class="token keyword">return</span> out<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span> <span class="token comment"># 为了容易计算交叉熵这里调整维度为(seqLen * batch_size, hidden_size)</span>net <span class="token operator">=</span> Model<span class="token punctuation">(</span>input_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span>criterion <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span></code></pre><h4 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h4><pre class="language-python" data-language="python"><code class="language-python">epochs <span class="token operator">=</span> <span class="token number">15</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>    optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>     <span class="token comment"># print(outputs.shape, labels.shape)</span>    <span class="token comment"># 这里的outputs维度是([seqLen * batch_size, hidden]), labels维度是([seqLen])</span>    loss <span class="token operator">=</span> criterion<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> labels<span class="token punctuation">)</span>     loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>     optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    _<span class="token punctuation">,</span> idx <span class="token operator">=</span> outputs<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>     idx <span class="token operator">=</span> idx<span class="token punctuation">.</span>data<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Predicted: '</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>idx2char<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">', Epoch [%d/15] loss = %.3f'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><blockquote><p>输出结果：</p><pre class="language-bash" data-language="bash"><code class="language-bash">Predicted:  ololl, Epoch <span class="token punctuation">[</span><span class="token number">1</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">1.189</span>Predicted:  ollll, Epoch <span class="token punctuation">[</span><span class="token number">2</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">1.070</span>Predicted:  ollll, Epoch <span class="token punctuation">[</span><span class="token number">3</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.976</span>Predicted:  ohlll, Epoch <span class="token punctuation">[</span><span class="token number">4</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.883</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">5</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.788</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">6</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.715</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">7</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.652</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">8</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.603</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">9</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.570</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">10</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.548</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">11</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.530</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">12</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.511</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">13</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.488</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">14</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.462</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">15</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.439</span></code></pre></blockquote><h2 id="将一个单词变成vector"><a href="#将一个单词变成vector" class="headerlink" title="将一个单词变成vector"></a>将一个单词变成vector</h2><h3 id="One-hot-encoding-of-words-and-characters"><a href="#One-hot-encoding-of-words-and-characters" class="headerlink" title="One-hot encoding of words and characters"></a>One-hot encoding of words and characters</h3><ul><li><p><strong>one-hot vectors high-dimension –&gt; lower-dimension</strong></p></li><li><p><strong>one-hot vectors sparse –&gt; dense</strong></p></li><li><p><strong>one-hot vectors hardcoded  –&gt; learn from data</strong></p></li></ul><h3 id="Embedding"><a href="#Embedding" class="headerlink" title="Embedding"></a>Embedding</h3><p><img src="/pic/ont_hot_VS_embedding.png" alt="ont_hot_vector VS embedding"></p><p><img src="/pic/embedding.png" alt="embedding"></p><h3 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h3><h4 id="构建模型-2"><a href="#构建模型-2" class="headerlink" title="构建模型"></a>构建模型</h4><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token comment"># parameters</span>num_class <span class="token operator">=</span> <span class="token number">4</span> input_size <span class="token operator">=</span> <span class="token number">4</span> hidden_size <span class="token operator">=</span> <span class="token number">8</span> embedding_size <span class="token operator">=</span> <span class="token number">10</span> num_layers <span class="token operator">=</span> <span class="token number">2</span> batch_size <span class="token operator">=</span> <span class="token number">1</span> seq_len <span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">class</span> <span class="token class-name">Model</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>Model<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>emb <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Embedding<span class="token punctuation">(</span>input_size<span class="token punctuation">,</span> embedding_size<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>rnn <span class="token operator">=</span> nn<span class="token punctuation">.</span>RNN<span class="token punctuation">(</span>input_size<span class="token operator">=</span>embedding_size<span class="token punctuation">,</span> hidden_size<span class="token operator">=</span>hidden_size<span class="token punctuation">,</span> num_layers<span class="token operator">=</span>num_layers<span class="token punctuation">,</span> batch_first<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>hidden_size<span class="token punctuation">,</span> num_class<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        hidden <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>num_layers<span class="token punctuation">,</span> x<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hidden_size<span class="token punctuation">)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>emb<span class="token punctuation">(</span>x<span class="token punctuation">)</span>                 <span class="token comment"># (batch, seqLen, embeddingSize) </span>        x<span class="token punctuation">,</span> _ <span class="token operator">=</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">(</span>x<span class="token punctuation">,</span> hidden<span class="token punctuation">)</span>      <span class="token comment"># 输出(𝒃𝒂𝒕𝒄𝒉𝑺𝒊𝒛𝒆, 𝒔𝒆𝒒𝑳𝒆𝒏, hidden_size)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>fc<span class="token punctuation">(</span>x<span class="token punctuation">)</span>                  <span class="token comment"># 输出(𝒃𝒂𝒕𝒄𝒉𝑺𝒊𝒛𝒆, 𝒔𝒆𝒒𝑳𝒆𝒏, 𝒏𝒖𝒎𝑪𝒍𝒂𝒔𝒔)</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> num_class<span class="token punctuation">)</span>    <span class="token comment"># reshape to use Cross Entropy: (𝒃𝒂𝒕𝒄𝒉𝑺𝒊𝒛𝒆×𝒔𝒆𝒒𝑳𝒆𝒏, 𝒏𝒖𝒎𝑪𝒍𝒂𝒔𝒔)</span>        net <span class="token operator">=</span> Model<span class="token punctuation">(</span><span class="token punctuation">)</span>criterion <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.05</span><span class="token punctuation">)</span></code></pre><h4 id="准备数据并训练"><a href="#准备数据并训练" class="headerlink" title="准备数据并训练"></a>准备数据并训练</h4><pre class="language-python" data-language="python"><code class="language-python">idx2char <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">]</span> x_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># (batch, seq_len) </span>y_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>    <span class="token comment"># (batch * seq_len)</span>inputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">(</span>x_data<span class="token punctuation">)</span>   <span class="token comment"># Input should be LongTensor: (batchSize, seqLen)</span>labels <span class="token operator">=</span> torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">(</span>y_data<span class="token punctuation">)</span>   <span class="token comment"># Target should be LongTensor: (batchSize * seqLen)</span>epochs <span class="token operator">=</span> <span class="token number">15</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>    optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>     loss <span class="token operator">=</span> criterion<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> labels<span class="token punctuation">)</span>     loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>     optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    _<span class="token punctuation">,</span> idx <span class="token operator">=</span> outputs<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>     idx <span class="token operator">=</span> idx<span class="token punctuation">.</span>data<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Predicted: '</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>idx2char<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">', Epoch [%d/15] loss = %.3f'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><blockquote><p>输出结果：</p><pre class="language-bash" data-language="bash"><code class="language-bash">Predicted:  ollll, Epoch <span class="token punctuation">[</span><span class="token number">1</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">1.290</span>Predicted:  olooo, Epoch <span class="token punctuation">[</span><span class="token number">2</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">1.071</span>Predicted:  ollol, Epoch <span class="token punctuation">[</span><span class="token number">3</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.913</span>Predicted:  ollol, Epoch <span class="token punctuation">[</span><span class="token number">4</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.785</span>Predicted:  ollol, Epoch <span class="token punctuation">[</span><span class="token number">5</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.660</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">6</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.541</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">7</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.435</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">8</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.343</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">9</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.251</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">10</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.171</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">11</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.121</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">12</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.081</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">13</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.052</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">14</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.036</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">15</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.025</span></code></pre></blockquote><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>可以看到使用embedding之后收敛的更快了，说明模型的学习能力变强了</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】并查集深入浅出，一文吃透！</title>
      <link href="suan-fa/47fefd104e9e.html"/>
      <url>suan-fa/47fefd104e9e.html</url>
      
        <content type="html"><![CDATA[<h2 id="【LeetCode】并查集"><a href="#【LeetCode】并查集" class="headerlink" title="【LeetCode】并查集"></a>【LeetCode】并查集</h2><blockquote><p>原文同步在：<a href="https://github.com/EricPengShuai/Interview/blob/main/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86.md">https://github.com/EricPengShuai/Interview/blob/main/algorithm/并查集.md</a></p></blockquote><h3 id="0-概念"><a href="#0-概念" class="headerlink" title="0. 概念"></a>0. 概念</h3><p>并查集主要用于解决一些 <strong>元素分组</strong> 问题，通过以下操作管理一系列不相交的集合：</p><ul><li>合并（Union）：把两个不相交的集合合并成一个集合</li><li>查询（Find）：查询两个元素是否在同一个集合中</li></ul><p>具体实现方面，使用一个数组 <code>parent</code> 存储每个变量的 <strong>父节点信息（每个节点的连通分量信息）</strong>，其中的每个元素表示当前变量所在的连通分量的父节点信息，如果父节点是自身，说明该变量为所在连通分量的根节点。初始化时所有变量的父节点都是它们自身。</p><ol><li><p>初始化：将每个节点的父节点指向自己。表示每个每个节点最开始都是自己一个集合，也就是节点的父节点都是自己</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">parent</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">iota</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> parent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><ol start="2"><li><p>查找时，沿着当前分量的父节点一路向上查找，直到找到根节点，这个过程也叫 <strong>路径压缩</strong>，具体来说有两种方法</p><ul><li><strong>隔代压缩</strong>：性能比较高，虽然压缩不完全，不过多次执行隔代压缩也能达到完全压缩的效果，这个方法也叫迭代查找</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        x <span class="token operator">=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><strong>完全压缩</strong>：需要借助系统栈，使用递归的写法。或者先找到当前节点的根节点，然后把沿途上所有的节点都指向根节点，得遍历两次，这个方法也叫递归查找</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><ol start="3"><li><p>合并时，将属于同一类的节点合并到一个树中，设计 <code>union(x, y)</code> 将 x 的根节点指向 y 的根节点</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 最好不要申明为 union，这是一个关键字</span><span class="token keyword">void</span> <span class="token function">Union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    parent<span class="token punctuation">[</span><span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在合并时还可以 <strong>按秩合并</strong>，秩没有明确的定义，一般可以指以节点为根节点的子树的深度，也可以表示以根节点的子树的节点个数，考虑按秩合并之后可以让查找的效率更高</p><ul><li><p>以秩比较大的节点为根合并：最大深度没有增加</p><img src="https://img-blog.csdnimg.cn/img_convert/c8a1efe9b35e7d432f8a11df4cb9a82c.png#pic_center" style="zoom:30%;" align="left"></li><li><p>以秩比较小的节点为根合并：最大深度有增加</p><img src="https://img-blog.csdnimg.cn/img_convert/e6708ec5ce7c00dbbcd9989104add532.png#pic_center" style="zoom:30%;" align="left"></li></ul></li></ol><h3 id="1-模板"><a href="#1-模板" class="headerlink" title="1. 模板"></a>1. 模板</h3><h4 id="1-1-维护深度——秩"><a href="#1-1-维护深度——秩" class="headerlink" title="1.1 维护深度——秩"></a>1.1 维护深度——秩</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> parent<span class="token punctuation">;</span>    vecotr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> rank<span class="token punctuation">;</span><span class="token comment">// 维护以节点为根节点的子树的深度——秩</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        parent<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">iota</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> parent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                rank <span class="token operator">=</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">// 隔代压缩，迭代查找</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            x <span class="token operator">=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">// 按秩合并</span>    <span class="token keyword">void</span> <span class="token function">Union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x_root <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> y_root <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x_root <span class="token operator">==</span> y_root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment">// 如果已经处于一个集合了直接返回</span>                <span class="token comment">// 注意这里只要最大的深度不变就不需要修改根节点的秩</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>x_root<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>y_root<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 以深度大的节点为根</span>            parent<span class="token punctuation">[</span>x_root<span class="token punctuation">]</span> <span class="token operator">=</span> y_root<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>x_root<span class="token punctuation">]</span> <span class="token operator">&gt;</span> rank<span class="token punctuation">[</span>y_root<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>y_root<span class="token punctuation">]</span> <span class="token operator">=</span> x_root<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// 深度一样，谁作为根节点都可以</span>         parent<span class="token punctuation">[</span>y_root<span class="token punctuation">]</span> <span class="token operator">=</span> x_root<span class="token punctuation">;</span>            rank<span class="token punctuation">[</span>x_root<span class="token punctuation">]</span> <span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 作为根节点的高度会+1</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="1-2-维护连通分量个数"><a href="#1-2-维护连通分量个数" class="headerlink" title="1.2 维护连通分量个数"></a>1.2 维护连通分量个数</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> parent<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> size<span class="token punctuation">;</span><span class="token comment">// 当前节点为根节点的子树节点总数</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token comment">// 连通分量个数</span>   <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        count <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token comment">// 初始是每个节点都是一个连通分量</span>        parent<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">iota</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> parent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">iota</span><span class="token punctuation">(</span>size<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">// 完全压缩，递归查找</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">// 按照连通分量个数合并</span>    <span class="token keyword">void</span> <span class="token function">Union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x_root <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> y_root <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x_root <span class="token operator">==</span> y_root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment">// 如果已经处于一个集合了直接返回</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>size<span class="token punctuation">[</span>x_root<span class="token punctuation">]</span> <span class="token operator">&gt;</span> size<span class="token punctuation">[</span>y_root<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 节点少分量合并到节点多的分量上</span>            parent<span class="token punctuation">[</span>y_root<span class="token punctuation">]</span> <span class="token operator">=</span> x_root<span class="token punctuation">;</span>            size<span class="token punctuation">[</span>x_root<span class="token punctuation">]</span> <span class="token operator">+=</span> size<span class="token punctuation">[</span>y_root<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>x_root<span class="token punctuation">]</span> <span class="token operator">=</span> y_root<span class="token punctuation">;</span>            size<span class="token punctuation">[</span>y_root<span class="token punctuation">]</span> <span class="token operator">+=</span> size<span class="token punctuation">[</span>x_root<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token operator">--</span> count<span class="token punctuation">;</span> <span class="token comment">// 合并时候连通分量个数减1</span>    <span class="token punctuation">}</span>        <span class="token keyword">int</span> <span class="token function">getSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> root <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> size<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>初始不知道节点个数的写法：维护哈希表</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> parent<span class="token punctuation">;</span>    <span class="token comment">// 连通分量个数</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">==</span> parent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> index<span class="token punctuation">;</span>            <span class="token comment">// 这里最初不知道节点个数需要在哈希表加入元素时候初始化</span>            count <span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">!=</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">Union</span><span class="token punctuation">(</span><span class="token keyword">int</span> index1<span class="token punctuation">,</span> <span class="token keyword">int</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> parent1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>index1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> parent2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>index2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// *这步骤很重要，直接把两节点首领一样的结果返回过滤，否则会让count多减1*</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent1 <span class="token operator">==</span> parent2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        parent<span class="token punctuation">[</span>parent1<span class="token punctuation">]</span> <span class="token operator">=</span> parent2<span class="token punctuation">;</span>        count <span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 也是合并时候连通分量减1</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h3><p><strong>基础</strong></p><table><thead><tr><th>题目</th><th>说明</th><th>答案</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/satisfiability-of-equality-equations/">990. 等式方程的可满足性</a></td><td>先将==全部合并，其次找出!=的根节点，如果一样则不行</td><td><a href="https://leetcode.cn/submissions/detail/136424817/">通过</a></td></tr><tr><td><a href="https://leetcode.cn/problems/number-of-provinces/">547. 省份数量</a></td><td>简单的并查集，维护连通分量个数，也可以 DFS 和 BFS</td><td><a href="https://leetcode.cn/submissions/detail/375522024/">通过</a></td></tr></tbody></table><p><strong>进阶</strong></p><table><thead><tr><th>题目</th><th>说明</th><th>答案</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/regions-cut-by-slashes/">959. 由斜杠划分区域</a></td><td>重点在将斜杠怎样拆分成单元格，外部添加成3*3（还可以DFS），内部分解成4*4</td><td><a href="https://leetcode.cn/submissions/detail/141243167/">通过</a>   <a href="https://leetcode.cn/submissions/detail/375476296/">DFS</a></td></tr><tr><td><a href="https://leetcode.cn/problems/accounts-merge/">721. 账户合并</a></td><td>维护账户到id的哈希表，合并含有相同账户的id</td><td><a href="https://leetcode.cn/submissions/detail/375528105/">通过</a></td></tr><tr><td><a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用</a></td><td>Kruskal 算法：构造边，排序之后合并连通分量，维护分量长度和节点个数</td><td><a href="https://leetcode.cn/submissions/detail/389340427/">通过</a></td></tr><tr><td><a href="https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/">1697. 检查边长度限制的路径是否存在</a></td><td>离线查询（询问全部给出，但是没必要按照<strong>询问的顺序</strong>处理，可以排序之后离线处理），注意自定义 sort 排序时最好加上引用<code>&amp;</code></td><td><a href="https://leetcode.cn/submissions/detail/389035257/">通过</a></td></tr><tr><td><a href="https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/">2503. 矩阵查询可获得的最大分数</a></td><td>可以考虑<code>点权</code>或者<code>边权</code>（边权就考虑较大边），排序之后然后<strong>离线查询</strong>，询问排序下标就可以，可以看看灵神视频题解</td><td><a href="https://leetcode.cn/submissions/detail/389036925/">边权</a>   <a href="https://leetcode.cn/submissions/detail/389025813/">点权</a></td></tr></tbody></table><ul><li><input disabled="" type="checkbox"> <a href="https://leetcode.cn/problems/evaluate-division/">399. 除法求值</a> </li><li><input disabled="" type="checkbox"> <a href="https://leetcode.cn/problems/bricks-falling-when-hit/">803. 打砖块</a> </li><li><input disabled="" type="checkbox"> <a href="https://leetcode.cn/problems/smallest-string-with-swaps/">1202. 交换字符串中的元素</a></li></ul><h3 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h3><ul><li><a href="https://leetcode.cn/problems/satisfiability-of-equality-equations/solution/shi-yong-bing-cha-ji-chu-li-bu-xiang-jiao-ji-he-we/">使用并查集处理不相交集合问题（Java、Python）</a></li><li><a href="https://leetcode.cn/problems/satisfiability-of-equality-equations/solution/shou-hui-tu-jie-shou-xie-unionfind-bing-cha-ji-bu-/">「手画图解」手写UnionFind，并查集 不再畏惧</a></li><li><a href="https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/solution/by-endlesscheng-qeei/">LC2503：两种写法：离线询问 + 并查集 / 最小堆（Python/Java/C++/Go）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python】将列表转字符串</title>
      <link href="bian-cheng-bei-wang/4d78f241e58d.html"/>
      <url>bian-cheng-bei-wang/4d78f241e58d.html</url>
      
        <content type="html"><![CDATA[<p><strong>前提条件：列表中的元素全部是字符串</strong></p><pre class="language-python" data-language="python"><code class="language-python"><span class="token builtin">list</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token comment"># 首先需要将列表的元素全部转换为str，以下两种方法</span><span class="token comment"># 使用for循环</span>list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">list</span><span class="token punctuation">]</span><span class="token comment"># 使用map函数</span>list2 <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span><span class="token comment"># 使用join将列表中的元素串起来</span>res1 <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>list1<span class="token punctuation">)</span>res2 <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>res1<span class="token punctuation">,</span> res2<span class="token punctuation">)</span></code></pre><p>输出如下：</p><p><img src="https://img-blog.csdnimg.cn/20200403182820156.png" alt="res1和res2结果如下"></p>]]></content>
      
      
      <categories>
          
          <category> 编程备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python】类中函数相互调用方法</title>
      <link href="bian-cheng-bei-wang/7d7b20d80e52.html"/>
      <url>bian-cheng-bei-wang/7d7b20d80e52.html</url>
      
        <content type="html"><![CDATA[<h4 id="方法一：self-方法（参数列表），注意参数列表不需要self"><a href="#方法一：self-方法（参数列表），注意参数列表不需要self" class="headerlink" title="方法一：self.方法（参数列表），注意参数列表不需要self"></a><strong>方法一：self.方法（参数列表），注意参数列表不需要self</strong></h4><h4 id="方法二：类名-方法（self，参数列表）"><a href="#方法二：类名-方法（self，参数列表）" class="headerlink" title="方法二：类名.方法（self，参数列表）"></a><strong>方法二：类名.方法（self，参数列表）</strong></h4><p>具体代码例子如下：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># 利用测试次数和鸡蛋个数的关系变化带来的确定的楼层数来解题</span><span class="token keyword">class</span> <span class="token class-name">dropeggs</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">superEggDrop</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> K<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> N<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        remainTestCount <span class="token operator">=</span> <span class="token number">1</span>        <span class="token comment"># 方法一</span>        <span class="token comment"># while self.getConfirmFloors(remainTestCount, K) &lt; N:</span>        <span class="token comment">#     remainTestCount += 1</span>        <span class="token comment"># return remainTestCount</span>                <span class="token comment"># 方法二</span>        <span class="token keyword">while</span> dropeggs<span class="token punctuation">.</span>getConfirmFloors<span class="token punctuation">(</span>self<span class="token punctuation">,</span> remainTestCount<span class="token punctuation">,</span> K<span class="token punctuation">)</span> <span class="token operator">&lt;</span> N<span class="token punctuation">:</span>            remainTestCount <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> remainTestCount    <span class="token comment"># 在remainTestCount个测试机会、eggsCount个鸡蛋可以确定的楼层数量</span>    <span class="token keyword">def</span> <span class="token function">getConfirmFloors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> remainTestCount<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> eggsCount<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 如果remainTestCount=1，只能移动一次可以确定楼层0（在一楼扔鸡蛋碎了）</span>        <span class="token comment"># 如果eggsCount=1，只能从一楼开始往上面测试扔鸡蛋最多确定remainTestCount个楼层</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>remainTestCount <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">or</span> eggsCount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> remainTestCount        <span class="token keyword">return</span> self<span class="token punctuation">.</span>getConfirmFloors<span class="token punctuation">(</span>remainTestCount<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> eggsCount<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>getConfirmFloors<span class="token punctuation">(</span>remainTestCount<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> eggsCount<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020总结</title>
      <link href="sheng-huo-sui-bi/6c249f289724.html"/>
      <url>sheng-huo-sui-bi/6c249f289724.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0609875a890474650cc542eb3889846dcf205dc652bc10026211fec91ef1ba9c">6802c8327ff80937d8b806ec285ce0fac9a755142ae6e2d068b0a504892a38134c79cbfaa8bd329c5c029d84299b6864db1f755ad9fa4bdb624ed8dc66e161e8c8ac28c66fc63de585151849fefa4c2e9164746e256756616627187b077aa48cfb1c921012a7725cad527555592fae768dc27746e5dd77575cbfbb169c487aaa55c87b89182f5d43630e54ab6cecaad40971367165c2d098188158c43000386c3e8529373d24a0fd00bd03a4acc4e32b36364f12ae1fc12e7a42b1942a1f62c4823c10bb63a1be46f5122c11ddc0f05ba93ebb925c94d1e9e0ea6a2a9e252324ae2afd18da5122bd8e274b6b28851dbc760baa8f1681847ecec8aa78a573e4a96255c3e7702c0d38bc7704b8e50f3f8f36cc467a80b53d167bd743298a304e165f1a8c3a85c6864e962303ad930b165c88ef0ab96feea970fc35810d060dec864d06b40660de7659a775627fd6c1dbdd90eae1b277824b3c3af73be893a8b0371111394bf4057390325c34806a9fe52d6526f2bc485e0e350a43dbc161d18f2de6c7813a638d182df400e50d61b38d49c7f1a40d8335e7f8a28a725eaf11cbd715bfb8e60ffa5aae2d105e46dae8eff4e6662480af5637a4a916e166f7bea08a51ada3eacb3c536acb5a15c567a70c8c141c091ae6b0d399990c9ff806d141e5b3b2ff9d79e47610a9c161617e830b9e01e43a61e65d29cb77e3176c636c92df56942acb1f5ee3e5302f51c2e5ff8eac44a4fe4e60e207b0d57b1efdbabbdf472a4b33a212d6cc2f41a7e8a2982eae6b1000c10b3519885638775e70408ddd98704945d7e78a47772d8cd454726ff1e06d7466b29dff2e8fa3723fdd8d9fed2315acf1f72cefa3321ef1a60ef68fdf806eb5d2c1eaac6424da6f5a6da22e4aea8298193a3d0f26507c218edb077817960a15b84bbb3da8b4a9ffd3b346f7dc63f7526da14a5a3e56ba00e353fdb4385bb9a3c68737658dc0b1e69aae8c28abab8e68e87ad902a5a625f64880920a8d77a56961cd666e6a919dbefbac0f1692974355cbfa49d54e82b290a84cad613c6da48f65a74cbca3d7de839ec4ad4247fe57e9190539089185b53b9d089658949fc4a468a76ed579516c4e52b55f1ae7332028f43adf4420b4cc9fc3f3270375b5a69379082c51ca2206ace6355115b0dca89f3e41795f2705f4912b956300f89f832ff972ab55f50fa16c72a67180ecc78494f474c69dfe302e5192117b49aabfedda80b2ef55510cafbc6f3ebe72b127d87e605bbb6f47ea1b5f05b22e3bad81c99848ca40817b227ba9bfaf6fbaed85bb8c75e9556f4affb7d75cc7202129b80ea59a43741140aeb79e897ba20b44a584dab8518b7b7dbec549143ef47512198cd2d1d44d6168cbe0101b278e33ab198a5670c67295dce6d8a73f8996bc85e330abdbc44f24d8737f31b6d069c060b1f74fa014c31074c89cd43aa01f7c619d6c6ecee009068c9545d37ac394c999fc79a82a79be799443d6972ea005056284aa440a75cd213f776cee1bc386c855dd0029d532adc8e64f047e3133ccf847ae3222ff5f6201387050e73e3aa2e2aaddf9113fcd52987323184ad8df89e9b73c1d9dd540c815dfa9775ee9462d5f882d898c35f8ed4b8b7500b9a7bfa5b16f8bb9e52e33e76425fa0d0b89b45dbda98411d67491b577003dc70d5cac0605fe07c5e13042e31be1a6c19a51d0d1bd83ca5f6cdb70deffb827535de4956c828f9c52ad13e15748109b101a21002754ed45d0c3bb04a1e0a13e30b650c64721974a18bf6d3409c6fc2144eb5eab6231b0a9a560f9f833ab740b7b2e5981c98fd2ac1da8c9b8c9061ba1112db3bfe314095dfaed5fd859de21f1461ae5038910cdafd242f9d79038eef23866d209421cce1c276b8a182e3a3e2da8afcba56c6659cb566d33d5acc44dde5d37af09bf13652d157fb819c27eb755c81ba0ec48cd0a623bb74501d51edfc049bab811dd851ca7124c45d97f5cbe3e0b1bcc9f25a41e1ece2bec48b2b30e04c6772489fa502840e9b0c72f80e70a0f2b4f3d9b852312aacbcb058a0d960f8ad9c65dec49847a3f3bf1808109315bc74a282604d122acf116511428f94e48272dc1f2b9eefd524f346406a8389a1f8f3d3909fd9387ddebdbe3ce9061f8759174657bae3a30d1a407b288e6b116be6474c5164a0c2d0f767dfabdf336e82b83e4133c9a19ca9a150f51c72a27c9bb49ae2e042f832852c54b68444a7f7bd852e2d67bb8e37f9912fee087061cb8138438d1f271dd81965a1d258ed7ceb173a932576d7997f9983ea0669b91ec41810992fab32fb0a11292948f27f455c6ab3540821129b16d928086ffd0415654f11897e44709a777ae4e879e750755d9920465548f5723504ac346285e62c33f996a91cbd44f6e1b0107060f8bc9aca9f6b702f9630611108ff962a6ae797dc8564dcd50b3728fef6e59ebcaf0bfa2bdeb66c487ff80a994444bb23735157df9d15eb516a7f833bd97b76cf86abcd1eddcfe0b1f117ab2ec828806445b61be8d4b4b32410e4c2ae2e63b99dd20b2417e6427ad99340eea17bd91b3089343b5b0dc643e7918a31b967c5439e70d47688410c5e34a0cbf8d1a062f28e8c066b2a6f8a9697e7275bfef2ffef8d7cbb453e11a2eebcec0e3ec04aa345542708a3bcc8f3b93d9dcfd646f58ddbcfbdf4cff22fef4194fadce65a7e8d709611978db4c0705d979fe0213eadcba88460420d0940c6680fd228bf329a346b434fcdd29e2032221352f545b3fc8e6d710165b6a7a7f82fe738b011c5434d87d951c2059cf2a9435285eb55c1492239a707400857118f9a0f0813bb30d2e1a077a0e7a55257ab47efe037ed7f7a8289073def28cc78ac11fff9ed5a458b9b692d7c87c7549054ccdb60b876c9ce416b744bd61c2b0a7838e779d99b59923c5cc54bce220d297e50bb6ad485d4131d0b5ce0cc7103ad6ccc1757ec71a6f48457be2ff9a37e57b52826c08e9853091bc0a8d77f66872c3f024f0573139346bdfb5e797a6bad70725b387d066e93334728c10b0a689d0cfe7bd01cc4359973943bb3b56b3813bfd2af298a24ec1dea3d038279775e6b9ba50c8d788502936b83928739f596fd1db881ea5e2fba4ee21e9a58d803aaa0ae89e402f925a9f8b17f63d1534b29f328d3494a1dbe589c7f07035492207c0967219698ce9ffaf53ce817d841b37162462ffa82268a55b5c38e4655d22bfee3f3b43b7d0ac2b39a2b0bf6b43df79f1f7791163f9de460f5ff0a1fe5fe155aeba2576fff5379cdf369c9ec8c4f468ea0c90d2b9924d01db8120fc14d8c49856df29d1d10c920027b85ed46526f09c75403d9cd77bfa9e948a48e3efd7893f5f8ea183e4b05c90a1aa50637865401d55389d3a141f6026fdce7016b7d33946f4f0931ff9407006c6fac47c4ea01db5a7fadb07c5a326850caf5495216c0051de313e499ac8855d0bf79efcaa215d5a50d927bce7e6c2df770adf30efe613fd0c2d0b9b17b86d6ead80fcf9359456384cca6aa384c2eb014981c309f84770162dc4bc6698ef0ecf2278aa4863c66bc01fee28054aaf480872bf23620138c548f9e497f045dedf25ccc6d692d9e950871d2c6acbd0011cc5aa01228847f45bc64df7db9464b9e88e910525127b2bc025e4e5072395465add0899b5535b65c515d3da5e2864c6a15a9ea293424fc0dca78a61be6816b2bb90b0fa2799f08bf4fa2abc079334ba35903b12c9dd63729b4a5c26ee4fb89b1ad7868c67f9a9408be3a486f4fca52df06aadf58f602108a00384b803c11c6fb92c6055ac0cb78eb36463b1a9069c357a7c5f56ecab1dc9502d54f17ff1cf932c1ee029243eddf40d80b95e3c3d3585cf5b747df6cfe4ce6a0b833b73d9c7fc178ed92d8250155206d2498bfbb10ac00f2ec0c223884fe8320595bd3221cac2fbfe5804e404f0807122bdf8a2228cf946ea6ab5319c09a98482e527edd1772d698e5633a985fa3a7f1f34749ad7cf80ab6ed9cab4bae0dcd4103f6786c61273fb8cfd0d3aab46c94bf727a4c679e278d0ca855704531ac8736dcdd1d65517f9189e5363a5eae4ccf4bafd0f9d3bfa83c0fa5e7351d63c236b2015ed78c526bb9dcb50ba504e964a7a5024f52638fe9a52b2127c6d44cd7099d2bdf8d7e9ece6906ac7ee396f19019615b0417338bc4fa91b5a115f57f2411ca3de5ee4fb181369157b770e46f47ef71457f139b3b295249027704b26df22330ca0c9e796bd40d22ae396ad5972d144114f9146540ab8d35cff824589c119dce5b338ad0e166c464b2e703071a9854adb399426f17a15ff7c12a82b5af736e508aa433bfe1b4f2222a1df66bd2280c023d6273c4121b40ea976e4ffc21136d786954f3532760ea3e1b38a8e3c09207cedded3f84ec2cf85e3abe9751ad7dadba8aa1d4f9ea9860d37d8fba229a197cb8a35b3e96f73afe5fbef9ca8b507c253804f0bd2ea4cb43b43233730e2c6bd19704197df0f430db7b08eeceaef7806b54a36a9772abddd7171be6acbc7a8c506b6258eb07c50632f399d5bfc9c656167067d75e3bb88c9500836c78f6da1eb89f969717d8b2e5b0bb0b9f314af6ca92af9075431a6764694ed4daba41c4453779b31acea70836967d76ad05e36fc7e0e63057836d2ae7d0f2fb31b479ec5281690edfe28ffa0fdecc6a3fad93cbb28901cfe71b85d76422608520dbc7a732cb662b1c9396bf42674094c732aa5e6d04eeb4216699ddf5b6e0eebb44d70b19cc030aed7c4474832c6b1b40497c30460d51aadf51aefb04f8814b1983e26c6b12057774d84624db36e6c85d213d56e91ea23e310c4702af7e804fccd242c102cd0990879350b208939f3db5e3d582411c3d5d015152fa6f4bc94ea8734e1fb3bfe60ded23c4ac25a3a522a80479d0b5104b8ada4fdb816b4188870b10fd360f765f333c0f3884b510d1d7a22065c7cce5339ac419f635784eb8b3a6a8d5c557784d80459730430fd478b4192ca7c6c8bd6817f043616a1fd03c4d0d97e0739bd503b57485cbf9967a527b54539b6d5f29e0a84acee38b67f7b6710348811dc83b59b54d645150183331abdeaa7461802d7c22653727ac239654175e6b0c72798062ca7bf1fa2899e497bcd7d392e9c293b146dca395dc5646468781cf66feeec5615850582e04d7b2ac9285a42a557a7beacd2e92420a7fa86a995a1373896d6bb0438b6543999b62e27f863bde4712247538dee71311bb04eed74576b92a57325a3d9caeab97646b724d872561853bde2e171b2dbaec36087cf80920910b8e6cd5b8e5a4ba5fcc2472c01a695301fef13064e3ceabf99c693a13f9daad516c0e6e84e2fbb541c303948990156315e8eb0160f5a0cd96297836db9cf0c5c44919bac6237993b233ae336239656001a5fc2d822a47ecbfde2bf8c870de126e1641af50c6a6198224bb22816fece0c28fb1113c08d5ad51bd9682b5e3d63b40ea92c0163c1d31be4212b4945020ca444385e3c73d34232ead14804e249c841cd4055f0ac1a490b6164ee2fab4e44dcdf979e67b98be80095d47b6d90395443abbd3b64428796601690acc61f1adcd252ddf6a805147b63dd23360f18f8b8b06fa708daf78d71c175a22ee4f0682f3ee8d64945cb152495802f6e900a9acba4548b9ce49b62aba43ac1367d92c124c546ff720132824812e04bc110f9f65f75aa7fcd5cf7344b8c16c7596c6faa3d290f5f55c9060da4f702e72b6660daa0ab381e768ba3797dc26f662a1561e0d3f8ba08bedeaaf6408b2d7f4bc99f55ed885b1430ae4876fb42c4ccd7454eac74a607ff83afba981a1e4cc4ab93078591ffe2fb33d8c5972e2e4668b404adc330d70a59a35d198f78d9045dc47718ead48fb9a84d6f14f5b266bff7b1419f047982eaea645e3edd319a89c9bfd755b7c7bad9831191764feafb7bc28d3bb7a34e1a4d3e92897efa6d58c03db2115ea53c8469f7de7abf645deca10f88ec04d86a66786a4c59c01e74321504ad72b9c40a85ce753fdd8196573c61faa8f0c0fb3d2eb4df5fe34a081982dac323f46044fb82fc80fd3b4e251fe76ff2fb39476fcf1ff3eb699e08d8b1b781b9229373ea89ea2103a6976e6197ae793b1d1547ed3fd4a0bb0d7069d94c3c92922a8670218ba1bf56bef4e9733def2220d23e68e9cb1d74c3e6e4ca33330933a97de00209ebdf5981362e14d68b33b717995be18a42039b2c3888cb71623ed00cfb5c454aa2d75301f887d3636d20e3cd6c0b01f40b8894a4a01db882b9dc8e630733a87b700807a58f0525ca0d20a389c01c0bcd1f8aefdf4ca66bfccf732e9768232e00b36b3a299ea73c851b57e2696b06a81beac18d2ecc51bf36f6f00fd45756ae7f39d70f2f1eb1f027c2087694fb3a6ec6b922a868928fb44f9a13b849cd7620f610ac824d506a8792301e7afa8bcacb7a920c0a91badaa567d336de8fd0060c764d4181e7a6ab5de8a1de953abf73563f8beac8f06e4218733a06cc62a24df9a1d889b14dc3c12d8a56c8bb2d5a5c02df690c172ada70711f358cd7a2ea4a373b12e00063df4525f4a1fbfc10b67939ee507c1ca6422919de17e900b1b876ac3c97aa98a861caef7bce279f160a3c11a480a037b437a97da1a96fa350b313df67d73ad98369a9d4a2f358157fec05ecfbb8c6538f60e99f40d9b8f2110ce6b3e3e87e186596a04ba3d208f63f9fad9fdee445aaed52877adecb3d285dfe79e8c4bc90a8463f1089e00d1732c56b0574ade0e7f85c140663d2c0ea700884846ba2d67dd7350cab8b43beb9350ee6a7419137656d305f7cca8675be441f49aea269a6a4766792bff250edf3dd8c4836d431f309beebb13c33d016766bba3868e696acf7197827e034cc3055737665f70d75bd4abd03c6f3b46126679b12defe1d206f1cb6ea611715d46acf4147edec8a01c9edb90d204d0c5f41e275cb3f2a983c1192a2c76ab49133f094bd01c41a5a7622f04deeef4e0071f1cb01d4107b0da54a42f33f23eee50f0362844a07dda2bee84552ea6fe0c802db608b70e384b80c7bbe18fc6a6d0e3fef18e45b86d5f3f171a8be299cdf90540a7c1bd39a5a949edf0e9e658d58f6f879dc4c65cdbe63382c3c0fb0d6cab13a1bfe4bd9a6933d139648c62e2a34e478b94259f23fbee6f28f90873588b6ae57ce27a4773518ae301026b7ab04a93e5dcf1513708b51eae126f17af3f1d0ddc17343c20e5cb46366e33a8d308e9732c1ef307755374c452d97ac6278a78e855729e0db83622e22aab7d2188ceb7d4649b9429cf78fce3e0e536565995e37f6c788d91239b06ef4535337dcd96910ca958259299d4a1c4efa4642b00fef9e9daae5304dcf9f9ae17754e575aea64b26c827ef9635a7be3772c8eab3c69bd0232f67e0d1b12f7a88f2ea7d0bf931f6531500c5b9663e4f99321d37d1a30be62ee8eddd8a28e933c8a3235dcd0b785ed5bd3d47434bd12b73cdb4d9bc731bb72ba3f4568204fa92ec4ac74d75ea2d929d761078b66a5647f701911655a14c346b0a0c7f860757a8b0e189e1991a0ece321105b483e1eadb75ca65ecf677cd288f5f6477913d12efbf8bde3bd4a8996ad57a9f6b7845e7c5979e498c008096504f2cb4d889e21411f500137ba3e7d576626e35991c97061d2eea740368787784c4f894644f461794fb58ca88a8ce4695e49f3569390d3a874179fc690eeeee5e542f3a8516048b701bbd7369f1f1315afa646a7eba94f937f186e7bda964d4eb47fe5a7b553773dbc46c79fae6efd0f2cfcc5b9c2ae9101e836566c48fe6068d1f13a7a153a3fa2bc246400e9f4cce74d1896c7ac5db7345799069d6bd18b6c1781db510816ddecfd2f97181245e07efb82beacb6295289fdfb8ae8206b92611a8c8557bc677ce0f468837130ae20e72a5218bd19b15f02c0f2c021d15ad74cc6f4ef214df5c2b413e9d6e07f2e2a3b8255dfada32fbd2a62a7c714e8a83b2a7bcf3b6ea0439e19f9a279485764b4cc9583c705bc9ad96e1dc226a31b88040cb930683c0c334eda8d181c16ce45eac5d7d98696e05f3d51abb47a321a31a0fccbb3be313cd99aab2a025010034f6c04903316e53029d991cab72890af00d32fb3fee74bc3857c941fb406d5f6a9e501da1a10f649f66d1ee9cecc5ce1b07e4e08a1723e81ba08f302cf60d301f755496afa611def99cb321e79db49e0482efb9f46ec878930c52edb8ff7e64349cb3cf1955c0c344924be8aa3811dc7437baadcf6f900fcd668c7376e9bc5ffbb5527cb70cc6f049c55ee0102c75e812069bc7ddce27d0eb5aae01da8a9636daf13bcf514834e000a74fe5ac524400fa4ea439c9d45703ecd2a393af0cad8c54f4289d9f0e8565f6b0b3687b47e227971517986eab286e4493e4bd2544e3fe5ddfc6c24ed5439fb08588112e7c6e1f200fdfa22d697e83e691c9f28029ed4fd1cf0c05cf5952b11a233ac57c3583278e2029c1045d7db114c520be1e802a82fa536c4bd240313533fe9b261ea3e2b77aaa3918acb67c04b5fa21fb1d47a42053fce3065c4f51e300a3ff4b9c19451c8a97fb4fb767f2db559acc905171e17b9e8848ed0b1332b7bd8258d246ce2ac4082ca38785db3605a1b56bd3f6465645e23f31a120963d5b8c6ede345561ebb19b0377feda5295a52c423b516b8abc3392b8c67caa4a55b08fdd78a8f982b3e8a0cb873addb27ec975b4c658b4dd4d9a08de525a7840a33d45da711bb176628abe6aaebd66916a773555c87f655b888fac9b3b1b1732614bb02c3b521381a0a01c4179abb2fb5b409439ded23e57a2ef52f462e9b0fe8a184d26afff18ada6eacbced43547e1e296318b2586d45e714857ad90ee56551c8a6df5b1762483c617e1826b0028f1d0444ce111984d61d53aa3638eda28b5f4e514e81854715a43fbc355ffc70914e236488a0ffa60d1f2641d94a517a1687c350b21d781be5ab841e9c8a967f78a6a69e1987dae1894852111a1bb9ca582edf8f35229fd17f283143e6f90d63b2a814d7a826e2b1b4764b91799851a78fe43604cefc2147c557dead5bdaf2dbfe74db273cdf88ffeab676f7792ede8829c3cb8660b6ac1dd796bdb787a6f84b38e38bbd6a53bfa9f688e4ea7db62bade7b6cab15e7061f463f388ddb6f5a4626c99a154a152e97216b041be3d0651f9ea0a4e0954dcdcebe2d966c5e3811b4dca12624dc5c1da9c62f60e3128b0041c55bd53141218e4fdeaf0f14955bc677c91b89e90e233badee3029ccfad8359927aff91668c3741ce1c6d267467e2a93eeeacb3d19eb2f0e5a24264893e6a102d47dbfc9943c15980459432a551c065384eb18c59320cf0f09450019cc0fe0afd8083fb0c3a576087d382b40098edd24fb796e6c0fd6c6bb917d3194b53de434c0f966a558174559f93ebd96190df9506f317f99d81d0932c301f72d2827f73581f661a8337e6db071e16bb91db04763a39a0034ddb0bdd63e9ace593d404346fe81f225cfa8923732b93a06dd9a1ba2eaff34bbdd6d4d406d06d92cf37df946597d74908d095d51bf53b50c2ef923f2990646b06f667a36c1409491ad8e6d11329db2124d4f96d9660829d05a246423c695f3814635a9ab399b3877b0441994f2f7845c6a38c074a32574267d43fe861b5176d2dc65ec11d878bbaee73c165e743fbd5c302022c5061635c58dca81000b2b332aaab06f4913df5a575633b7c2db3f73979ac7681711522a26b8f56d1d88e0c412c7753a22ddd885208d7d1e8842c076956b4696c32058dd22ea6fa7d0b4b98cf356de209111ac46d8991e13ed45921cee1c1b1428b5cae1314a9bde2572173e0a68dae99e7b035a8ca41281e8083d81e39621197bd69009643ee445bae2902af6cec74d921504544dbad5eee131245afb5fba5fef4760e8305312b59737ce217f2e5932270b52d773da868a4c3e256a3eb04f0a390e51c04757c6bb46f0d056c8792ba1ced58f3134da30423470327dff5c92f4f3cdb28e7eec0c8c11d3dc5824c08292f4aaab3bdd242de7cc9c36824e07790a3078dc637bdbc06cfd93de49ba3fc66425f0cb4bef224a640e297c97578437d04cc38e124e4a04acff1b21c26b3656c7aefa23de7f52badcdf6fd2bbdfba36fcfe23c7bdeebabe63c68e18ae5f6925cff0f4b5cf669e6141bdf2136fb2adb809c32723331a0f4fbdcdeb022fec45694859171b0221d5b5af7c677730fbe8d7d12a91281a7c6e94cdf19e79486f8c93143a05e76ccda5708580fffb451b2c8d7f9b8d3275538d520feaf2800d639876729fcfaad73501384690b66ee791d000cfbe7fc0872629ba629305e8e78edb292c360ef6ea5163b8920418e11357d13316e9fdaa3c83e1aea266cab1947727f38329436515cd277c306206959236b1ee45dd5d6880d1801359dd57b32b4008e41947f7fd9ae5c92253896022f5418479f8a1596df8bfaed70c101122963415a479a7b88acbbf99c0a34d6a20de756119578d618dc1281c747da5c79205324318a1325149ae5164640e7d517839a6b796739642f7f917ff6ad3989d0fc27cfb1d9db1a352eaa09c0cb107f37d0f7aa88a3bc927a3270f06313c09e03e3f6790a901038be95b72b17997cb684ca0355c16510cd49c0195ee3eb097cd8a776be005bd1e508094e3e28e778f6f934403237482f70c5fd5a9290ed705c8ac22d2cce404a2c109a88de9af594a76bec4915ebc5ba5b60b02244742c3be18acee7e26c45e67866e8aafbbe18c58697c22574ac7dca510b5fe811bb25fe970fff64bbc2052092eee1e4f480638262f414d3cffe7381ea0a2c641065f397be8733da6386b38bb761e7391ddf7d67a050b2a4d1b485a199687ace94ef3f5abb0c0ef30397767015397b9eaa0c32b759290d611679b83323c58d03bc58c7cd6c5947261bc0dfe25366009f8b4ea827ffe26cf106e311a8d0e005c07787a3bc66d429177b7226de368b6d1e054dcf5ade8cda0a45a0adb7e2716ce366132fb3a0526eff6ed78c5a9f404ec4758e2aca3ed576e6565cc60b6894b3165fd114886ec91f164fd66a1345a898831bdf888fa5c3cea01886a8fe53f9c03839d7c97729dbca7f5a5b2593094ac47cba4f66f17a8cce5d9904668c1f4ba87996af1695a02a0073d97f53ec1e5201c822c869096c4e92d253996b4e534f708cbee6dbc437c2d6c6e7d9270d3ad88f0ee10c380ada9e14c1e038f0994c318d539c0e1700a7d6c1be67957c84f55ce083f31bc558d3761453e7b2997428cde91b99e7b3ebe12b1e4b5b73c5b332d227eb37e1ccd9ceee39d119da6a898ecf3a24ea7fbca60d846ede0cc18e8d99c59b07777cfafe77a18ad3617fa7dacf6b7084fa5e85e864487b015fc859cc99ef11a143e1dde592b856ce5c5a18e9cc26f3e84964e8d511f3415b1771b98954c431393d325812e70541603dbef51f29bdbe77125506e33fbd4e4a031c13208e6c2a371c0e74f4b2100491b8605507a566b7305fc83e13355d547f70dbdc610c1b8e845912734b00c24a91ab530aa6bc31d7a78374b26f7578edf75d7b6962646663402c4a1d074c914d1f434c94bfbd2d14ad07853b558f54c725725e199769a03d07e0812d49b35e73e63e5b756d984e6383816001adf4cbd000c76f466d7b04849508516f64a4f5c5a93a22d072baeb713ecb01d275e49a8a2d41ba1c41b90e3c52fd00f1781bbcd48ec1a1095c7734545b045e38790bd86add690b78c1cda80c26c61928437989ce7da05c08fbbb61d2c30249a8a33e598c133d836ed7af32b54809f3399dd4c6d320e2e107a1a2e470fb981ff80a72c8813bc2455b6f4496a484c054868d432e83f6f3cdd760b263fc3160b033e4690bfae638f5275cc43f07306519bc2c9bee1bdce7971df284a0631035907efc9dc3de6f63c287a6e0ec48fc346e110eaa5959c036c9e30b2949f799d39a75b20cc8476d715f1f6282d4f10627ccf5962c3184e1d288eaa4814e87e88723f451e112a938b1c46c0c75b8c206f7f491330203c49e7a14d368d7d0e75d84e989af416c5e7460e20f3968e54587af7fc40d5ce0671f194cbde9176c74a000431a9508385cc3a5c24714c98f2d4bcd1487d5e3cad56ecaa20283b61e05aee991e31d2e23630ab352c4826ca66f885211dd165f75d19fcdbb16a07eb3c5d01a265d197143d65ea7d8124b70364a3a880c6770998fbacb31d9704f6935e839a5249b6c385786f24c189ec3359fdc31709a3f058c2026325ef3faaa2e88f92bc8b415771ca11510d28601a379b2756ef874a72edd5c2756cf8b3dc8194587e56788f87e9611ad3a30e8f81215d8511dd8650429df73073e3f3f2abad57454546e38b2e00af4004d803f2ae76f73075976c823bf88c7202dd2fa2db000afe1ba798386309f90e43dd729e44719e7c5c5201938aa24ee4180734b826f0f025758477e9ff5dd06853de2f090cc6246fb999802d731209e60225c48c31e98d9dbb1bf7b173e61f364aca1f00e550553d71d22dec521056dee031d5219e213372e081edbf7db0c9a32b3751a51e498d48ebbbf0a05af36f8d682f7d5c9ba11eecc323bfdd028ab9278b08f922e35cb4d3949dd00ac4dddbc5b0e309c1368ee00e3e9feed236365e598b7af5ea902987a8bc080aefeb4a2dba0718e2f2f33fc79862feeb1eea95e8f1d2bbe54e8fc993564ce81192af858d2d180d9989f746a3e074c24cd187c826d2cc7fc85e19d7c2a859a6ecf771373e08b1d7758c9ba084a7a618fc9fafdc1f80aeea71a6fb33ad901b2ac289406a5a10bd00d80044b2c8c1aa0f4171c5b398317cc9b5894cacb38bfb9687aaf309f4e6d9cb75348c2ac2815d6e4c1825b655737b258f40320bda6469aaf5f81bc9165ae8e8b581fd09f3f86720061e316ac6537ef98fa740a4ae1a620c1fc5225c6f5dac7cfba8ed5e670fee04dfb1084cd8aaa4d73f4904bdc42c49cc6ad4a72a7da559276294b434524c0eff4701171d4e6658ff469951d0c1dd74e1a0553abc9cc3a3690db1512524f7fa91d4baa8f9dfa1bf3513ac7b4f92d1416cfd7640c0490984166638f4a5df492b73c081a473eaab3e1dbc5b49c1e17a045bd62c8ca95b2db8178bd14c3996379917a7ec36ec567e464439d710460fcac4288e67bd30106fc891abab7b8b3ef017f41fde24997a74dc33cc86154520fe678f261345728afe72eef1a4806efab92c5a16173d332fc8702223614077b4c6e628c30bf1174f7abe4792fe21348771fcee210634875862a012932c8d869476fe5d7f4e365a851b9f2f7add67dbc97c734446b3d0e0127840a627bb7512e397735c9cefb620116585cd9d10a5490b09f68a8a736cf487658f99bad5b27708ace25f0e9daccc88ec422fd54e217194375cc7876f441d7f7f77d63e6b7f36208a82c660b2027dacdff81f14c53f288ca6037a505fba44a33530ac46cb555c9136746206b8a29be646492bf7239778ea02f0016606af297049d10650b4b2cccf36bc06ae80c8504a611e348c65a7dfcfb95ab05acce08c80c6253594e0b9c33b5e20820ec7b15f208294c3a87ed3d019f8041eef69adcea2a35acaf613b0551f371e84bc49c8c34658c97ef2fccc436c338b77bd80bf984e3c53d2baad52f4b1de18462c66f29c42ae3cac015c45bc413fb9dff102e18747f2dfed30043a9d8a9104d511c97f25332fab8b59fc576c4dbf76638fc31ec63e39160edc53cb04e7efc3a55751123a131311d2009476317fcb81b81427000e4e0fe3b3752253e1667148b73013253d98553afd6e53e2b5b65ef1ee177abc3e7995d49739fd0e333911d6b315b32a5be87c55db7583020118bce5e72b123c193ff72c810394f84723c555e1b605d0020a843cc28e771c6db50b5cbfa8959aaf18cbd067cdd08b23604aaf2fc040bb7ba5bac7f5ce48bfa7bd77a7a69d433289a30f2c8d84fe6779faf0d8bc26f762392de37d6f17cd2d0b01ddf30e24dd0b9085ec6e34f2fad6d94e7c73c9ed57793c92bcb6ba6fb695d4a401e4be92b39c2f6952892355da9a9ba982c6419b4755689904742facea4ae7df63769b207c1081c2a141be07f0712fbca00b054c0a3f20a67c444965dd14d97ee316b5bb102ee2ab5caf8a3fe08fb62b75dc5e47e3f51ee8c3dd5d9d00e16133948d95c4ad0c950c76425d614f42199d8fdcaedfef3a62bb71f5326e57f4e483de4d103739d841a1246ddfa109aac99677f7e6808b0c96b05758c17cef356e8cdcf4a93563923d42542911473a00ff75a8c7b82b75a47c7cd861f48da283f89bdbdf9ff2021f1522763e7059358bd4ef8000dd5b73fd027cfa031a07121b2d17b4eccb7213921b84563e8536befd239d78fd68b29a41546243422c2a4519b67e44cbcc9b48f132cf4cc34e8dd0c90cef7302e211e439ab4514286524b3551277c4d98102d8ec2c52944c1b4d36203af03e902662b70a20ff0d1b92a6ab9a001842615e726ee153857146bc43ba99f2e5422062a13198191e187a060f4a77a004d72ed5dc86cc7b978ed266d5816108f52caa360a75d839d0bc7d5ba81eedee9aae12ce62e15046d87c28ca148e4a3f2fcad2cb3295248bb8d6e7098e316d0303232ee39992eb6fddeb02a1b46aee35eeecb891a222f83c9c2977c8de065b2959bb22390d54c73f71005c87e4e65eaa30422536f5587fcd0edda8bee845318afcdd64263a8d3b038fccd14a11c5052971eb089c3f6e9463942988d6b3e00a00d70613322d36d87ea90a085d65a578393dbc736270d2e88603796a9c368044b3e72fedf0be64739349235da4bda283b56b644717a5e2edcde0712b28451428c48e32e0af83d23e3b030883cd359ee56099a9a328d5d765a2d6b4627c278121e0c007d7dde6fc868e6264d47aaee9ee3c3457cc42822abd203f31189e8b5143e0dd76824fdd498f28e3bcb2ad196a856d039eb2c518987d2f32d2d50d45c30cc1a81543404586a9e8e7e36d9425600da266f197fce290d12e530792d48cafdb8cd0dda4eea4773d5a0d33aa3b0739265fe7acba093616e94852e185c0f520638f641b024c877042c5ab8b807f39570e607ff480bc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章（欲知晓请于留言板与我联系）。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Git】更新github指定文件以及git创建分支操作</title>
      <link href="xiao-ji-qiao/5c784c3b9232.html"/>
      <url>xiao-ji-qiao/5c784c3b9232.html</url>
      
        <content type="html"><![CDATA[<h2 id="更新github指定文件"><a href="#更新github指定文件" class="headerlink" title="更新github指定文件"></a>更新github指定文件</h2><p>首先在先前提交的文件中，更新要提交的文件</p><ol><li><code>git add filename</code>（要更新的文件名）</li><li><code>git commit -m 'Update filename'</code></li><li><code>git remote rm origin</code></li><li><code>git remote add origin 地址</code></li><li><code>git pull origin main</code>     // 没有这一步容易出错</li><li><code>git push origin main</code></li></ol><p>参考：</p><ul><li><a href="https://blog.csdn.net/weixin_44046355/article/details/91984584">更新github项目</a></li><li><a href="https://blog.csdn.net/gongqinglin/article/details/79752398?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control">git推送更新出错</a><blockquote><p>为什么<code>git push / push </code>不需要加 <code>-u </code>选项，可以参<a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732864121440">考廖雪峰老师</a>说的：”由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令” ，大致意思就是刚开始创建仓库的时候是空的就需要加，现在我是修改已经存在仓库中的文件就不需要加了</p></blockquote></li></ul><h2 id="git创建分支基本操作"><a href="#git创建分支基本操作" class="headerlink" title="git创建分支基本操作"></a>git创建分支基本操作</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 创建一个新的分支newbranch，并且切换到这个分支上</span><span class="token function">git</span> checkout -b <span class="token variable"><span class="token variable">`</span>newbranch<span class="token variable">`</span></span><span class="token comment"># 注意这个checkout命令如果后面加了`--`之后是撤销修改的意思，例如撤销对readme文件的修改</span><span class="token function">git</span> checkout -- README.md<span class="token comment"># 所以推荐使用switch方法，创建并且切换分支</span><span class="token function">git</span> switch -c new branch<span class="token comment"># 如果分为两步骤 1.创建新分支 2.切换</span><span class="token function">git</span> branch <span class="token variable"><span class="token variable">`</span>newbranch<span class="token variable">`</span></span><span class="token function">git</span> checkout <span class="token variable"><span class="token variable">`</span>newbranch<span class="token variable">`</span></span><span class="token comment"># 通过switch切换</span><span class="token function">git</span> switch <span class="token variable"><span class="token variable">`</span>newbranch<span class="token variable">`</span></span><span class="token comment"># 查看当前分支：会列出所有分支，当前分支前面有一个*号</span><span class="token function">git</span> branch<span class="token comment"># 合并新分支到主分支main上面</span><span class="token function">git</span> merge newbranch<span class="token comment"># 删除分支</span><span class="token function">git</span> branch -d <span class="token variable"><span class="token variable">`</span>newbranch<span class="token variable">`</span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【linux shell】while read line几种方法以及区别</title>
      <link href="yi-cuo-zhi-shi/fbae3676e54e.html"/>
      <url>yi-cuo-zhi-shi/fbae3676e54e.html</url>
      
        <content type="html"><![CDATA[<p><strong>引言</strong>：开始时自己的写的一个下载<a href="https://bing.ioliu.cn/?p=">某个bing网站</a>上面的图片的脚本程序中需要使用while read line读取自己提取出来的图片信息，刚开始没有用临时文件存放信息，而是直接使用管道机制重定向，结果……坑了我一个小时<br>==然后自己查了一些资料，比较一下三种while read line方法的区别==<br>首先自己的test文件如下：（就简单是三行数据）<br><img src="https://img-blog.csdnimg.cn/20200508145856694.png" alt="test文件内容"></p><h2 id="while-read-line三种方法"><a href="#while-read-line三种方法" class="headerlink" title="while-read-line三种方法"></a>while-read-line三种方法</h2><h3 id="1-形如cat-test-while-read-line-do-echo-line-done"><a href="#1-形如cat-test-while-read-line-do-echo-line-done" class="headerlink" title="1. 形如cat test | while read line;do echo $line;done"></a>1. 形如cat test | while read line;do echo $line;done</h3><ul><li>代码如下<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">name1</span><span class="token operator">=</span><span class="token string">"xiaowang"</span><span class="token assign-left variable">date1</span><span class="token operator">=</span><span class="token string">"2020-05-08"</span><span class="token function">cat</span> <span class="token builtin class-name">test</span> <span class="token operator">|</span> <span class="token keyword">while</span> <span class="token builtin class-name">read</span> <span class="token function">date</span><span class="token keyword">do</span>    <span class="token builtin class-name">read</span> url    <span class="token builtin class-name">read</span> name    <span class="token assign-left variable">name1</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$name</span>"</span>    <span class="token assign-left variable">date1</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$date</span>"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$date1</span> <span class="token variable">$name1</span> <span class="token variable">$url</span>"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$date</span> <span class="token variable">$name</span> <span class="token variable">$url</span>"</span><span class="token keyword">done</span><span class="token builtin class-name">echo</span> <span class="token string">"888888 <span class="token variable">$date1</span> 777 <span class="token variable">$name1</span> 666  <span class="token variable">$url</span>"</span></code></pre></li><li>结果输出<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token number">2020</span>-05-07 https://bing.ioliu.cn/photo/WildflowerWeek_ZH-CN4593499387?force<span class="token operator">=</span>download 印克斯湖国家公园中的德克萨斯矢车菊，德克萨斯州<span class="token number">2020</span>-05-07 https://bing.ioliu.cn/photo/WildflowerWeek_ZH-CN4593499387?force<span class="token operator">=</span>download 印克斯湖国家公园中的德克萨斯矢车菊，德克萨斯州<span class="token number">888888</span> <span class="token number">2020</span>-05-08 <span class="token number">777</span> xiaowang <span class="token number">666</span></code></pre></li></ul><p><strong>我想的是使用while read line读取文件之后赋值给name1和date1，结果并没赋值。刚开始很疑惑，明明在while循环中的name1和date1都赋值了为啥退出之后没了呢，结果发现是管道的机制，这个使用管道之后while read line是在子shell中进行的，所以在退出while之后其中的操作都是无效的</strong></p><p>另外，参考一片博客中说的：cat test会一次性将test文件所有数据装入内存，如果test文件足够大，会直接占用巨量内存</p><h3 id="2-形如-while-read-line-lt-test-do-echo-line-done"><a href="#2-形如-while-read-line-lt-test-do-echo-line-done" class="headerlink" title="2.形如 while read line <test;do echo $line;done"></a>2.形如 while read line &lt;test;do echo $line;done</h3><ul><li><p>代码如下</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">name1</span><span class="token operator">=</span><span class="token string">"xiaowang"</span><span class="token assign-left variable">date1</span><span class="token operator">=</span><span class="token string">"2020-05-08"</span><span class="token keyword">while</span> <span class="token builtin class-name">read</span> <span class="token function">date</span> <span class="token operator">&lt;</span> <span class="token builtin class-name">test</span><span class="token keyword">do</span>    <span class="token builtin class-name">read</span> url    <span class="token builtin class-name">read</span> name    <span class="token assign-left variable">name1</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$name</span>"</span>    <span class="token assign-left variable">date1</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$date</span>"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$date1</span> <span class="token variable">$name1</span> <span class="token variable">$url</span>"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$date</span> <span class="token variable">$name</span> <span class="token variable">$url</span>"</span><span class="token keyword">done</span><span class="token builtin class-name">echo</span> <span class="token string">"888888 <span class="token variable">$date1</span> 777 <span class="token variable">$name1</span> 666  <span class="token variable">$url</span>"</span></code></pre></li><li><p>结果如下</p><pre class="language-bash" data-language="bash"><code class="language-bash">   <span class="token number">2020</span>-05-07  <span class="token number">2020</span>-05-07  <span class="token number">2020</span>-05-07  <span class="token number">2020</span>-05-07  <span class="token number">2020</span>-05-07  <span class="token number">2020</span>-05-07  <span class="token punctuation">..</span>.</code></pre></li></ul><p><strong>首先我看不懂这个输出结果（其中的空行全是我自己按的回车，也就是按了两次回车之后才出现结果，然后这个while循环一直不结束…）查说法就是：它会在每次循环的时候都重新打开test文件，使得每次都从头开始读数据，而不是每次从上一次标记的地方继续读数据。</strong></p><h3 id="3-【最佳】形如while-read-line-do-echo-line-done-lt-test"><a href="#3-【最佳】形如while-read-line-do-echo-line-done-lt-test" class="headerlink" title="3.【最佳】形如while read line;do echo $line;done <test"></a>3.【最佳】形如while read line;do echo $line;done &lt;test</h3><ul><li><p>代码如下</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">name1</span><span class="token operator">=</span><span class="token string">"xiaowang"</span><span class="token assign-left variable">date1</span><span class="token operator">=</span><span class="token string">"2020-05-08"</span><span class="token keyword">while</span> <span class="token builtin class-name">read</span> <span class="token function">date</span><span class="token keyword">do</span>    <span class="token builtin class-name">read</span> url    <span class="token builtin class-name">read</span> name    <span class="token assign-left variable">name1</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$name</span>"</span>    <span class="token assign-left variable">date1</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$date</span>"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$date1</span> <span class="token variable">$name1</span> <span class="token variable">$url</span>"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$date</span> <span class="token variable">$name</span> <span class="token variable">$url</span>"</span><span class="token keyword">done</span> <span class="token operator">&lt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">"888888 <span class="token variable">$date1</span> 777 <span class="token variable">$name1</span> 666  <span class="token variable">$url</span>"</span></code></pre></li><li><p>结果如下（正常了耶）</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token number">2020</span>-05-07 https://bing.ioliu.cn/photo/WildflowerWeek_ZH-CN4593499387?force<span class="token operator">=</span>download 印克斯湖国家公园中的德克萨斯矢车菊，德克萨斯州<span class="token number">2020</span>-05-07 https://bing.ioliu.cn/photo/WildflowerWeek_ZH-CN4593499387?force<span class="token operator">=</span>download 印克斯湖国家公园中的德克萨斯矢车菊，德克萨斯州<span class="token number">888888</span> <span class="token number">2020</span>-05-07 <span class="token number">777</span> https://bing.ioliu.cn/photo/WildflowerWeek_ZH-CN4593499387?force<span class="token operator">=</span>download <span class="token number">666</span>  印克斯湖国家公园中的德克萨斯矢车菊，德克萨斯州</code></pre></li></ul><p><strong>这个不就是我想要的结果吗，使用输入重定向的方式则每次只占用一行数据的内存，而且是在当前shell环境下执行的，while内的变量赋值、数组赋值在退出while后仍然有效。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>以上三种方法中，大家在选取的时候最好选择第三那种方法，别问为什么问。</li><li>其实读取文件内容的方法有很多，比如使用形如：for line in $(&lt;file); do echo ​$line; done的方法，据说这种方法效率最高，具体可以参考<a href="https://blog.csdn.net/u014650722/article/details/51563823">这篇博客</a>，这个说了几种while read和for的比较。</li><li>另外如果想要了解我那个下载图片的脚本程序可以访问<a href="https://github.com/EricPengShuai/Linux-Shell-netstat--s-And-download-photos">我的github</a></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/xl-892694298/p/11017168.html">https://www.cnblogs.com/xl-892694298/p/11017168.html</a><br><a href="https://blog.csdn.net/u014650722/article/details/51563823">https://blog.csdn.net/u014650722/article/details/51563823</a></p>]]></content>
      
      
      <categories>
          
          <category> 易错知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WireShark】成功解决WireShark没有发现端口，Win10pcap和Npcap安装失败</title>
      <link href="chang-jian-bao-cuo/40828016f13e.html"/>
      <url>chang-jian-bao-cuo/40828016f13e.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><h3 id="引言："><a href="#引言：" class="headerlink" title="引言："></a><strong>引言</strong>：</h3><p>wireshark是去年安装的，大约一年没用了，现在一打开发现<strong>“没有发现接口”</strong>，本来是要通过抓包了解IPV6分组机制（分片扩展首部），结果蒙了…下面说一下整个解决过程</p><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a><strong>原因</strong>：</h3><p>没有<a href="https://www.cnblogs.com/cc1840/p/10074686.html">Npcap或者Winpcap</a>，这里大家可能想知道这两个有啥区别，总体上是Npcap是现在的新型Windows网络数据包截获软件，替代了Winpcap，现在安装wireshark的时候一般都会安装Npcap的，具体区别<a href="https://blog.csdn.net/hsluoyc/article/details/46483151">传送门</a></p><ol><li><p>首先<strong>卸载你电脑中的Npcap或者Winpcap</strong>（这个已经不完整了），具体清理过程<a href="https://blog.csdn.net/hs_err_log/article/details/79646455">传送门</a></p></li><li><p>开始我查CSDN上面的说法是<strong>下载Win10pcap</strong>，这里<a href="http://www.win10pcap.org/download/">附链接</a>，不知道为什么我总是安装失败（可能自己环境确实有点问题，不过你们可以试试）</p></li><li><p>然后我又尝试<strong>安装Npcap</strong>（一般的wireshark文件夹中都会有这个的安装程序）<br><img src="https://img-blog.csdnimg.cn/20200403185450956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="wireshark安装目录"><br>如果你安装成功，那么恭喜你，你欧气爆棚，但是我是没有安装上的，总是提示<br><img src="https://img-blog.csdnimg.cn/20200403185619214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="安装Npcap失败"></p></li></ol><p> <strong>关于这个错误网上说法很多：有可能是自己的Npcap没有卸载干净、还有可能你改变了路径、另外就是他自己说的版本太低……</strong><br> 前两个我试了还是不行<br> 然后我又<strong>下载了最新版本的Npcap</strong>，这里附上<a href="https://nmap.org/download.html">官网</a>，然后重新安装，结果还是报错，气得我…..直接把wireshark卸载了（以为我去年这个版本已经不行了，然后去<a href="https://www.wireshark.org/download.html">官网</a>下载最新的版本），然后把之前的工作又重新做了一遍，所以结果还是一样不行！！！！心态崩了</p><ol start="4"><li>将之前安装的Npcap重新卸载之后，<strong>百度了一下WinPcap，结果发现了新大陆</strong>，在<a href="https://www.winpcap.org/install/default.htm">WinPcap官网下载</a>了WinPcap，傻瓜式下载安装竟然ok了，然后打开<strong>wireshark竟然看到了接口</strong>，我人没了【具体为什么之前的Win10Pcap不行而这个可以我也不知道，注意这个我用的是WinPcap】<br><img src="https://img-blog.csdnimg.cn/20200403191932344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="WinPcap主页"></li></ol><h3 id="结束："><a href="#结束：" class="headerlink" title="结束："></a><strong>结束</strong>：</h3><p>然后我又可以快乐的用wireshark抓包了</p>]]></content>
      
      
      <categories>
          
          <category> 常见报错 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WireShark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WXG后端实习面试题】去除驼峰字符串</title>
      <link href="suan-fa/aa9cbe7520ab.html"/>
      <url>suan-fa/aa9cbe7520ab.html</url>
      
        <content type="html"><![CDATA[<p>今天面试了一个腾讯微信后台，说了几句就说弄一个题做一下，结果一脸懵逼，给定字符串，去除其中的驼峰字符串（例如：将“AaAdfAAaAaA”变成“df”）。</p><p>说实话对于<strong>驼峰串</strong>这个定义就有点模糊，本来当时有点紧张，有时在牛客网上做题，他别是那个面试官看着你做题，我当时脑子真的就是一片空白，这个驼峰串仅仅是两个大写字母中间夹一个小字母吗？能不能是两个小字母夹一个大写字母呢？（毕竟这个<strong>aAa</strong>也像驼峰）总之面试是gg了，之后网上看了一些解答，自己总结一下。</p><ul><li>首先对于第一种情况：驼峰串仅仅是两个大写字母中间夹一个小字母，形如AaA<pre class="language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token string">'AaAdfaAaAaAaAaB'</span><span class="token builtin">len</span> <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s字符串长度："</span> <span class="token operator">%</span> <span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">)</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">:</span>    <span class="token comment"># 遇到驼峰</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">and</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">and</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">2</span>        i <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 如果没有驼峰并且不是之前识别驼峰的最后一个字母就打印</span>    <span class="token keyword">elif</span> i <span class="token operator">!=</span> j<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">'  '</span><span class="token punctuation">)</span>    i <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token builtin">len</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">:</span>    <span class="token comment"># 对于像'AaAdfAaAaAaAaA'这样的串处理最后两个字符不要打印</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">and</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">and</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 对于像"AaAdfAaAaAaAaB"、"AaAdfaAaAaAaAaB"这样的串特殊处理最后两个字符</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>调试结果如下：<br><img src="https://img-blog.csdnimg.cn/20200331225824935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020033122565815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>其次对于第二种情况：形如AaA、aAa都可以当成驼峰串<pre class="language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token string">'AaAdfAaAaAaAaA'</span><span class="token builtin">len</span> <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"字符串长度："</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">)</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">:</span>    <span class="token comment"># 遇到驼峰</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">and</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">2</span>        i <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 如果没有驼峰并且不是之前识别驼峰的最后一个字母就打印</span>    <span class="token keyword">elif</span> i <span class="token operator">!=</span> j<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">'  '</span><span class="token punctuation">)</span>    i <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token builtin">len</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">:</span>    <span class="token comment"># 对于像'AaAdfAaAaAaAaA'这样的串处理最后两个字符不要打印</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">and</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 对于像"AaAdfaAaAaAaAaB"这样的字符串特殊处理最后一个字符</span>    <span class="token keyword">elif</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">and</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment"># 对于像'AaAdfAaAaAaAaaa'这样的串特殊处理最后两个字符,另外对于这种情况是不是有点问题</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>调试结果如下：<br><img src="https://img-blog.csdnimg.cn/20200331223036784.png" alt="测试结果1"><br><img src="https://img-blog.csdnimg.cn/20200331222927502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="测试结果2"><br><img src="https://img-blog.csdnimg.cn/20200331223319160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="测试结果3"></li></ul><p><strong>总结</strong>：其实这个算法的核心就是<strong>while循环</strong>部分：其中j的作用很巧妙，配合i的增加做到了对每个驼峰串的识别</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【分治法】解决循环赛问题（n分为奇数和偶数）</title>
      <link href="suan-fa/1741f76a1a4e.html"/>
      <url>suan-fa/1741f76a1a4e.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设有N个运动员要进行网球循环赛，设计一个满足以下要求的比赛日程表</p><ol><li>每个选手必须与其他n-1个选手各赛一次；</li><li>每个选手一天只能赛一次；</li><li>当n 是偶数，循环赛进行n-1简单天，当n是奇数，循环赛进行n天。</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-首先考虑简单问题（n-2-k）"><a href="#1-首先考虑简单问题（n-2-k）" class="headerlink" title="1. 首先考虑简单问题（n = 2^k）"></a>1. 首先考虑简单问题（n = 2^k）</h3><p>这个我先上一个图大家应该就可以明白：</p><p><img src="https://img-blog.csdnimg.cn/20191024222342845.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="第1列为选手，第2-8列为赛程，8个选手赛7天"></p><p>应该很容易想到分治法，有如下规律：对于任意一个正方形区域（包括4、16……个小方块）左上角和右下角相等，右上角和左下角相等（<strong>如果懒得看汉字就直接看上面几种颜色的方块吧</strong>）</p><p><img src="/pic/divide.jpg" alt="n=8"></p><blockquote><p>按分治策略，我们可以将所有的选手分为两半，则n个选手的比赛日程表可以通过n/2个选手的比赛日程表来决定。递归地用这种一分为二的策略对选手进行划分，直到只剩下两个选手时，比赛日程表的制定就变得很简单。这时只要让这两个选手进行比赛就可以了。如上图，所列出的正方形表是8个选手的比赛日程表。其中左上角与左下角的两小块分别为选手1至选手4和选手5至选手8前3天的比赛日程。据此，将左上角小块中的所有数字按其相对位置抄到右下角，又将左下角小块中的所有数字按其相对位置抄到右上角，这样我们就分别安排好了选手1至选手4和选手5至选手8在后4天的比赛日程。</p></blockquote><p>然后这个代码也很容易：</p><ul><li><input disabled="" type="checkbox"> 非递归（k是2上面的次数）<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">SetTable</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//初始化左上角数</span>    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//然后分治安排</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span>   <span class="token comment">//len = 2^i</span>        <span class="token keyword">int</span> half <span class="token operator">=</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>         <span class="token comment">//左下角子表就是左上角子表加上half</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> half<span class="token punctuation">;</span> row <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> row <span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> half<span class="token punctuation">;</span> col <span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                a<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>row <span class="token operator">-</span> half<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">+</span> half<span class="token punctuation">;</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//右上角子表就是左下角子表</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> row <span class="token operator">&lt;</span> half<span class="token punctuation">;</span> row <span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> half<span class="token punctuation">;</span> col <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> col <span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                a<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>row <span class="token operator">+</span> half<span class="token punctuation">]</span><span class="token punctuation">[</span>col <span class="token operator">-</span> half<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//右下角子表就是左上角子表</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> half<span class="token punctuation">;</span> row <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> row <span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> half<span class="token punctuation">;</span> col <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> col <span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                a<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>row <span class="token operator">-</span> half<span class="token punctuation">]</span><span class="token punctuation">[</span>col <span class="token operator">-</span> half<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><input disabled="" type="checkbox"> 递归（n是比赛总人数，这里先考虑简单的n = 2^k）<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">tourna</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tourna</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">copy</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            a<span class="token punctuation">[</span>i <span class="token operator">+</span> m<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> m<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//右下角</span>            a<span class="token punctuation">[</span>i <span class="token operator">+</span> m<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> m<span class="token punctuation">;</span>  <span class="token comment">//左下角</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> m<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> m<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//右上角</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="2-衍生到一般的偶数（如果n不是2的次方）"><a href="#2-衍生到一般的偶数（如果n不是2的次方）" class="headerlink" title="2. 衍生到一般的偶数（如果n不是2的次方）"></a>2. 衍生到一般的偶数（如果n不是2的次方）</h3><p>举一个例子（n=6），既然是分治法，按照大的思路，我们把tourna(6, a)问题转换成tourna(3, a)【这里的你们就先看成是上面的tourna函数】，那么问题又来了，n=3怎么解决呢？（自然引出了奇数的问题，那我们直接考虑下面的奇数问题，这里大家可以直接跳到第三种情况看，看完之后回看这一点）</p><p>我们可以将6分为（1 2 3）和（4 5 6）我们且看两者单独考虑的赛程：<br><img src="https://img-blog.csdnimg.cn/2019102423094673.PNG" alt="（1 2 3）赛程"> <img src="https://img-blog.csdnimg.cn/20191024231411687.PNG" alt="（4  5  6）赛程">  </p><ul><li>考虑到（1 2 3）（4 5  6）“1和4”的第四列（第三天），只有一号选手和四号选手没比赛，那就让他们比，同理还有2和5，3和6，推出如下图【左图】</li><li>再来分析【右图】，第一行由于（1 5）（1 6）没比赛，后面就填他们，对应的也有（5 1）（6 1），再看第二行可以是（2 4）（2 6），由于6在第五天和1比赛了，所以应该是先填（2 6）然后（2 4），对应的也有（6 2）（4 2）；后面同理。</li></ul><blockquote><p>其实我感觉这个就是找规律好吗，<del>和分治法有“桃子”关系</del> </p></blockquote><p><img src="https://img-blog.csdnimg.cn/20191024232029757.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="找规律"></p><h3 id="3-n为奇数"><a href="#3-n为奇数" class="headerlink" title="3. n为奇数"></a>3. n为奇数</h3><ul><li>考虑到题目中有n天时间比赛，自然想到n = 4 的情况（看下图）</li></ul><blockquote><p> 这个是4个人比赛3天的情况，现在如果只有3个人，那么岂不是正好是3天，我们仅仅需要将其中的4改变为0（看下图），代表选手那天空闲就可</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20191024224244591.PNG" alt="n = 4">                            <img src="https://img-blog.csdnimg.cn/20191024225923228.PNG" alt="n = 3"></p><ul><li>其实对于一般的奇数，我们都可以转换成相应的n + 1，变成偶数再分治求解，最终递归到尽头就是n = 3（然后我们回到第二问）</li></ul><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">//n为奇数时候的输出</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                    cout <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>  cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> n<span class="token punctuation">)</span>                    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                <span class="token keyword">else</span>                    cout <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token comment">//n为偶数时候的输出</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>                    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                <span class="token keyword">else</span>                    cout <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">//cout &lt;&lt; m &lt;&lt; endl;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            a<span class="token punctuation">[</span>i <span class="token operator">+</span> m<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> m<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//右下角</span>            a<span class="token punctuation">[</span>i <span class="token operator">+</span> m<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> m<span class="token punctuation">;</span>  <span class="token comment">//左下角</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> m<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> m<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//右上角</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">copyodd</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> m <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 4 5 6</span>        b<span class="token punctuation">[</span>m <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 4 5 6</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token comment">//改写左上角和填写右下角</span>        <span class="token punctuation">{</span>   <span class="token comment">//这里如果你硬要说什么解释的话，我也说不出啥来，我看来就是找规律</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> m<span class="token punctuation">)</span>             <span class="token punctuation">{</span>                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                a<span class="token punctuation">[</span>m <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> m<span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> a<span class="token punctuation">[</span>m <span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> m<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">//填写右上角和对应的右下角</span>        <span class="token punctuation">{</span>   <span class="token comment">//这里我当时是把 n = 6作为特例带进去一个一个是试出规律来的</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>b<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">makecopy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">copyodd</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">copy</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">tourna</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">tourna</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//奇数+1变成偶数</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tourna</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//分治</span>    <span class="token function">makecopy</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    cin <span class="token operator">&gt;&gt;</span>n<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token operator">*</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//分配空间</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">tourna</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">output</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token operator">*</span>n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//delete空间</span>        <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>a<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 分治法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Qt】运行qt生成的exe文件报“无法找到Qt5network.dll等组件”“无法找到入口”的问题</title>
      <link href="chang-jian-bao-cuo/d47d18d8b526.html"/>
      <url>chang-jian-bao-cuo/d47d18d8b526.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><p>我在Qt creator上面构建好项目之后生成了exe文件（在debug中），我想直接在qt creator之外运行时候就报“什么缺少一些插件的错误”，我查了一些资料，说是要设置什么环境变量path，然后我也设置了好了，如下：<br><img src="https://img-blog.csdnimg.cn/20190502175006195.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="添加环境变量path"><br> 然后我就运行，也是报错什么“无法找到入口”：如下（有几个错误，弄一个）<br> <img src="https://img-blog.csdnimg.cn/20190502175307908.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="无法找到入口"><br>然后查了一些资料之后说是要把那个环境变量放到上面几个（为了一次成功，<strong>我直接把那个环境变量置顶</strong>）<br><img src="https://img-blog.csdnimg.cn/20190502175634356.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="🔝环境变量"><br>然后保存好设置之后就可以运行了。</p>]]></content>
      
      
      <categories>
          
          <category> 常见报错 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
