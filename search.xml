<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2022总结</title>
      <link href="sheng-huo-sui-bi/7c47771eecff.html"/>
      <url>sheng-huo-sui-bi/7c47771eecff.html</url>
      
        <content type="html"><![CDATA[<h2 id="2022总结"><a href="#2022总结" class="headerlink" title="2022总结"></a>2022总结</h2><p>今天是2022年12月30日晚上7点左右，想了一想，还是写一个年终总结吧。总的来说这年过得不是那么如意，有一种“向死而生”的感觉。</p><p>上半年研一下，实验室摸鱼了大半年，一直在做一些调研工作，6月开始刷题。下半年研二上，找到了努力的方向并一直在准备。总的来说这一年前半年就是“摸爬滚打”混日子，后半年就是“艰苦奋斗”寻方向。</p><h3 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h3><p><strong>1月 &amp;&amp; 2月</strong></p><p>我记得是1月上旬放寒假回家了，那时候也写了2021年的年终总结。1月份以及二月份都是在家度过的，中间过了一个年，当时还挺快乐，过年的时候和几个表弟一起打打麻将，看看电影，过年期间大概玩了一周左右吧。</p><p>之后都是每周固定的组会，因为开学的时候华为的项目也要结项了，所以那段时间的实验室活都是弄华为项目的那个系统，我这边主要就是负责视野预测的部署上线，其实总的来说写的还算顺利，主要是Flask后端加一些前端的代码。对了这期间还完善了去年年底写的 J-NaNA 论文，记得是1月份就见刊发表了。然后还帮路哥看看了 ABR 部分相关论文（之后去学校要写一个 MM），主要是用联盟博弈实现的码率自适应算法。</p><p><strong>3月 &amp;&amp; 4月</strong></p><p>这两个月主要是两个事情：一是华为项目的结尾验收，而是帮杨老师写 MM</p><p>我记得是2月底3月初就去了学校，当前其实华为的项目在家基本上就做的差不多了，去学校之后也就是一些收尾工作，所以那段时间也不是很忙。当时好像还收到去年提交的 ICME 论文的结果，结果挺好的（中了，好像是5|4|5|5分），之后也花了点时间弄那个 camera-ready。所以随之而来的就是杨老师那边让我和路哥帮他写一篇论文：ABR 为主体，FoV部分为辅。</p><p>开始一周左右都在想怎样弄一个全新的视野预测框架中，但是想了想时间可能不太够，就在之前那个 ICME 的基础上改改吧，加一个原始的视频帧以及改改参数吧，画画图就这样吧。而且本来论文的主体就是联盟博弈实现的码率自适应部分。最后大概是4月中下旬的时候提交了 MM 论文（不过估计也不太可能中）。</p><p><strong>5月 &amp;&amp; 6月</strong></p><p>论文写完之后就是忙实验室项目的调研了，就是和电信研究院的合作，初期就是一些调研工作。记得5月份的北京疫情很严重，五一小长假整个都是封校状态，当时学校里还有“草地音乐节”等等一系列封校活动~~不过我也没怎么去，可能是不太愿意凑热闹吧。</p><p>记得5月初时候还指导完 zzc 学弟完成了国院的答辩，主要是指导他做显著性方面的实验。当时目哥还和我这边有一些交流，准备是扩一扩 ICME，当时我还跑了跑显著性实验，不过由于之后实验室的活有点多，之后的交流也就搁置了（现在看来那些跑的实验还是有点用的，用在了之后写的IWCMC上）。</p><p>当时6月初的时候好像回家了，因为北京的疫情太严重了，学校乘着窗口期赶我们回家了，“点对点回家”：从学校坐校车去车站，到家之后村里从车站接回家。好在学回家之后没有集中隔离，就居家7天健康监测。之后就开始大概3个月的居家办公。</p><p>最后好像是从6月下旬开始刷力扣的，因为当时回家之后多了一些自己支配的时间，当时也像准备准备找工作方面的东西了。</p><p><img src="https://s2.loli.net/2022/12/31/6JlLfd7SRHqBmZP.png" alt="leetcode"></p><h3 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h3><p><strong>7月 &amp;&amp; 8月</strong></p><p>这两个月主要是就是实验室的一些“杂活”，还有就是刷每日一题。</p><p>实验室的杂活就是和电信研究院那边的交流，什么QUIC调研，单组播调研等等。然后后来和华为的交流又来了，华为那边主要是关于 3D 会议场景的搭建，使用 WebRTC 协议传输音视频，然后结合 VR 来构建一些虚拟会议场景，当时我这边就学了一点关于 A-Frame 框架来学着搭一搭 VR 场景，然后也看了看 Networked-AFrame 这个 VR 场景更新同步库，当时这些东西学起来是比较费时间的，而且感觉对自己找工作也没有多大帮助，所以当时也就是边看这个边刷着题。另外7月底8月上旬还把之前没中的 MM 改了改投了 Infocom（吐槽一下 edas 系统真难用…）</p><p>除了刷题之后当时也像找一些 CPP 实际项目自己啃一啃，大致了解了一些什么 WebServer 服务器、muduo 网络库、leveldb 数据库等等，但也就是了解了一下，你说真真啃进去也是挺难的，就是感觉无法下手，主要是没有一个大致的方向…所以也就搁置了，当时刷着力扣的同时也看看一些 C++ 11 语法新特性，也在维护这 C++ Interview 这个仓库：<a href="https://github.com/EricPengShuai/Interview">https://github.com/EricPengShuai/Interview</a></p><img src="https://img-blog.csdnimg.cn/img_convert/552c0f5e964e20b7f9790394cd1c2eb9.png" alt="logo" style="zoom:50%;"><p>反正当时的一个整体状态就是边刷着题，边看看实验室项目，主要是自己要学点东西进去，学点对找工作有帮助的东西，对了当时还参加了字节的一个“青训营”，参加的是一个“Android开发”的小组，就是上上一些 Android 的基础课然后做一个“抖音”项目，当时也没怎么做（跟了一个大佬，全程大佬带飞做完最后还获奖了），主要是自己主要准备 CPP 方面的知识。</p><p><strong>9月 &amp;&amp; 10月</strong></p><p>8月下旬就回到了学校，当时因为疫情好多同学还没法回来。整个9月好像也没有什么进展，就是看看 WebRTC，学学 NAF，还有在电信那边服务器上部署之前全景视频传输系统，他们说要测什么指标，这一部署就一发不可收拾，一直提出一些需要，什么测试工具，支持并发的开发，内存泄漏的维护等等。回到学校之后的开始一段时间也在写一些算法博客：<a href="https://blog.csdn.net/miracle_ps/category_9859223.html%EF%BC%8C%E5%BD%93%E6%97%B6%E5%A5%BD%E5%83%8F%E8%BF%98%E7%9C%8B%E4%BA%86%E7%82%B9">https://blog.csdn.net/miracle_ps/category_9859223.html，当时好像还看了点</a> CMU 15-445 课程，但也没有坚持下来，总是被一些杂七杂八的事情打断…</p><p>10月就开始忙碌起来了，也不是什么找工作上的，就是开始做电信那边提出的单组播系统架构了。还好那边要求的语言是 C++，正好和我的语言栈相契合，所以做这个系统的过程中也能学一点 C++ 的知识，当时刚开始看的“入坑项目”就是一个 RTSP 服务器，了解了 RTP RTSP 基本原理。10月下旬也开始了奖学金的评定，开始我以为凭着 J-NaNA 期刊（一作）和 ICME B会（二作）可以拿到国奖的，看来是我想多了，最后连一个最低级的企业奖都没拿到，主要的原因就是 J-NaNA 连 EI 都还不是，没想到啊，连 NaNA 都还不如，最好真的是我想多了，听意难平的，还不如发一个 NaNA。而且之后杨老板说你这个最好还发一篇 EI，因为你毕业的时候这个 J-NaNA 可能还不是 EI，最后盲审可能不好说，当时听到这个真是有点急了，也有点不爽吧，感觉自己被骗了…</p><p><strong>11月 &amp;&amp; 12月</strong></p><p>11 月感觉过的很快又感觉很漫长，10月底好像也过了一个生日，当时“请”宿舍同学一起出去吃个饭，但是第二天我竟然发另一个群收款（因为当时我想的是路哥那份我请了，另外也算这和卓远一起过生日，而且想着之后可能需要有大笔花销买个 14 pro，所以当时脑门一热就发了，虽然每个人只收了70吧，但是之后一想起来就感觉很尴尬），唉，之后注意吧，本来就是我请大家吃饭，还收了大伙的部分AA，不想了越想越尴尬…</p><p>11月中下旬收到了自己买的 iPhone 14 pro，pdd 8399 下单的，还好没翻车，好像最近几年的苹果产品都是在 pdd 买，百亿补贴认准了之后还是挺香的…</p><p>11月30号我们楼层出另一个阳性，噩梦就开始来了，我们那一层按照“十字分割法”拉了几个宿舍区沙河健康驿站隔离了，我们宿舍也不例外，也有过反抗，但也无济于事，不然的话我11月底就回家了（当时学校的返乡政策也出了）</p><p>12月初我就在沙河那边隔离，好像隔离了6天吧，随着疫情的二十条以及最后的新十条，全国越来越放开。我一隔离结束就订票回去了（中间来回改了4-5次车票，航班基本不飞），12月7号晚上到岳阳站的，到了之后打车回家，8号凌晨才到家，最后回家之后1点多才睡下</p><p>好像是回家第一天也就是8号左右吧，新十条发布了，回家也不做核酸了，很庆幸在高铁上没有感染（当时紧张的真是连口罩都没摘，水都没喝），在家隔离了7天之后也就正常生活了。但随着政策的放开，我们村里的阳性感染者也在不断出现，周围连着好几户人家都中招了，最后病毒也没放过我们家，20号晚上爷爷开始发烧38°，最后果不其然第二天抗原阳了，最后一家人都感染了。好在爷爷奶奶的症状都还好，没有我的重，我目前还在咳嗽：</p><p><img src="https://s2.loli.net/2022/12/30/3CG64RTnBgAiWOk.png" alt="新冠症状"></p><p>不过总的来说还是有点难受的，真的很担心家里老人抗不过去，现在奶奶还没有完全恢复，身上有点没劲，这几天我也在网上看血氧仪，因为我看网上说老人有静默型缺氧，还是有点担心的。可是真的不好买啊（康泰的预约基本上抢不到，鱼跃的又太坑），看了看就在网上买另一个华为手环测测老人的心率血压啥的，但是应该没有指压式的血氧仪准确，但是我一想着手环还可以监测睡眠啥的，就买了一个，先用着看看，然后看看血氧仪抢不抢得到。</p><p>就先写这么多吧，内心想法还有很多，就不再这里一一写了，主要是这一个月以来心理的打击有点大，总的来说这半年是“向死而生”</p><p><img src="https://s2.loli.net/2023/01/02/rxWHpyFMNgPS4ws.png" alt="2022.png"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>关于爱情，有时也在考虑，会在社交软件上看看，但是这东西真说不好，也聊了几个，但是感觉也没那么愉快…再看看吧，虽然有的时候也会着急，但是忙起来时也没那么往这方面想…</p></li><li><p>关于运动，今年主要就是羽毛球、健身、足球。健身是从今年才开始的，上半年办了张季卡去了大概一个多月健身房吧（后来因为疫情退了），下半年也办了张季卡并且坚持了一两个月吧，练了练腿、胸、背、肱二、肱三、腹等等，但是效果嘛…</p></li><li><p>关于生活，今年给自己换一部手机 iPhone 14 Pro，主要就是想用用苹果的生态，pdd 500优惠券安全下车，不过最近看14pro又降价… 理财真的是一年下来还不如余额宝和货币，一年的白酒和医疗都是绿色的，年底的债基都不断下跌，最终割了白酒，债基是割了之后又入了，总之就是割啥涨啥…</p></li><li><p>关于工作，马上开过年也要找实习了，所以这段时间也比较着急，项目也要做，每周还要开会。上周刚弄完论文（之前显著性那个），抓紧弄完吧也不太拖太久，以后还要看看八股文了，关于项目也是挺头大，现在电信那个系统开发起来还有点障碍，以后面试还要好好准备下项目…</p></li><li><p>关于人生，其实这一年还是挺魔幻的：年初的“浑水摸鱼”，心态摆烂；年中的着手刷题，寻找方向；年后的“认清现实”，学会接受。这些无一不是在“教我生活“，也许人的一生就是这样吧…</p></li></ul><div align="right">    <b>ericps 写于 2022.12.30 晚</b></div>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】二叉树路径问题深入浅出，一文吃透！</title>
      <link href="suan-fa/65c543f63eb3.html"/>
      <url>suan-fa/65c543f63eb3.html</url>
      
        <content type="html"><![CDATA[<h2 id="【LeetCode】二叉树路径问题总结"><a href="#【LeetCode】二叉树路径问题总结" class="headerlink" title="【LeetCode】二叉树路径问题总结"></a>【LeetCode】二叉树路径问题总结</h2><blockquote><p>原文同步在：<a href="https://github.com/EricPengShuai/Interview/blob/main/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98.md">https://github.com/EricPengShuai/Interview/blob/main/algorithm/二叉树路径问题.md</a></p></blockquote><h3 id="0-引言"><a href="#0-引言" class="headerlink" title="0. 引言"></a>0. 引言</h3><p>二叉树路径问题就是解决从一个节点出发寻找某个路径或者到某一个节点，以满足题目要求。核心就是二叉树遍历问题，总的来说就是<strong>深度优先遍历</strong>（DFS）和<strong>广度优先遍历</strong>（BFS），更具体来说前者就是<strong>递归</strong>，后者就是<strong>迭代</strong>。</p><h3 id="1-问题分类"><a href="#1-问题分类" class="headerlink" title="1. 问题分类"></a>1. 问题分类</h3><p>按照 <a href="https://leetcode.cn/u/eh-xing-qing/">星晴pro</a> 大佬的整理，路径问题大致可以分为两类：</p><h4 id="1-1-自顶向下"><a href="#1-1-自顶向下" class="headerlink" title="1.1 自顶向下"></a>1.1 自顶向下</h4><p>从某一个节点（不一定是根节点），从上向下寻找路径，到某一个节点（不一定是叶节点）结束，解决此类问题往往使用 DFS 和 BFS，一般来说 DFS 代码更加简洁。</p><p><strong>DFS 模板</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> res<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> path<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 加入节点</span>    path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token operator">-&gt;</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 继续递归</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 指定路径和</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> path<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 处理节点</span>    sum <span class="token operator">-=</span> root<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>    path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token operator">-&gt;</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>root<span class="token operator">-&gt;</span>right <span class="token operator">&amp;&amp;</span> sum <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 继续递归</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>这类题型DFS注意点：</strong></p><ol><li><p>如果是找路径和等于给定 target 的路径的，那么可以不用新增一个临时变量cursum来判断当前路径和，只需要用给定和 target 减去节点值，最终结束条件判断 <code>target==0</code> 即可</p></li><li><p>是否要回溯：二叉树的问题大部分是不需要回溯的，原因如下：<strong>二叉树的递归部分：dfs(root-&gt;left),dfs(root-&gt;right)已经把可能的路径穷尽了</strong>，因此到任意叶节点的路径只可能有一条，绝对不可能出现另外的路径也到这个满足条件的叶节点的</p><p>而对比<strong>二维数组(例如迷宫问题)的 DFS</strong>，for循环向四个方向查找每次只能朝向一个方向，并没有穷尽路径，因此某一个满足条件的点可能是有多条路径到该点的，并且visited数组标记已经走过的路径是会受到另外路径是否访问的影响，这时候必须回溯</p></li><li><p><strong>找到路径后是否要return</strong>：取决于题目是否要求找到叶节点满足条件的路径，如果必须到叶节点，那么就要return; 但如果是到任意节点都可以，那么必不能return,因为这条路径下面还可能有更深的路径满足条件，还要在此基础上继续递归</p></li><li><p>是否要双重递归（即调用根节点的dfs函数后，继续调用根左右节点的pathsum函数）：看题目要不要求从根节点开始的，还是从任意节点开始</p></li></ol><p><strong>BFS 模板</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">bfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> res<span class="token punctuation">;</span>    <span class="token comment">// 维护两个队列：节点队列和数组队列</span>    queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">&gt;</span> qu_node<span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> qu_path<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    qu_node<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    qu_path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>qu_node<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> qu_node<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> path <span class="token operator">=</span> qu_path<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        qu_node<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        qu_path<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token operator">-&gt;</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// 注意这里需要一个副本，为了左右子树都使用这个 path</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> tmp <span class="token operator">=</span> path<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                qu_node<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                qu_path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                qu_node<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                tmp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                qu_path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>力扣中类似题目整理如下：</p><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></td><td>BFS代码比较复杂，DFS简练</td><td><a href="https://leetcode.cn/problems/binary-tree-paths/solution/er-cha-shu-de-suo-you-lu-jing-by-leetcode-solution/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/paths-with-sum-lcci/">面试题 04.12. 求和路径</a></td><td>没有要求起点和终点，需要使用双重DFS</td><td><a href="https://leetcode.cn/submissions/detail/358317287/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></td><td>简单DFS</td><td><a href="https://leetcode.cn/submissions/detail/358318248/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></td><td>BFS 挺好理解的，DFS 模板不需要回溯但不能用引用</td><td><a href="https://leetcode.cn/problems/path-sum-ii/solution/lu-jing-zong-he-ii-by-leetcode-solution/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></td><td>双重DFS</td><td><a href="">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/smallest-string-starting-from-leaf/">988. 从叶结点开始的最小字符串</a></td><td>DFS 不能引用传参</td><td><a href="https://leetcode.cn/submissions/detail/358344110/">解</a></td></tr></tbody></table><h4 id="1-2-非自顶向下"><a href="#1-2-非自顶向下" class="headerlink" title="1.2 非自顶向下"></a>1.2 非自顶向下</h4><p>设计一个辅助函数 <code>maxpath</code>，调用自身求出以一个节点为根节点的左侧最长路径 <code>left</code> 和右侧最长路径<code>right</code>，那么经过该节点的最长路径就是 <code>left+right</code><br>接着只需要从根节点开始dfs,不断比较更新全局变量即可</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">maxPath</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token comment">// 以root为路径起始点的最长路径</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">maxPath</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">maxPath</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> left <span class="token operator">+</span> right <span class="token operator">+</span> root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新全局变量  </span>    <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 返回左右路径较长者</span><span class="token punctuation">}</span></code></pre><p>这类题型DFS注意点：</p><ol><li>left，right 代表的含义要根据题目所求设置，比如最长路径、最大路径和等等</li><li>全局变量 res 的初值设置是 0 还是 INT_MIN 要看题目<strong>节点是否存在负值</strong>，如果存在就用 INT_MIN，否则就是 0</li><li>注意两点之间路径为1，因此一个点是不能构成路径的</li></ol><p>力扣中类似题目整理如下：</p><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></td><td>内部最大路径要包含当前子树的根节点，外部返回结果只能选择一个分支的最大值返回</td><td><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/solution/shou-hui-tu-jie-hen-you-ya-de-yi-dao-dfsti-by-hyj8/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/longest-univalue-path/">687. 最长同值路径</a></td><td>DFS 返回的值就是左右子树同值路径中最大的</td><td><a href="https://leetcode.cn/submissions/detail/358214147/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></td><td>不能直接判断根节点是否为空，因为单个节点提供的路径也为0，当然也可以理解成高度问题</td><td><a href="https://leetcode.cn/submissions/detail/358906228/">解1</a> <a href="https://leetcode.cn/problems/diameter-of-binary-tree/solution/hot-100-9er-cha-shu-de-zhi-jing-python3-di-gui-ye-/">解2</a></td></tr></tbody></table><h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h3><p>二叉树的所有遍历问题无非就是 DFS 和 BFS，DFS 代码简单但是递归理解起来有些许复杂，写递归不能自己陷到递归栈里面去，需要仔细分析题意，搞清楚递归的三步走策略：</p><ol><li>知道递归出口是什么，一般而言有如：<code>root == nullptr</code></li><li>明白递归的时候做什么，也就是处理左右子树时需要怎样维护我们需要的结果</li><li>明确递归的返回值是什么，也就是对 DFS 而言的返回值，一般而言就是贡献给父节点的中间结果</li></ol><h3 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h3><ul><li><a href="https://leetcode.cn/problems/longest-univalue-path/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-94j7/">一篇文章解决所有二叉树路径问题（问题分析+分类模板+题目剖析）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】差分数组深入浅出，一文吃透！</title>
      <link href="suan-fa/9c1c32b3eab8.html"/>
      <url>suan-fa/9c1c32b3eab8.html</url>
      
        <content type="html"><![CDATA[<h2 id="【LeetCode】差分数组"><a href="#【LeetCode】差分数组" class="headerlink" title="【LeetCode】差分数组"></a>【LeetCode】差分数组</h2><blockquote><p>原文同步在：<a href="https://github.com/EricPengShuai/Interview/blob/main/algorithm/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84.md">https://github.com/EricPengShuai/Interview/blob/main/algorithm/差分数组.md</a></p></blockquote><h3 id="0-概念"><a href="#0-概念" class="headerlink" title="0. 概念"></a>0. 概念</h3><p>区间更新问题除了最适用的线段树维护之后，还可以使用差分数组维护，顾名思义，差分数组元素就是原数组中两个元素之差，例如假设原数组为 <code>arr=[7, 1, 5, 6, 3, 2, 4, 8]</code>，那么查分数组就是 <code>arr1=[0, -6, 4, 1, -3, -1, 2, 4]</code>，arr1[0] 默认为 0，如下图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dbd3d9bfe45c8187213c84cd081b0125.png" alt="差分数组"></p><p>差分数组是把原数组中后一个元素减前一个元素的差构成一个新的数组，作为辅助数组使用。具体来说：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// nums 是原数组，diff 是差分数组</span>diff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>diff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>diff<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> diff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> diff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span>  diff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> diff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> diff<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span>  diff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> diff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> diff<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h3 id="1-应用"><a href="#1-应用" class="headerlink" title="1. 应用"></a>1. 应用</h3><p>一般来说，将原数组 nums 中 [0, 3] 的值都加2，我们需要遍历对应区间：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>但是使用差分数组我们就只需要更新端点就可以了：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">diff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// 0 往后的所有值都加 2</span>diff<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// 4 往后的所有值都减 2</span></code></pre><p>这样就省去了遍历操作，因为原数组的值可以通过差分数组两端的数求得。</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h3><p>以 <a href="https://leetcode.cn/problems/my-calendar-iii/">732. 我的日程安排表 III</a> 为例，我们维护<strong>有序的STL map</strong>，因为我们还原数组时候需要从头开始，是有顺序的，也就是使用 map 代替了数组，注意初始数组都为0，每次 book 都需要将区间内元素加1表示预定次数，然后求得区间元素最大值即为所求</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyCalendarThree</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">MyCalendarThree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">book</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">// 注意题目中是前开后闭区间</span>        diff<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// start 开始的值都加 1</span>        diff<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>   <span class="token comment">// end 开始的值都减 1</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>kv <span class="token operator">:</span> diff<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cur <span class="token operator">+=</span> kv<span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token comment">// 还原原数组，由于初始值都是0所以这里就只是加差分值</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 求预定次数的最大值</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> diff<span class="token punctuation">;</span> <span class="token comment">//差分数组</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">/** * Your MyCalendarThree object will be instantiated and called as such: * MyCalendarThree* obj = new MyCalendarThree(); * int param_1 = obj-&gt;book(start,end); */</span></code></pre><p>另外类似题还有：</p><ul><li><p><a href="https://leetcode.cn/problems/my-calendar-i/">729. 我的日程安排表 I</a></p></li><li><p><a href="https://leetcode.cn/problems/my-calendar-ii/">731. 我的日程安排表 II</a></p></li></ul><h3 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h3><ul><li><a href="https://leetcode.cn/problems/my-calendar-iii/solution/c-by-li-zhi-chao-4-k89h/">C++ 差分数组，注释详细</a></li><li><a href="https://leetcode.cn/problems/my-calendar-iii/solution/wo-de-ri-cheng-an-pai-biao-by-jiang-hui-yac60/">我的日程安排表 III【差分数组+线段树动态开点(带lazy)】</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 差分数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】线段树深入浅出，一文吃透！</title>
      <link href="suan-fa/7f2e4d9cef89.html"/>
      <url>suan-fa/7f2e4d9cef89.html</url>
      
        <content type="html"><![CDATA[<h2 id="【LeetCode】线段树"><a href="#【LeetCode】线段树" class="headerlink" title="【LeetCode】线段树"></a>【LeetCode】线段树</h2><blockquote><p>本文大部分内容来自 <a href="https://leetcode.cn/link/?target=https://lfool.github.io/LFool-Notes/algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%AF%A6%E8%A7%A3.html">LFool⚡</a> 的力扣题解：<a href="https://leetcode.cn/problems/my-calendar-ii/solution/by-lfool-nodi/">https://leetcode.cn/problems/my-calendar-ii/solution/by-lfool-nodi/</a> </p><p>另外小部分参考 <a href="https://leetcode.cn/problems/my-calendar-iii/solution/xian-duan-shu-by-xiaohu9527-rfzj/">线段树 – 新手篇</a></p><p>在此记录只为学习留用，另外同步在个人仓库：<a href="https://github.com/EricPengShuai/Interview/blob/main/algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91.md">https://github.com/EricPengShuai/Interview/blob/main/algorithm/线段树.md</a></p></blockquote><h3 id="0-定义"><a href="#0-定义" class="headerlink" title="0. 定义"></a>0. 定义</h3><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点，**对于线段树中的每一个非叶子节点 [a, b], 它的左儿子表示的区间为 [a, (a+b)/2], 右儿子表示的区间为 [(a+b)/2+1, b]**。因此线段树是平衡二叉树，最后的子节点数目为 N，即为整个线段区间的长度。</p><p>使用线段树可以快速的查找一个节点在若干条线段中出现的次数，时间复杂度为 O(logN)，而未优化的空间复杂度为 2N，因此有时需要离散化让空间压缩</p><p><strong>线段树解决的是「区间和」问题，并且该「区间」会被修改</strong>。例如对于一个数组，多次求某个区间的和，可以使用「前缀和」实现，但是如果区间里面的元素经常变化时「前缀和」的效率就没那么高效。为此引入线段树，<strong>线段树中的每个节点代表一个区间</strong>，对于数组 <code>nums=[1, 2, 3, 4, 5]</code> 对应的线段树为：</p><p><img src="https://img-blog.csdnimg.cn/a39194386877480eb43193260904a84c.png#pic_center" alt="线段树结构"></p><p><strong>说明：</strong></p><ol><li>每个节点代表一个区间，节点的值就是该区间的和</li><li>节点的值可以根据题目要求换成自己满足<strong>「区间加法」</strong>的表示，例如<ul><li>最大公因数 GCD：总GCD = gcd (左区间GCD，右区间GCD)</li><li>最大值：总最大值 = max (左区间最大值，右区间最大值)</li></ul></li><li>有些不符合 <strong>「区间加法」</strong> 的表示需要注意，例如：<ul><li>众数：根据左右区间的众数不能求出总区间的众数</li><li>01序列的最长连续零：根据左右区间的最长连续零，没法知道总的最长连续零</li></ul></li><li>根节点代表的区间是问题的总区间，例如上图中数据的长度就是 [0, 4]</li><li>线段树是一棵近似的完全二叉树，如上图，但也有不是完全二叉树的情况</li><li>建立线段树的过程就是不断把区间<strong>「平分」</strong>的过程，直到区间长度为1</li></ol><h3 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h3><p><strong>数据结构</strong>：由于线段树是一棵近似的完全二叉树，因此可以使用二叉树的结构表示</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>           <span class="token comment">// 当前节点值</span>    Node <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span> <span class="token comment">// 左右孩子节点</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">delete</span> left<span class="token punctuation">;</span>        <span class="token keyword">delete</span> right<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>建立线段树</strong></p><ol><li><p>如果题目中给了具体的区间范围，我们可以根据范围建立线段树</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 到达叶子节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        node<span class="token operator">-&gt;</span>val <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">buildTree</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">buildTree</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 向上更新</span>    <span class="token function">pushUp</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">pushUp</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>    node<span class="token operator">-&gt;</span>val <span class="token operator">=</span> node<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>val <span class="token operator">+</span> node<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>对于没有具体范围的情况，一般只有数据的取值范围，一般都很大，可以使用<strong>「动态开点」</strong>，例如刚开始我们只知道数组的长度为5，不知道数组内每个元素的大小，元素都是一个一个添加进去的，此时需要动态开点，例如刚开始的节点就只能是 <code>[0, 4]; val = 0</code>，此时添加元素 <code>[2, 2]; val = 3</code>，线段树变为：</p><p><img src="https://img-blog.csdnimg.cn/310f91075aa9458b9da0a29c44778e25.png#pic_center" alt="动态开点1"></p><p>这里需要解释一下，如果一个节点没有左右孩子，会一下子把左右孩子节点都给创建出来，如上图橙色节点所示，具体代码可见方法 <code>pushDown()</code></p><p>两个橙色的叶子节点仅仅只是被创建出来了，并无实际的值，均为 0；而另外一个橙色的非叶子节点，值为 3 的原因是下面的孩子节点的值向上更新得到的</p><p><strong>下面给出依次添加剩余节点的过程：(注意观察值的变化！！)</strong></p><p><img src="https://img-blog.csdnimg.cn/3f91e62b8d8142499e876a23ac531414.png#pic_center" alt="动态开点2"></p></li></ol><blockquote><p>「动态开点」一般是在「更新」或「查询」的时候动态的建立节点，具体可见下面的<strong>更新</strong>和<strong>查询</strong>操作</p></blockquote><p><strong>更新线段树</strong>：将指定区间如 [2, 4] 的元素都增加1</p><p><img src="https://img-blog.csdnimg.cn/f847d1f390e3430db0a8277dbbd6c2a0.png#pic_center" alt="更新线段树"></p><p>更新的前提是查询需要更新的区间，首先查找到区间 [2, 2] 和 [3, 4]，然后更新节点，但是如果只是更新这两个节点的话也有问题，因为 [3, 3] 和 [4, 4] 也需要更新，当查询它们时才可以得到更新之后的值。</p><p>为此，我们给节点添加一个「懒惰标记」，给更新区间的对应节点添加一个懒惰标记，<strong>表示该节点所有对应的孩子节点都应该有此次更新</strong>，当向孩子节点遍历的时候会把「懒惰标记」下推给孩子节点，如果节点不存在最优孩子节点时需要创建左右孩子节点，最终我们修改 Node 的数据结构：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>           <span class="token comment">// 当前节点值</span>    <span class="token keyword">int</span> lazy<span class="token punctuation">;</span>          <span class="token comment">// 添加的懒惰标记</span>    Node <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span> <span class="token comment">// 左右孩子节点</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">delete</span> left<span class="token punctuation">;</span>        <span class="token keyword">delete</span> right<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>『下推懒惰标记』函数：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// leftNum 和 rightNum 表示左右孩子区间的叶子节点数量</span><span class="token keyword">void</span> <span class="token function">pushDown</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">int</span> leftNum<span class="token punctuation">,</span> <span class="token keyword">int</span> rightNum<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        node<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        node<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 没有标记直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>lazy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment">// 如果是「加减」更新操作就需要使用：标记值 * 子树所有叶子节点数量</span>    node<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>val <span class="token operator">+=</span> node<span class="token operator">-&gt;</span>lazy <span class="token operator">*</span> leftNum<span class="token punctuation">;</span>    node<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>val <span class="token operator">+=</span> node<span class="token operator">-&gt;</span>lazy <span class="token operator">*</span> rightNum<span class="token punctuation">;</span>    <span class="token comment">// 对区间进行「加减」的更新操作，下推懒惰标记时需要累加起来，不能直接覆盖</span>    node<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>lazy <span class="token operator">+=</span> node<span class="token operator">-&gt;</span>lazy<span class="token punctuation">;</span>    node<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>lazy <span class="token operator">+=</span> node<span class="token operator">-&gt;</span>lazy<span class="token punctuation">;</span>    <span class="token comment">// 取消当前节点的标记</span>    node<span class="token operator">-&gt;</span>lazy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>「更新最终函数」：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 在 start...end 范围内更新 l...r 区间中的每个元素，都加 val</span><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 找到满足要求的区间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> start <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">// 区间节点加上子树所有叶子节点</span>        node<span class="token operator">-&gt;</span>val <span class="token operator">+=</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> val<span class="token punctuation">;</span>        <span class="token comment">// 累计添加懒惰标记</span>        node<span class="token operator">-&gt;</span>lazy <span class="token operator">+=</span> val<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">// 下推标记，mid - start + 1 表示左孩子区间叶子节点数量，end - mid 表示右孩子区间叶子节点数量</span>    <span class="token function">pushDown</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> mid <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">-</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span>        <span class="token function">update</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;</span> mid<span class="token punctuation">)</span>        <span class="token function">update</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 向上更新</span>    <span class="token function">pushUp</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>查询线段树</strong>：查询某一个区间如 [2, 4] 的结果（图中红色标记）并返回</p><p><img src="https://img-blog.csdnimg.cn/f8429c714cf04761b4c7320988c7d9a5.png#pic_center" alt="查询线段树"></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 在区间 [start, end] 中查询区间 [l, r] 的结果，注意 [l, r] 保持不变</span><span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 区间 [l ,r] 完全包含区间 [start, end]</span>    <span class="token comment">// 例如：[2, 4] = [2, 2] + [3, 4]，当 [start, end] = [2, 2] 或者 [start, end] = [3, 4]，直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> start <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> node<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 把当前区间 [start, end] 均分得到左右孩子的区间范围</span>    <span class="token comment">// node 左孩子区间 [start, mid]</span>    <span class="token comment">// node 左孩子区间 [mid + 1, end]</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">pushDown</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> mid <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">-</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        ans <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;</span> mid<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        ans <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="2-完整模板"><a href="#2-完整模板" class="headerlink" title="2. 完整模板"></a>2. 完整模板</h3><p><strong>基于求「区间和」以及对区间进行「加减」的更新操作的常规模板</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 线段树代码</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">// node_idx 为线段树下标，从1开始取</span><span class="token keyword">void</span> <span class="token function">build_tree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> tree<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> node_idx<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//递归的出口，也就是到了叶子节点</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">[</span>node_idx<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">//找到左子树的节点(2*node_idx)</span>        <span class="token comment">//找到右子树的节点(2*node_idx+1)</span>        <span class="token keyword">int</span> left_node <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>node_idx<span class="token punctuation">,</span> right_node <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>node_idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">//将树进行分割，然后左右递归建树</span>        <span class="token function">build_tree</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> left_node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">build_tree</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> right_node<span class="token punctuation">)</span><span class="token punctuation">;</span>        tree<span class="token punctuation">[</span>node_idx<span class="token punctuation">]</span> <span class="token operator">=</span> tree<span class="token punctuation">[</span>left_node<span class="token punctuation">]</span> <span class="token operator">+</span> tree<span class="token punctuation">[</span>right_node<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 查询 [l, r] 的区间和，node_idx 从1开始</span><span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> tree<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> node_idx<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//情况一</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">&gt;</span> end <span class="token operator">||</span> r <span class="token operator">&lt;</span> start<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> start <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//情况二</span>        <span class="token keyword">return</span> tree<span class="token punctuation">[</span>node_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">//递归查询</span>        <span class="token comment">//找到左子树的节点(2*node_idx)</span>        <span class="token comment">//找到右子树的节点(2*node_idx+1)</span>        <span class="token keyword">int</span> left_node <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>node_idx<span class="token punctuation">,</span> right_node <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>node_idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">//将树进行分割，然后左右递归查询</span>        <span class="token keyword">int</span> left_sum <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> left_node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right_sum <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> right_node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> left_sum <span class="token operator">+</span> right_sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 更新指定下标 update_idx 的元素，node_idx 从1开始取</span><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> arr<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> tree<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> node_idx<span class="token punctuation">,</span> <span class="token keyword">int</span> update_idx<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//递归的出口，也就是到了叶子节点, 更新其值</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tree<span class="token punctuation">[</span>node_idx<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">//找到左子树的节点(2*node_idx)</span>        <span class="token comment">//找到右子树的节点(2*node_idx+1)</span>        <span class="token keyword">int</span> left_node <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>node_idx<span class="token punctuation">,</span> right_node <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>node_idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">//如果要更新节点在右边</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>update_idx <span class="token operator">&gt;</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">update</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> right_node<span class="token punctuation">,</span> update_idx<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">//要更新节点在左边</span>            <span class="token function">update</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> left_node<span class="token punctuation">,</span> update_idx<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//要注意更新当前节点！！！！！！</span>        tree<span class="token punctuation">[</span>node_idx<span class="token punctuation">]</span> <span class="token operator">=</span> tree<span class="token punctuation">[</span>left_node<span class="token punctuation">]</span> <span class="token operator">+</span> tree<span class="token punctuation">[</span>right_node<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">93</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">tree</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">build_tree</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"更新前的树:"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> x <span class="token operator">:</span> tree<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token comment">//更新 idx = 4的元素值为 2</span>    <span class="token function">update</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"更新后的树:"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> x <span class="token operator">:</span> tree<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"查询区间[2,4]的和为："</span> <span class="token operator">&lt;&lt;</span> <span class="token function">query</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> tree<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>基于求「区间和」以及对区间进行「加减」的更新操作，且为「动态开点」的模板</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> lazy<span class="token punctuation">;</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    Node <span class="token operator">*</span>left<span class="token punctuation">;</span>    Node <span class="token operator">*</span>right<span class="token punctuation">;</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lazy</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">SegmentTree</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    Node <span class="token operator">*</span>root<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">SegmentTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 更新 [l, r] 区间里面元素</span>    <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> start <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            node<span class="token operator">-&gt;</span>val <span class="token operator">+=</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> val<span class="token punctuation">;</span>            node<span class="token operator">-&gt;</span>lazy <span class="token operator">+=</span> val<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">// 下推懒惰标记</span>        <span class="token function">pushDown</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> mid <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">-</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span>            <span class="token function">update</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;</span> mid<span class="token punctuation">)</span>            <span class="token function">update</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pushUp</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> start <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>            <span class="token keyword">return</span> node<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">pushDown</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> mid <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">-</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span>            ans <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;</span> mid<span class="token punctuation">)</span>            ans <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">pushDown</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">int</span> leftNum<span class="token punctuation">,</span> <span class="token keyword">int</span> rightNum<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            node<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            node<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>lazy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        node<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>val <span class="token operator">+=</span> node<span class="token operator">-&gt;</span>lazy <span class="token operator">*</span> leftNum<span class="token punctuation">;</span>        node<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>val <span class="token operator">+=</span> node<span class="token operator">-&gt;</span>lazy <span class="token operator">*</span> rightNum<span class="token punctuation">;</span>        <span class="token comment">// 更新懒惰标记</span>        node<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>lazy <span class="token operator">+=</span> node<span class="token operator">-&gt;</span>lazy<span class="token punctuation">;</span>        node<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>lazy <span class="token operator">+=</span> node<span class="token operator">-&gt;</span>lazy<span class="token punctuation">;</span>        node<span class="token operator">-&gt;</span>lazy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 这里如果不是维护区间和需要注意改变</span>    <span class="token keyword">void</span> <span class="token function">pushUp</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        node<span class="token operator">-&gt;</span>val <span class="token operator">=</span> node<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>val <span class="token operator">+</span> node<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="3-常见题型"><a href="#3-常见题型" class="headerlink" title="3. 常见题型"></a>3. 常见题型</h3><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/my-calendar-i/">729. 我的日程安排表 I</a></td><td>维护<strong>区间最值</strong>并对区间进行<strong>加减更新</strong>，暴力维护，<strong>差分数组</strong></td><td><a href="https://leetcode.cn/problems/my-calendar-i/solution/by-lfool-xvpv/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/my-calendar-ii/">731. 我的日程安排表 II</a></td><td>维护<strong>区间最值</strong>并对区间进行<strong>加减更新</strong>，暴力维护，<strong>差分数组</strong></td><td><a href="https://leetcode.cn/problems/my-calendar-ii/solution/by-lfool-nodi/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/my-calendar-iii/">732. 我的日程安排表 III</a></td><td>维护<strong>区间最值</strong>并对区间进行<strong>加减更新</strong>，<strong>差分数组</strong></td><td><a href="https://leetcode.cn/problems/my-calendar-iii/solution/xian-duan-shu-by-xiaohu9527-rfzj/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a></td><td>维护<strong>区间和</strong>并对区间进行<strong>覆盖更新</strong>，参考题解的第二份cpp代码</td><td><a href="https://leetcode.cn/problems/my-calendar-iii/solution/xian-duan-shu-by-xiaohu9527-rfzj/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/number-of-recent-calls/">933. 最近的请求次数</a></td><td>维护<strong>区间和</strong>并对区间进行<strong>加减更新</strong>，直接<strong>队列</strong>就可以</td><td><a href="https://leetcode.cn/problems/number-of-recent-calls/solution/by-nehzil-9het/">解</a></td></tr></tbody></table><ul><li>对于表示为<strong>「区间和」</strong>且对区间进行<strong>「加减」</strong>的更新操作的情况，我们在更新节点值的时候『需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『需要累加』！！(这种情况和模版一致！！) 如题目 933.最近的请求次数</li><li>对于表示为<strong>「区间和」</strong>且对区间进行<strong>「覆盖」</strong>的更新操作的情况，我们在更新节点值的时候『需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『不需要累加』！！(因为是覆盖操作！！) 如题目 307.区域和检索 - 数组可修改</li><li>对于表示为<strong>「区间最值」</strong>且对区间进行<strong>「加减」</strong>的更新操作的情况，我们在更新节点值的时候『不需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『需要累加』！！ 如题目 729.我的日程安排表 I、732.我的日程安排表 III</li></ul><blockquote><p>注意：对于题目 <a href="https://leetcode.cn/problems/number-of-recent-calls/">最近的请求次数</a> 和 <a href="https://leetcode.cn/problems/range-sum-query-mutable/">区域和检索 - 数组可修改</a> 可以「不用✖️左右孩子区间叶子节点的数量」</p><p>因为这两个题目是「点更新」，「点更新」和「区间更新」可以合并成一种，「点更新」就是更新长度为 1 的「区间更新」</p></blockquote><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>线段数在多次求取「区间和」问题上具有优势，但是实际面试比较难想出来，而且实际体型中使用常规的方法如暴力维护、差分数组等可能比直接维护 [0, 1e9] 上的线段树时间复杂度低，因此这个数据结构先简单了解就好，具体熟练掌握可能有点难度。</p><blockquote><p>面试中可能很难写出完整线段树，所以这类题如果可以使用差分数组的话尽量直接用差分数组来写，再不济暴力维护也不是不行</p></blockquote><h3 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h3><ul><li><a href="https://leetcode.cn/problems/my-calendar-ii/solution/by-lfool-nodi/">线段树详解「汇总级别整理 🔥🔥🔥」</a></li><li><a href="https://leetcode.cn/problems/my-calendar-iii/solution/xian-duan-shu-by-xiaohu9527-rfzj/">小虎：线段树 – 新手篇</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】字典树深入浅出，一文吃透！</title>
      <link href="suan-fa/10f45ffa0d67.html"/>
      <url>suan-fa/10f45ffa0d67.html</url>
      
        <content type="html"><![CDATA[<h2 id="【LeetCode】字典树"><a href="#【LeetCode】字典树" class="headerlink" title="【LeetCode】字典树"></a>【LeetCode】字典树</h2><p>原文地址：<a href="https://github.com/EricPengShuai/Interview/blob/main/algorithm/%E5%AD%97%E5%85%B8%E6%A0%91.md">https://github.com/EricPengShuai/Interview/blob/main/algorithm/字典树.md</a></p><h3 id="0-定义"><a href="#0-定义" class="headerlink" title="0. 定义"></a>0. 定义</h3><p>字典树又称单词查找数、前缀树、Trie [trai] 树，是一种哈希树的变种，常用于统计、排序和保存大量的字符串（也不限于字符串），所以经常被搜索引擎用于文本词频统计，很直观的用处就在我们在百度和google搜索某个词汇时往往会有“联想提示”。<strong>字典树可以利用字符串的公共前缀减少查询时间，最大限度地减小无用的字符串比较，所以查询效率比哈希树高。</strong></p><p>基本操作有：<strong>查找</strong>、<strong>插入</strong>和删除（比较少）</p><p>Trie 是一颗非典型的多叉树模型，多叉就是每个结点的分支数量可以为多个，为什么说非典型呢？因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，比如一般的多叉树的结点是这样的</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span><span class="token keyword">char</span> value<span class="token punctuation">;</span><span class="token comment">// 结点值</span>TreeNode<span class="token operator">*</span> children<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 指向孩子结点</span><span class="token punctuation">}</span></code></pre><p>Trie 的结点为</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{</span><span class="token keyword">bool</span> isEnd<span class="token punctuation">;</span><span class="token comment">// 该结点是否是一个串的结束</span>TrieNoe<span class="token operator">*</span> next<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 字母映射表</span><span class="token punctuation">}</span></code></pre><p>其中**字符映射表<code>next</code>**的用处在于TrieNode结点中不用直接保存字符值，通过包含 a-z 26个字符的字母映射表标识当前结点下一个可能出现的所有字符的链接，因此我们可以通过一个父节点来预知它所有子结点的值</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parentNode<span class="token operator">-&gt;</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        说明父结点的后一个字母不可为 ch    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        说明父结点的后一个字母可以是 ch    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们来看一个例子：对于包含三个单词 “sea”,”sells”,”she” 的字典树可以是如下的结构：</p><p><img src="https://img-blog.csdnimg.cn/3e72b1ea6ce14653962f26cf2e875836.png#pic_center" alt="Trie"></p><p>字典树中一般还有大量的空链接，因此在绘制一颗单词查找树时一般会忽略空链接，同时为了方便理解我们通常将字典树简化如下：</p><p><img src="https://img-blog.csdnimg.cn/d99f350f7378455d98c45617eb442a53.png#pic_center" alt="SimpledTrie"></p><h3 id="1-常见操作"><a href="#1-常见操作" class="headerlink" title="1. 常见操作"></a>1. 常见操作</h3><p><strong>定义类</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>vector<span class="token operator">&lt;</span>TrieNode<span class="token operator">*</span><span class="token operator">&gt;</span> next<span class="token punctuation">;</span>    <span class="token keyword">bool</span> isEnd<span class="token punctuation">;</span>    <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">isWord</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">children</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>  <span class="token comment">// 手动释放内存</span>    <span class="token operator">~</span><span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> n <span class="token operator">:</span> next<span class="token punctuation">)</span>            <span class="token keyword">delete</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token comment">// 插入和查询操作</span><span class="token punctuation">}</span></code></pre><p><strong>插入</strong></p><p>目的：向 Trie 中插入一个单词 word</p><p>实现：和链表类似，首先从根结点的子结点开始与 word 第一个字符进行匹配，一直匹配到前缀链上没有对应的字符，此时开始<strong>不断开辟新的结点</strong>，直到插入完 word 的最后一个字符，同时还要**将最后一个结点 <code>isEnd = true</code>**，表示它是一个单词的末尾</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>string word<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Trie<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token operator">:</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>next<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          node<span class="token operator">-&gt;</span>next<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">new</span> <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      node <span class="token operator">=</span> node<span class="token operator">-&gt;</span>next<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  node<span class="token operator">-&gt;</span>isEnd <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>查找</strong></p><p>目的：在 Trie 中查找某个单词 word</p><p>实现：从根结点的子结点开始，一直向下匹配即可，<strong>如果没有匹配完就出现结点值为空，返回 <code>false</code>；如果匹配到最后一个字符，直接判断结点 <code>node-&gt;isEnd</code></strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">search</span> <span class="token punctuation">(</span>string word<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Trie<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token operator">:</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node <span class="token operator">=</span> node<span class="token operator">-&gt;</span>next<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> node<span class="token operator">-&gt;</span>isEnd<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>前缀匹配</strong></p><p>目的：判断 Trie 中是否有以 prefix 为前缀的单词</p><p>实现：和 <code>search</code> 操作类似，只是不需要判断最后一个字符结点的 <code>isEnd</code>，因为既然能匹配到最后一个字符，那后面一定有单词是以它为前缀的</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">startsWith</span><span class="token punctuation">(</span>string prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Trie<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node <span class="token operator">=</span> node<span class="token operator">-&gt;</span>next<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>总结</strong></p><p>Trie树 的宗旨是 <strong>一次建树，多次查询</strong>，具有如下特点</p><ul><li><strong>形状唯一</strong>： Trie 的形状和单词的插入或删除顺序无关，也就说对于任意给定的一组单词，Trie 的形状都是唯一的</li><li><strong>查询次数与单词长度相关</strong>：查找或插入一个长度为 <code>L</code> 的单词，访问 next 数组的次数最多为 <code>L+1</code>，和 Trie 中包含多少单词无关</li><li><strong>空间复杂度高</strong>：Trie 的每个结点中都保留一个字母表，这是很耗费空间的。如果 Trie 的高度为 n，字母表大小为 m，最坏的情况是 Trie 中还不存在前缀相同的单词，那么空间复杂度就位 $O(m^n)$</li></ul><h3 id="2-扩展延生"><a href="#2-扩展延生" class="headerlink" title="2. 扩展延生"></a>2. 扩展延生</h3><p>前面说到使用字典树空间复杂度较高，因为用到了 next 数组，每个数组包含 m 个字母 （一般 <code>m=26</code>），另外 m 很大时复杂度就更大。因此可以使用哈希表来存储元素，使用哈希表代替数组进行基本操作时就需要判断是否存在对应的 key，一个很典型的题目如下：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 648.单词替换</span><span class="token keyword">class</span> <span class="token class-name">Trie</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> Trie <span class="token operator">*</span><span class="token operator">&gt;</span> children<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment">// 插入单词建立前缀树</span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>string word<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Trie <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">&amp;</span>c <span class="token operator">:</span> word<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cur<span class="token operator">-&gt;</span>children<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                cur<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cur<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span><span class="token string">'#'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置结束标志</span>    <span class="token punctuation">}</span>    <span class="token comment">// 查询前缀树</span>    string <span class="token function">findRoot</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>word<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        string root<span class="token punctuation">;</span>        Trie <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">&amp;</span>c <span class="token operator">:</span> word<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>children<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token string">'#'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">return</span> root<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cur<span class="token operator">-&gt;</span>children<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">return</span> word<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            root<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>children<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">replaceWords</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>dictionary<span class="token punctuation">,</span> string sentence<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Trie <span class="token operator">*</span>trie <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 建立前缀树</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>word <span class="token operator">:</span> dictionary<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            trie<span class="token operator">-&gt;</span><span class="token function">insert</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> words <span class="token operator">=</span> <span class="token function">split</span><span class="token punctuation">(</span>sentence<span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        string ans<span class="token punctuation">;</span>        <span class="token comment">// 对于 sentence 中的每个单词查询前缀</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>word <span class="token operator">:</span> words<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            ans <span class="token operator">+=</span> trie<span class="token operator">-&gt;</span><span class="token function">findRoot</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>            ans <span class="token operator">+=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// C++ split 函数</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">split</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>str<span class="token punctuation">,</span> <span class="token keyword">char</span> ch<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> ret<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">==</span> ch<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                pos<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            start <span class="token operator">=</span> pos<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">!=</span> ch<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                pos<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                ret<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> pos <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>参考：<a href="https://leetcode.cn/problems/replace-words/solution/dan-ci-ti-huan-by-leetcode-solution-pl6v/">单词替换官方题解</a></p><p><strong>另外为了方便管理内存，可以只用<a href="https://github.com/EricPengShuai/Interview/tree/main/c%2B%2B2.0#5-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">智能指针</a>加以优化，例如<a href="https://leetcode.cn/submissions/detail/351429060/">211.添加与搜索单词</a></strong></p><h3 id="3-常见题型"><a href="#3-常见题型" class="headerlink" title="3. 常见题型"></a>3. 常见题型</h3><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></td><td>最基础的构建前缀树题目：通过插入建树，查询操作</td><td><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solution/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/replace-words/">648. 单词替换</a></td><td>暴力法可以，C++需要自己写split函数，通过dictionary建树，对每个单词使用查询前缀操作</td><td><a href="https://leetcode.cn/submissions/detail/351319378/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></td><td>注意对于通配符<code>.</code>的判断最好使用<a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/comments/31808"><strong>递归回溯</strong></a></td><td><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/solution/fu-xue-ming-zhu-qian-zhui-shu-xiang-xi-r-rty2/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/map-sum-pairs/">677. 键值映射</a></td><td>前缀树叶子结点增加 val 属性记录，其实暴力哈希表更简单</td><td><a href="https://leetcode.cn/problems/map-sum-pairs/solution/jian-zhi-ying-she-by-leetcode-solution-j4xy/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/implement-magic-dictionary/">676. 实现一个魔法字典</a></td><td>暴力法，前缀树在查询必须修改一个字母时很绕</td><td><a href="https://leetcode.cn/problems/implement-magic-dictionary/comments/70533">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/prefix-and-suffix-search/">745. 前缀和后缀搜索</a></td><td>注意题目是返回具有前缀和后缀的<strong>单词在字典中的最大下标</strong></td><td><a href="https://leetcode.cn/problems/prefix-and-suffix-search/solution/qian-zhui-he-hou-zhui-sou-suo-by-jiang-h-whm9/">解</a></td></tr></tbody></table><p><strong>说明</strong>：</p><ul><li>「211.添加与搜索单词」这题如果考虑“优化内存”时，可以手动写析构函数，注释如果使用智能指针需要独占的智能指针 <code>unique_ptr</code>，而不能使用共享内存的智能指针 <code>shared_ptr</code>，另外<strong>注意，一般传参的时候用裸指针，尤其是只读情况下，很少直接传智能指针。但也非绝对，也有传智能指针的场景。</strong>传裸指针比智能指针耗时少，参考：<a href="https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/8693">https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/8693</a></li><li>对于『745.前缀和后缀搜索』需要构建一个前缀树和一个后缀树，然后另外需要维护一个<strong>下标数组</strong>用户标识具有指定前缀和后缀的单词下标，具体可以参考：<a href="https://leetcode.cn/problems/prefix-and-suffix-search/solution/qian-zhui-he-hou-zhui-sou-suo-by-jiang-h-whm9/1652146">C++ 前缀后缀树</a></li></ul><h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h3><ol><li><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solution/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/">[路漫漫我不畏] Trie Tree 的实现 (适合初学者)🌳</a></li><li><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solution/by-lfool-k6hb/">详解前缀树「TrieTree 汇总级别整理 🔥🔥🔥」</a></li><li><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/solution/fu-xue-ming-zhu-qian-zhui-shu-xiang-xi-r-rty2/">【负雪明烛】「前缀树」详细入门教程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】二分查找深入浅出，一文吃透！</title>
      <link href="suan-fa/da4545859690.html"/>
      <url>suan-fa/da4545859690.html</url>
      
        <content type="html"><![CDATA[<h2 id="【LeetCode】二分查找"><a href="#【LeetCode】二分查找" class="headerlink" title="【LeetCode】二分查找"></a>【LeetCode】二分查找</h2><blockquote><p>原文地址：<a href="https://github.com/EricPengShuai/Interview/blob/main/algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md">https://github.com/EricPengShuai/Interview/blob/main/algorithm/二分查找.md</a></p></blockquote><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ol><li>基本概念：二分查找就是从一个排好序的序列中查找一个元素，和顺序查找不同的是，二分查找通过逐步缩小搜索区间的方式将搜索范围逐渐缩小，最终定位到我们的目标值或者目标位置，<strong>在STL中，<code>lower_bound()</code> 和 <code>upper_bound()</code> 就是利用二分的思想，前者在有序数组中找到第一个大于等于的目标值的位置，后者找到第一个大于目标值的位置</strong></li><li>排版说明：<ul><li>首先是<strong>套用模板法</strong>，这个很简单，就是记住一个二分查找的模板，然后根据题意套用即可，可以解决99%的问题，但对于个别特殊的问题无法解决，主要参考的是 <a href="https://leetcode.cn/problems/search-insert-position/solution/by-carlsun-2-2dlr/">代码随想录</a> 和 <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/tu-jie-er-fen-zui-qing-xi-yi-dong-de-jia-ddvc/">图解二分</a></li><li>其次是<strong>直接分析法</strong>，这个方法需要忘记所有的模板，没有所谓的「左闭右开」「左闭右闭」的概念，重点是认真理解题意，根据题目的条件分析如何缩减区间，主要参考的是 <a href="https://leetcode.cn/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">liweiwei</a></li></ul></li></ol><h3 id="套用模板法1"><a href="#套用模板法1" class="headerlink" title="套用模板法1"></a>套用模板法1</h3><p>首先说明两个概念：</p><ol><li><p><strong>左闭右闭</strong>：搜索区间范围是 <code>[left, right]</code>，此时循环条件是<code>left &lt;= right</code>，因为<code>left == right</code>时区间也是存在的</p><p>参考代码：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// 定义target在左闭右闭的区间里，[left, right]</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> middle <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            right <span class="token operator">=</span> middle <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在左区间，在[left, middle-1]中</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            left <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在右区间，在[middle+1, right]中</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> middle<span class="token punctuation">;</span> <span class="token comment">// 数组中找到目标值的情况，直接返回下标</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">// 这里需要根据题意分析！！</span>    <span class="token keyword">return</span> right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><ol start="2"><li><p><strong>左闭右开</strong>：搜索区间范围是 <code>[left, right)</code>，此时循环条件是<code>left &lt; right</code>，因为<code>left == right</code>时区间不存在</p><p>参考代码：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// 定义target在左闭右开的区间里，[left, right) </span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> middle <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            right <span class="token operator">=</span> middle<span class="token punctuation">;</span> <span class="token comment">// target 在左区间，在[left, middle)中</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>middle<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            left <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在右区间，在 [middle+1, right)中</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> middle<span class="token punctuation">;</span> <span class="token comment">// 数组中找到目标值的情况，直接返回下标</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">// 循环结束时有 right&gt;=left，大多数情况下 left == right，但是为了不越界往往返回right</span>    <span class="token keyword">return</span> right<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="套用模板法2"><a href="#套用模板法2" class="headerlink" title="套用模板法2"></a>套用模板法2</h3><blockquote><p>统一将判断条件定位 <code>while(left &lt; right)</code>，根据划分区间的不同选择不同的模板</p></blockquote><ol><li><p><strong>模板一</strong></p><p>将区间 <code>[left, right]</code>划分为分成 <code>[left, mid]</code> 和 <code>[mid + 1, right]</code>，此时计算 mid 不需要 +1</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">bsearch_1</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token keyword">else</span> l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> l<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><ol start="2"><li><p><strong>模板二</strong></p><p>将区间 <code>[left, right]</code>划分为分成 <code>[left, mid-1]</code> 和 <code>[mid, right]</code>，此时计算 mid 需要 +1</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">bsearch_2</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span> l <span class="token operator">+</span> r <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> l <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token keyword">else</span> r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> l<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><p><strong>说明：在大多数情况下，这里使用模板一可以求出左边界，使用模板二可以求出右边界，为什么是大多数情况呢？因为有的题目很特殊需要特别注意判断条件</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">searchRange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 二分范围</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>        <span class="token comment">// 查找元素的开始位置</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> target<span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token keyword">else</span> l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">!=</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 查找失败</span>    <span class="token keyword">int</span> L <span class="token operator">=</span> r<span class="token punctuation">;</span>        l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// 二分范围</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>                   <span class="token comment">// 查找元素的结束位置</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target <span class="token punctuation">)</span> l <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token keyword">else</span> r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>L<span class="token punctuation">,</span>r<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="直接分析法"><a href="#直接分析法" class="headerlink" title="直接分析法"></a>直接分析法</h3><blockquote><p>这里需要忘记前面提到的左闭右闭和左闭右开区间，根据题意分析 right 的初始值，然后分析下一轮的搜索区间是左侧还是右侧</p><p>这里根据经验，往往设置的是<code> while(left &lt; right)</code>，因为只有这样退出循环时才有 <code>left &gt;= right</code>，往往会有 <code>left == right</code>成立， 为了不越界就使用 right 作为目标位置</p></blockquote><p><strong>常见问题</strong></p><blockquote><ol><li>二分查找不一定要求数组有序</li></ol></blockquote><p>力扣上如「山脉数组」「选择有序数组」等可以<strong>根据 <code>nums[mid]</code> 的值推测两侧元素的性质，进而缩小搜索区间</strong>，这类数组都是接近有序的数组</p><p>还有如「<a href="https://leetcode.cn/problems/find-the-duplicate-number/">寻找重复数</a>」不在输入数组上做二分，而是<strong>在输入数组的最小值 min 和最大值 max 组成的连续整数数组上查找一个数</strong>，也就是搜索区间是 <code>[min...max]</code></p><blockquote><ol start="2"><li>二分查找取 mid 时何时+1</li></ol></blockquote><p>首先何时+1何时不+1是为了避免<strong>死循坏</strong>，对于有偶数个元素的区间来说，使用 <code>mid = (left+right)/2</code> 只能取到<strong>左边的中位数</strong>，如果想要取到<strong>右边的中位数</strong>就必须+1</p><p>再来看为什么有时需要取到右边的首位数，考虑只有两个元素的区间，利用 mid 将区间分为 <code>[left, mid-1]</code> 和 <code>[mid, right]</code>时，如果不+1则无法缩减区间，进而进入死循环</p><p><strong>总结</strong></p><ul><li><p>写成 <code>while(left &lt; right)</code>，退出循环的时候有 <code>left == right</code> 成立，好处是：不用判断应该返回 left 还是 right；</p></li><li><p>区间 <code>[left..right]</code> 划分只有以下两种情况：</p><ul><li>分成 <code>[left..mid]</code> 和 <code>[mid + 1..right]</code>，分别对应 <code>right = mid</code> 和 <code>left = mid + 1</code>；</li><li>分成 <code>[left..mid - 1]</code> 和 <code>[mid..right]</code>，分别对应 <code>right = mid - 1</code> 和 <code>left = mid</code>，这种情况下。需要使用 <code>int mid = (left + right + 1) / 2</code>，否则会出现死循环，这一点不用记，出现死循环的时候，把 left 和 right 的值打印出来看一下就很清楚了；</li></ul></li><li><p>退出循环 <code>left == right</code>，如果可以确定区间 <code>[left...right]</code> 一定有解，直接返回 left 就可以，否则还需要对 left 这个位置单独做一次判断；</p></li><li><p>始终保持不变的是：在区间 <code>[left...right]</code> 里查找目标元素。</p></li></ul><h3 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h3><h4 id="1-二分求下标"><a href="#1-二分求下标" class="headerlink" title="1. 二分求下标"></a>1. 二分求下标</h4><p>在给定数组中查找符合条件的元素下标</p><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/binary-search/">704.二分查找</a></td><td>简单的二分即可，常规思路</td><td></td></tr><tr><td><a href="https://leetcode.cn/problems/search-insert-position/">35.搜索插入位置</a></td><td>找到插入位置的索引，可以是len，因此可以设置right=len</td><td><a href="https://leetcode.cn/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/longest-increasing-subsequence/solution/">300.最长上分子序列</a></td><td>这题DP思路比较简单，二分查找比较难</td><td><a href="https://leetcode.cn/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34.排序数组查找第一个和最后一个位置</a></td><td>可以总结为两个模板：<strong>查找左边界</strong>和<strong>查找右边界</strong></td><td><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/tu-jie-er-fen-zui-qing-xi-yi-dong-de-jia-ddvc/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/valid-triangle-number/">611.有效三角形的个数</a></td><td><strong>二分有两种思路</strong>：左边界和右边界，<strong>双指针</strong>：固定最长边逆序</td><td><a href="https://leetcode.cn/problems/valid-triangle-number/solution/ming-que-tiao-jian-jin-xing-qiu-jie-by-jerring/">解1</a> <a href="https://leetcode.cn/problems/valid-triangle-number/solution/er-fen-cha-zhao-python-dai-ma-java-dai-ma-by-liwei/">解2</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-k-closest-elements/">659.找到K个最接近的元素</a></td><td>二分找到左边界，双指针</td><td><a href="https://leetcode.cn/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-right-interval/">436.寻找右区间</a></td><td>使用哈希表记录第一个元素位置之后在[:][0]二分查找[:][1]</td><td><a href="https://leetcode.cn/problems/find-right-interval/solution/by-fuxuemingzhu-98m1/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-positive-integer-solution-for-a-given-equation/">1237.找出给定方程的正整数解</a></td><td>二分利用一个变量递增，双指针利用两个变量都递增</td><td><a href="https://leetcode.cn/problems/find-positive-integer-solution-for-a-given-equation/solution/xiang-jie-bao-li-er-fen-yu-shuang-zhi-zhen-fa-by-q/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4.寻找两个正序数组的中位数</a></td><td>直接归并比较简单，通过二分找到__分割线__比较难</td><td><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/he-bing-yi-hou-zhao-gui-bing-guo-cheng-zhong-zhao-/">解</a></td></tr></tbody></table><p><strong>「选择数组」和「山脉数组」：局部单调性</strong></p><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33.搜索旋转排序数组</a></td><td>直接在循环里面定位比较直接，<strong>在外面定位<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/solution/er-fen-fa-python-dai-ma-java-dai-ma-by-liweiwei141/129291">思考</a>很细节</strong></td><td><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/solution/er-fen-fa-python-dai-ma-java-dai-ma-by-liweiwei141/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">81.搜索旋转排序树组II</a></td><td>在 33 基础上通过<code>++left</code>去重，或者直接 <a href="https://leetcode.cn/submissions/detail/170342574/">while去重</a></td><td><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/solution/er-fen-cha-zhao-by-liweiwei1419/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153.旋转排列数组最小值</a></td><td>通过<strong>比较 mid 和 right</strong> 判断最小值在左还是右</td><td><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">154.旋转排序数组最小值II</a></td><td>在 153 基础上通过 <code>-- right</code> 去重</td><td><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/solution/154-find-minimum-in-rotated-sorted-array-ii-by-jyd/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/">852.山脉数组的峰顶索引</a></td><td>找到<strong>最小满足</strong> <code>nums[i] &gt; nums[i+1]</code> 的下标</td><td><a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/solution/shan-mai-shu-zu-de-feng-ding-suo-yin-by-dtqvv/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-in-mountain-array/">1095.山脉数组找目标值</a></td><td><strong>三个二分</strong>：找到峰顶下标，升序找target，降序找target</td><td><a href="https://leetcode.cn/problems/find-in-mountain-array/solution/shi-yong-chao-hao-yong-de-er-fen-fa-mo-ban-python-/">解</a></td></tr></tbody></table><h4 id="2-二分找答案"><a href="#2-二分找答案" class="headerlink" title="2. 二分找答案"></a>2. 二分找答案</h4><p>在给定的序列中找一个满足条件的答案，通过二分查找逐渐缩小范围，最后逼近到一个数</p><table><thead><tr><th>题目</th><th>说明</th><th>题解</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/sqrtx/">69.x的平方根</a></td><td>使用除法可以避免溢出，另有一个 <a href="https://leetcode.cn/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/">牛顿迭代法</a></td><td><a href="https://leetcode.cn/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287.寻找重复数</a></td><td>二分思路有点绕，<a href="https://leetcode.cn/problems/find-the-duplicate-number/solution/287xun-zhao-zhong-fu-shu-by-kirsche/">循环链表</a>思路比较直接</td><td><a href="https://leetcode.cn/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/guess-number-higher-or-lower/">374.猜数字大小</a></td><td>比较简单的二分，注意一下题意就好</td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/h-index-ii/">275.H指数 II</a></td><td>注意向左找还是向右找的条件</td><td><a href="https://leetcode-cn.com/problems/h-index-ii/solution/jian-er-zhi-zhi-er-fen-cha-zhao-by-liweiwei1419-2/">解</a></td></tr><tr><td><a href="https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold/">1283.使结果不超过阈值的最小除数</a></td><td>注意不整除才+1</td><td><a href="https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold/solution/er-fen-cha-zhao-ding-wei-chu-shu-by-liweiwei1419/">解</a></td></tr><tr><td><a href="https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/">1292. 元素和小于等于阈值的正方形的最大边长</a></td><td>二维前缀和，遍历二分</td><td><a href="https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/solution/yuan-su-he-xiao-yu-deng-yu-yu-zhi-de-zheng-fang-2/">解</a></td></tr></tbody></table><ul><li><input disabled="" type="checkbox"> 其实按照 liweiwei 的总结还有第三个题型，这里就不继续刷了，先消化消化</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实二分的题目刷多了就有经验了，最主要的分析出<strong>二分判断的条件</strong>，根据题意判断出是在左区间还是右区间查找元素。另外对于二分意图不明显的题目需要尝试分析出题目的<strong>隐藏题意</strong></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>大部分参考自：<a href="https://leetcode.cn/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">写对二分查找不是套模板并往里面填空，需要仔细分析题意</a></li><li>另模板1参考自：<a href="https://leetcode.cn/problems/search-insert-position/solution/by-carlsun-2-2dlr/">代码随想录</a></li><li>另模板2参考自：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/tu-jie-er-fen-zui-qing-xi-yi-dong-de-jia-ddvc/">图解二分</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++】lambda表达式</title>
      <link href="bian-cheng-bei-wang/868f1faa4d10.html"/>
      <url>bian-cheng-bei-wang/868f1faa4d10.html</url>
      
        <content type="html"><![CDATA[<h2 id="【C-】lambda-表达式"><a href="#【C-】lambda-表达式" class="headerlink" title="【C++】lambda 表达式"></a>【C++】lambda 表达式</h2><blockquote><p>源代码：<a href="https://github.com/EricPengShuai/Interview/blob/main/c%2B%2B2.0/lambda.cpp">https://github.com/EricPengShuai/Interview/blob/main/c%2B%2B2.0/lambda.cpp</a></p></blockquote><p>lambda 表达式C++11引入的，可以编写内嵌的匿名函数，代替独立函数等。在C++14中添加新特性，又加以强化。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 完整语法</span><span class="token punctuation">[</span> capture<span class="token operator">-</span>list <span class="token punctuation">]</span> <span class="token punctuation">(</span> params <span class="token punctuation">)</span> <span class="token keyword">mutable</span><span class="token punctuation">(</span>optional<span class="token punctuation">)</span> <span class="token keyword">constexpr</span><span class="token punctuation">(</span>optional<span class="token punctuation">)</span><span class="token punctuation">(</span>c<span class="token operator">++</span><span class="token number">17</span><span class="token punctuation">)</span> exception attribute <span class="token operator">-&gt;</span> ret <span class="token punctuation">{</span> body <span class="token punctuation">}</span> <span class="token comment">// 可选的简化语法</span><span class="token punctuation">[</span> capture<span class="token operator">-</span>list <span class="token punctuation">]</span> <span class="token punctuation">(</span> params <span class="token punctuation">)</span> <span class="token operator">-&gt;</span> ret <span class="token punctuation">{</span> body <span class="token punctuation">}</span>     <span class="token punctuation">[</span> capture<span class="token operator">-</span>list <span class="token punctuation">]</span> <span class="token punctuation">(</span> params <span class="token punctuation">)</span> <span class="token punctuation">{</span> body <span class="token punctuation">}</span>    <span class="token punctuation">[</span> capture<span class="token operator">-</span>list <span class="token punctuation">]</span> <span class="token punctuation">{</span> body <span class="token punctuation">}</span> </code></pre><p><strong>参数说明：</strong></p><ul><li><p><strong>capture-list</strong>：捕捉列表，这个不用多说，前面已经讲过，记住它不能省略；</p></li><li><p><strong>params</strong>：参数列表，可以省略（但是后面必须紧跟函数体）；</p></li><li><p><strong>mutable</strong>：可选，将<code>lambda</code>表达式标记为<code>mutable</code>后，函数体就可以修改传值方式捕获的变量；</p></li><li><p><strong>constexpr</strong>：可选，C++17，可以指定<code>lambda</code>表达式是一个常量函数；</p></li><li><p><strong>exception</strong>：可选，指定<code>lambda</code>表达式可以抛出的异常；</p></li><li><p><strong>attribute</strong>：可选，指定<code>lambda</code>表达式的特性；</p></li><li><p><strong>ret</strong>：可选，返回值类型；</p></li><li><p><strong>body</strong>：函数执行体</p></li></ul><h3 id="常见写法"><a href="#常见写法" class="headerlink" title="常见写法"></a>常见写法</h3><ol><li><p>基本表达式</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> basicLambda <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Basic Lambda Express!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">basicLambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><ol start="2"><li><p>带参数</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> add <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><ol start="3"><li><p>捕获变量</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// [] 其实就是一个闭包，用来定义捕捉模式以及变量，表示的是lambda捕捉块</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">auto</span> add_x <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">// 复制捕捉x，不可以修改x</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> multiply_x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 引用捕捉x，可以修改x</span>    <span class="token keyword">return</span> a <span class="token operator">*</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">add_x</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token function">multiply_x</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">// mutbale 关键字可以让复制捕捉方式的表示修改参数</span><span class="token keyword">auto</span> add_x_mutable <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">{</span>    x <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">add_x_mutable</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre></li></ol><ol start="4"><li><p>lambda 表达式禁用了辅助操作符，但是没有禁用复制构造函数</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// add_x_mutable 是上面定义的</span><span class="token keyword">auto</span> add_copy <span class="token operator">=</span> add_x_mutable<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">add_copy</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre></li></ol><ol start="5"><li><p>lambda 表达式作为传递的参数</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token function">count_if</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> x <span class="token operator">&gt;</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">vt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">generate</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> value <span class="token operator">=</span> b<span class="token punctuation">;</span>    b <span class="token operator">=</span> b <span class="token operator">+</span> a<span class="token punctuation">;</span>    a <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> element<span class="token operator">:</span> vt<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> element <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre></li></ol><ol start="6"><li><p>常见捕获形式</p><ul><li><p><code>[]</code>：默认不捕获任何变量；</p></li><li><p><code>[=]</code>：默认以值捕获所有变量；</p></li><li><p><code>[&amp;]</code>：默认以引用捕获所有变量；</p></li><li><p><code>[x]</code>：仅以值捕获x，其它变量不捕获；</p></li><li><p><code>[&amp;x]</code>：仅以引用捕获x，其它变量不捕获；</p></li><li><p><code>[=, &amp;x]</code>：默认以值捕获所有变量，但是x是例外，通过引用捕获；</p></li><li><p><code>[&amp;, x]</code>：默认以引用捕获所有变量，但是x是例外，通过值捕获；</p></li><li><p><code>[this]</code>：通过引用捕获当前对象（其实是复制指针）；</p></li><li><p><code>[*this]</code>：通过传值方式捕获当前对象；</p></li></ul><blockquote><p>最好不要使用 [=] [&amp;] 捕获所有变量，可能会出现悬挂引用</p></blockquote></li></ol><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><h4 id="捕捉表达式"><a href="#捕捉表达式" class="headerlink" title="捕捉表达式"></a>捕捉表达式</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">auto</span> y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>r <span class="token operator">=</span> x1<span class="token punctuation">,</span> x1 <span class="token operator">=</span> x1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    r <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x1 <span class="token operator">*</span> x1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> x1 <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">auto</span> z <span class="token operator">=</span> <span class="token punctuation">[</span>str <span class="token operator">=</span> <span class="token string">"string"</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre><h4 id="泛型表达式"><a href="#泛型表达式" class="headerlink" title="泛型表达式"></a>泛型表达式</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span>  add1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token punctuation">,</span> <span class="token keyword">auto</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span>  <span class="token function">add1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token function">add1</span><span class="token punctuation">(</span><span class="token number">2.3</span><span class="token punctuation">,</span> <span class="token number">2.3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre><h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">for_each</span><span class="token punctuation">(</span>vt<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vt<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/d686ad9de817">https://www.jianshu.com/p/d686ad9de817</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021总结</title>
      <link href="sheng-huo-sui-bi/3ed2242071f5.html"/>
      <url>sheng-huo-sui-bi/3ed2242071f5.html</url>
      
        <content type="html"><![CDATA[<h2 id="2021总结"><a href="#2021总结" class="headerlink" title="2021总结"></a>2021总结</h2><p>这一年总的来说要比2020年要好，2020年由于保研之后自己的心理斗争下半年过得很糟糕，今年继续研究生生活之后感觉也没有那么糟糕，超出了我预期的研究生生活。这里我记录一下2021生活，分为面试打工的上半年以及生活打工的下半年。</p><h3 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h3><p>2020年年末我写了一份年终总结，记得当时也是由于疫情放假比较早，12月底就回家了，当时怀着“沉重”的心情写了那份总结（在生活随笔中可以找到：<code>2020总结</code>）。2021上半年是我面试打工的半年。当时由于保研之后自己的想直接工作的心理，所以当时回家之后就 想着是在家准备面试技巧，刷题，看面经……与此同时还需要在实验室某个项目里面看看论文，做做项目。所以整个上半年就是边面试边打工的时期，虽然最后面试没有一个成功通过的<span class="github-emoji"><span>😅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，但是那段时间也是在面试实习和实验室打工之间相当矛盾！</p><p>自从学校回家之后有一直有准备面试的想法，所以2021年1月就开始着手准备了，这个博客也是当时搭建。我的实验室打工生活还要从那天一个阳光明媚的下午，那天我刚打完游戏（记得还是在幺幺家的阳台上晒着太阳），接到了杨老师的电话说：“你最近在是忙什么吗？”，我说在就在实验室华为那个项目的基础上做做毕设，然后他说：“哦，你们毕业之后就要入学了，现在我想着是和一个在清华读博后的师兄带着你和HJL看看论文，然后着手开始上手研究生生活的论文，我们就就着移动流媒体这个方向先开始读读论文，然后着手开始写！”，当时我也就随口答应了。当时事后还想着：唉，我这边的面试还要继续准备啊，又要着手干着实验室项目，真是太难了，不过还是读论文也对我的毕业设计有点帮助，就这样吧！随后我和JL就开始差不多每周一次的论文汇报工作。那段时间虽说比较难受，但是现在回过头来想想看也是有收获的，知道如何阅读论文、如何检索论文，了解到了目前我们这个方向有哪些会议和期刊可以试着看看。我当时的方向和毕设的方向也是一致：全景视频中的视野预测方向，当时也是接着论文中的方向一步一步走下去，入门了PyTorch（这里推荐一下B站刘二大人的PyTorch实践），维护了一个仓库：<a href="https://github.com/EricPengShuai/Pytorch-Learning">https://github.com/EricPengShuai/Pytorch-Learning</a> 到现在竟然有6个<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，现在也在维护，如果有自己学习PyTorch的心得也会不断的记录</p><p>上半年也坚持着在LeetCode上刷题，想着准备面试，然后暑期去实习赚点钱，所以当时在准备看论文做实验室项目的同时还需要刷刷题，看看面经，这里是我当时刷题记录：</p><img src="https://s2.loli.net/2022/01/14/lbzGSg4Z52dPTq3.png" alt="leetcodeRecord.png" style="zoom:80%;"><p>可以看到基本上做到了每天一题，后半年入学之后就没有刷了，并且之前刷的题也都忘记了。当时是3月中旬去的学校，记得我面试的公司有：字节、快手、百度等等，当时自己也在维护一个仓库：<a href="https://github.com/EricPengShuai/Interview">https://github.com/EricPengShuai/Interview</a> 记录自己的面试经历以及一些八股文，记得当时最有把握的两个面试是一个字节的火山引擎部门，一面之后HR就问我能实习多久，面试官给的反馈也比较好，但是当时自己唯唯诺诺不敢多说：两个月（那边要求是三个月及以上），所以连二面都没有就直接给我拒了；还有一个自己很有把握的面试快手的社科部门，一二面都过了，三面回答的也还行（最后被那个几个脑筋急转弯的智力题给弄崩了），随后而来的也是“很遗憾”的短信通知<span class="github-emoji"><span>😞</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f61e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>一连着准备和面试了一个多月，我的面试最终结束于百度用户质量效能部门的测试开发工程师，当时搞笑的还是那个面试官以为我是参加春招补招（6月份春招也基本结束了），谁知道我只是想找一个实习，所以进入到如流和面试官简单聊了几句之后就下了，这之后我也就没怎么准备面试了，其他时候就准备毕设论文了，记得毕设答辩时间是5月底，记得答辩那天得知到袁隆平爷爷永远的离开了我们<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><img src="https://s2.loli.net/2022/01/14/oMWBcq2NugAspPX.jpg" alt="pyq.jpg" style="zoom:80%;"><p>当时答辩之后我申请了一个优秀学士学位论文，最终获得了一个校级奖项。再然后我就毕业了，和舍友一起拍了毕业照，和好兄弟也拍了几张照，全院同学也合了照，唯一遗憾的就是没有和女同学合照🥺，再然后就毕业了，拿到了毕业证书和学士学位证书，再然后就没有然后了，然后也写一些关于本科期间的感受（在生活随笔中可以找到：<code>毕业了？</code>）</p><h3 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h3><p>2021年9月1号我们开学了，以研究生的新身份再次来到北邮。再开始来的时候以为研究生生活是“很难受”的（论文上各种吐槽加上自己心理上的低预期），但是当我自己真正经历过之后感觉也不是我想象中那么糟糕，反而超出了我的预期。</p><p><strong>9月份</strong>，开学那天忙着帮宿舍，登记信息，那天晚上和JL他们一起在新食堂四楼吃了晚饭，然后那天好像杨老师开了一个会。记得开学没几天好兄弟奔总叫我和Wei哥一起去他那吃另一个饭。之后开始了选课，上课，实验室项目等等常规的研究生生活，记得当时参加了计院的足球队，最后是进入了二队，虽然实际比赛中没能首发踢上几场，但是每次踢球的时候好开心啊<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，也是从那段时间开始我研究生生活的体育活动就丰富了起来，经常和实验室同学师兄师姐一起打打乒乓球，周二和周五晚上打打羽毛球，周末的时候被路哥带着健健身（立个Flag：下学期办卡去<span class="github-emoji"><span>😤</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f624.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，争取一周三次健身）；<strong>10月份</strong>印象最深的是我们组去了郑州“出差”，人生第一次“出差”（实际上就是做项目），我们去了河南的郑州轻工业大学，辅助那边的老师完成他们申报的一个河南省科技进步一等奖，很开心和Han哥、Feng哥、Lu哥、RenJie的一周出差生活，感觉也是从那段时间开始自己和师兄们聊得开了，也了解了同学的性格，总的来说，收获很大！最后我们10月中旬回到了学校，10月底就是参加足球赛了，虽然只作为替补上场了一次，但是也认识了很多好兄弟。<strong>11月份</strong>可能就是艺馨杯了，那也是我第一次参加这种文艺活动，虽然没有一点经验，但是还是“主演”了那个话剧（可能是研究生大家对于这种活动都不太感冒吧，当时我是想着多交几个朋友的念头去的，说白了就是结交一下），也是从那次开始我认识好几个朋友，和YunPeng逐渐熟悉了起来，认识了Li姐，LiXue，YiBing，和Jing姐也熟悉了起来……那次艺馨杯我们计院在研究生组竟然还是第一名，最后成功碰杯🎉，那晚我们几个和工作人员一起出去唱歌，吃饭（我没吃，太晚了），晚上1点多才回到学校。对了11月我还过一个很快乐的生日，又老了一岁🎂；<strong>12月份</strong>可以说是论文月和考试月，月初到月中写了一篇实验室的JNNA论文，帮助Mu哥完成了ConVLSTM的仿真，投了ICME。之后就是准备了大作业和考试了，大数据作业当时有点头秃🤯，图论考试全是选择题，感觉有点凉（到现在还没出分<span class="github-emoji"><span>😨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f628.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）……流水账记得差不多了，最后来一张照片吧</p><p><img src="https://s2.loli.net/2022/01/14/Vq1ZYCd5QPAxeE6.jpg" alt="0123.jpg"></p><p>2022年我们一起跨年了！1月4号我们成功举办了实验室的年会，很成功！</p><h3 id="来年愿望"><a href="#来年愿望" class="headerlink" title="来年愿望"></a>来年愿望</h3><ul><li>写好论文</li><li>夯实语言，准备面试</li><li>交朋友！！！谈对象</li><li>做好锻炼，健康生活</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Git】一个主机上Git同时配置两个GitHub账号</title>
      <link href="xiao-ji-qiao/adc772553d7d.html"/>
      <url>xiao-ji-qiao/adc772553d7d.html</url>
      
        <content type="html"><![CDATA[<h2 id="【Git】一个主机配置多个GitHub账号（Windows，MacOS，Linux都适用）"><a href="#【Git】一个主机配置多个GitHub账号（Windows，MacOS，Linux都适用）" class="headerlink" title="【Git】一个主机配置多个GitHub账号（Windows，MacOS，Linux都适用）"></a>【Git】一个主机配置多个GitHub账号（Windows，MacOS，Linux都适用）</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><blockquote><p>我开始的需要求是投稿论文的时候由于是<strong>匿名审稿</strong>，而我又需要上传源代码，所以打算把代码提交到GitHub上，匿名审稿不能用暴露自己个人信息的账号，所以就新建了一个账号，但是当我commit的时候发现提交人依然是自己之前的账号信息，而当我push的时候出现no permission，所以就需要配置一下新账号的信息</p></blockquote><p>我的环境是 windows 10，之前已经有了github账号，该账号的ssh已经配置，之前使用https和ssh都可以push，但是新账号没有配置所以没办法提交</p><p>下面我的方法<strong>使用ssh方式提交代码</strong>，需要配置新账号的公钥和私钥</p><h3 id="2-配置-ssh文件"><a href="#2-配置-ssh文件" class="headerlink" title="2. 配置.ssh文件"></a>2. 配置<code>.ssh</code>文件</h3><h4 id="2-1-在-ssh文件夹目录下面生成公钥和私钥"><a href="#2-1-在-ssh文件夹目录下面生成公钥和私钥" class="headerlink" title="2.1 在.ssh文件夹目录下面生成公钥和私钥"></a>2.1 在.ssh文件夹目录下面生成公钥和私钥</h4><p>windows中<code>.ssh</code>文件的路径为：<code>C:\Users\用户名\.ssh</code><br>生成公钥和私钥的命令为：<code>ssh-keygen -t rsa -f id_rsa_new</code>，然后一直按回车就可以了，这个时候会在ssh文件夹目录下面生两个文件（公钥和私钥文件），如下图（<font color="red">其中以.pub结尾的文件是公钥，没有后缀的是私钥，config是自己创建的配置文件，know_hosts好像没用？</font>）：<br><img src="https://img-blog.csdnimg.cn/img_convert/49b953ba27c07738d9e3278460cfca1e.png" alt=".ssh dir"></p><h4 id="2-2-将公钥复制粘贴到github的SSH-and-GPG-keys中"><a href="#2-2-将公钥复制粘贴到github的SSH-and-GPG-keys中" class="headerlink" title="2.2 将公钥复制粘贴到github的SSH and GPG keys中"></a>2.2 将公钥复制粘贴到github的SSH and GPG keys中</h4><ul><li>首先创建进入github的<strong>setting</strong>页面，然后点击<strong>SSH and GPG keys</strong>，新建一个<strong>SSH keys</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/3eecd5b323620612ee2847748e6e050d.png" alt="SSH"></li><li>然后随便去一个名字，将生成的**.pub公钥**粘贴到下面：<br><img src="https://img-blog.csdnimg.cn/img_convert/761d16b0f24592aeb2eb40602f0f0fb4.png" alt="SSH Add"><h3 id="3-将私钥添加到本地的git账户中"><a href="#3-将私钥添加到本地的git账户中" class="headerlink" title="3. 将私钥添加到本地的git账户中"></a>3. 将私钥添加到本地的git账户中</h3><h4 id="3-1-添加两个私钥到本地git账户"><a href="#3-1-添加两个私钥到本地git账户" class="headerlink" title="3.1 添加两个私钥到本地git账户"></a>3.1 添加两个私钥到本地git账户</h4><pre class="language-bash" data-language="bash"><code class="language-bash">ssh-agent <span class="token function">bash</span>ssh-add id_rsa_github<span class="token comment"># 之前已有的github账号信息</span>ssh-add id_rsa_new<span class="token comment"># 新生成的账号信息</span></code></pre><blockquote><p>其中<code>ssh-agent bash</code>（或<code>eval $(ssh-agent)</code>）会启动一个进程在内存里管理这些私钥，可以把它理解成一个私钥管理中心<br>添加之后可以使用<code>ssh-add -l</code>命令查看一下是否添加成功</p></blockquote></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/7487963d1a4b1c3c027c44afce8879a6.png" alt="ssh-add"></p><h4 id="3-2-创建config文件"><a href="#3-2-创建config文件" class="headerlink" title="3.2 创建config文件"></a>3.2 创建config文件</h4><p>自己在ssh文件夹新建一个txt文件，然后重命名为config，具体内容如下：<br><img src="https://img-blog.csdnimg.cn/img_convert/b9bfadd1cbeb6c7ac0c15d734a4c4838.png" alt="config"><br>config文件中部分参数含义：</p><pre class="language-none"><code class="language-none"># Host: 主机别名# HostName: 托管平台域名地址，如github.com# IdentityFile : 指明上面User对应的identityFile路径# User: 托管平台用户名# Port: 端口号，可不填（如果不是默认22号端口则需要指定）# PreferredAuthentications publickey</code></pre><h3 id="4-测试是否连通"><a href="#4-测试是否连通" class="headerlink" title="4. 测试是否连通"></a>4. 测试是否连通</h3><p>使用ssh -T测试一下：记住前面设置的<strong>hostname</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/d3fa0b1d31efb4fbf04ce40171009021.png" alt="ssh -T"><br>出现 <font color="red">“Hi ……”</font> 就说明新账号的公钥和私钥都配置成功了</p><h3 id="5-使用新账号提交代码"><a href="#5-使用新账号提交代码" class="headerlink" title="5. 使用新账号提交代码"></a>5. 使用新账号提交代码</h3><h4 id="5-1-新建仓库"><a href="#5-1-新建仓库" class="headerlink" title="5.1 新建仓库"></a>5.1 新建仓库</h4><p>首先在新建的文件夹中初始化仓库: <code>git init .</code></p><h4 id="5-2-设置新仓库的用户信息"><a href="#5-2-设置新仓库的用户信息" class="headerlink" title="5.2 设置新仓库的用户信息"></a>5.2 设置新仓库的用户信息</h4><p>设置新账号的用户信息，因为你的电脑中git账号信息都是之前的，所有的仓库建立之后的账户信息都是默认之前的，所以需要在新仓库中设置新的用户名和邮箱，具体命令如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config user.name <span class="token string">"userName"</span>       <span class="token comment"># 你的用户名</span><span class="token function">git</span> config user.email <span class="token string">"email address"</span> <span class="token comment"># 你的邮箱地址</span></code></pre><h4 id="5-3-设置新仓库的地址"><a href="#5-3-设置新仓库的地址" class="headerlink" title="5.3 设置新仓库的地址"></a>5.3 设置新仓库的地址</h4><p>之前都是配置ssh，所以这里添加仓库的ssh地址就可以（当然https地址也可以），<font color="red"><strong>修改ssh地址的hostname为config文件中设置host就可以了</strong></font></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">add</span> <span class="token function">ssh</span> <span class="token punctuation">[</span>URL<span class="token punctuation">]</span></code></pre><p>对于你的新账号，这里的URL比如可以是：<code>git@host:username/repository_name.git</code> (<strong>就是将下图中的github.com改成config文件中你新账号的hostname</strong>)<br><img src="https://img-blog.csdnimg.cn/img_convert/0dbec0f78500c542e8dcfd02f597f526.png" alt="SSH url"></p><h4 id="5-4-提交代码"><a href="#5-4-提交代码" class="headerlink" title="5.4 提交代码"></a>5.4 提交代码</h4><p>最后就可以使用新账号的信息提交代码了，什么git add，git commit 都可以，最后<code>git push ssh master</code>即可</p><hr><p>参考：<a href="https://blog.51cto.com/u_4160094/2912836">https://blog.51cto.com/u_4160094/2912836</a></p><hr><p><font face="黑体" color="black" size="5"><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 码字不易，如果对你有帮助，求三连支持！<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></font></p>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业了？</title>
      <link href="sheng-huo-sui-bi/0410ac902f84.html"/>
      <url>sheng-huo-sui-bi/0410ac902f84.html</url>
      
        <content type="html"><![CDATA[<p>现在是2021年7月底，本科毕业已经一个多月了，“距离开学还有一个多月时间”，现在想总结一下我的本科生活以及现在的一些所闻所感。</p><img src="https://i.loli.net/2021/07/23/eHlv1xKTptXNShf.jpg" alt="微信图片_20210723142115.jpg" style="zoom:50%;"><h2 id="本科四年"><a href="#本科四年" class="headerlink" title="本科四年"></a>本科四年</h2><p>总的来说大一懵懵懂懂，大二继续探索，大三干劲十足，大四有些落寞…</p><p>2017年9月来到北邮，以为大学生活是多姿多彩、十分轻松的，结果没过几个月就感觉有点压力：生活上有点不适应、学习上感觉跟不上、朋友之间相处的不是那么融洽……（也许也和自己的性格相关）。很是感谢当时的高中同学兼大学同学，谢谢她在我刚刚来到北邮的照顾。</p><p>2018年下半年到了大二，相应的专业课也比较多，这学年参加了较多的志愿活动，和大奔、英杰一起的夕阳再晨志愿活动很是充实（这也想我们的志愿德育分直接拿满）。这一年自己也在不断探索大学生活，由于自己处理不了学习和学生工作之间的关系，辞去了班长的职务。年底学校发了大一学年的二等奖学金3000。</p><p>2019年下半年到了大三，为了最后的保研努力冲刺专业课，提升绩点。这一年的相应的课外活动就减少了许多，年底拿到了学校发的大二学年励志奖学金5000。2020年初疫情爆发，开启了在家的学习生活，当时还想着找一个线上实习，想借此能帮助自己保研。</p><p>2020年下半年开学到了学校，也就是保研的9推活动开始，当时自己的心路历程十分复杂（具体记录在2020年底的那一晚）。</p><img src="https://i.loli.net/2021/07/23/BP1Yl8RX2buvaCo.jpg" alt="微信图片_20210723142125.jpg" style="zoom:50%;"><img src="https://i.loli.net/2021/07/23/dlhcZW51jrtQ2AU.jpg" alt="微信图片_20210723142130.jpg" style="zoom:50%;"><p>2021年6月毕业季，是的，我也毕业了，很快乐也很不安（自己究竟要不要读这个研究生，但是总感觉自己没有底气也没有勇气不读，不知道读三年之后会不会有提升，是不是还不如现在就业的同学们，说不定到时候我找工作的时候人接直接成为我的leader，心理想直接工作，但是实际上有需要完成实验室的搬砖工作，所以左右为难，而且随着实验室任务的增多会逐渐消磨直接的工作的想法，也许这就是生活吧：生活总是会在你不经意的时候消磨你生活的意志）</p><p>我不知道这四年我到底学到了多少有用的知识，也不知道未来的我能否达到预期的目标。但是我很喜欢一句话：你只管努力，剩下的交给时间！</p><p>不管未来怎样好吧，毕业快乐🎓，朋友们👩‍🎓，希望“苟富贵，勿相忘”。</p><img src="https://i.loli.net/2021/07/23/li9bwxXa2JUkIKE.jpg" alt="d0d5a39674b93bcd67111b254579ba1.jpg" style="zoom:50%;"><h2 id="未来三年？"><a href="#未来三年？" class="headerlink" title="未来三年？"></a>未来三年？</h2><p>目前我想的是：应该还是会在小破邮待上三年吧。</p><p>想有自己的规划：</p><ul><li><input disabled="" type="checkbox"> 希望自己GitHub项目逐渐丰富🤯</li><li><input disabled="" type="checkbox"> 希望自己入门的C++到“精通”🧑‍🦲</li><li><input disabled="" type="checkbox"> 希望自己学点机器学习深度学习发个小论文😶‍🌫️</li><li><input disabled="" type="checkbox"> 希望自己找个女朋友🤗</li><li><input disabled="" type="checkbox"> 希望自己希望的都实现（🈲套娃）</li></ul><p>先这样吧，心里还有许多想说但没说的话</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Saliency】显著性评价指标</title>
      <link href="shen-du-xue-xi/507732ac59dc.html"/>
      <url>shen-du-xue-xi/507732ac59dc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><span class="github-emoji"><span>⚠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 如果公式不正常显示可以使用Chrome浏览器或者重新刷新试试</p></blockquote><p>一般分为两种显著性目标检测（salient object detection）和眼注视点显著性（eye fixation saliency），虽然两者都能展现吸引用户注意力的物体或者区域，但是侧重点不同。<strong>物体的显著性</strong>主要在于图像中各个物体轮廓的检测，例如目标检测，语义分割等等都涉及到物体的显著性；<strong>眼注视点的显著性</strong>更多是关注用户观看的区域，和用户的观看行为有联系。由于用户在观看全景视频时，往往会关注视频中比较突出的部分，所以两者也有交集。</p><img src="https://img-blog.csdnimg.cn/20181219165952369.jpg" alt="Saliency" style="zoom:80%;"><ul><li>参考1：<a href="https://blog.csdn.net/stupidautofan/category_7507356.html">显著性目标检测</a></li><li>参考2：<a href="https://blog.csdn.net/u010736662/article/details/85099853">图像显著性检测算法的评价指标介绍</a></li></ul><h2 id="1-眼注视点显著性"><a href="#1-眼注视点显著性" class="headerlink" title="1. 眼注视点显著性"></a>1. 眼注视点显著性</h2><h3 id="Receiver-Operating-Characteristic-curve（ROC）"><a href="#Receiver-Operating-Characteristic-curve（ROC）" class="headerlink" title="Receiver Operating Characteristic curve（ROC）"></a>Receiver Operating Characteristic curve（ROC）</h3><h3 id="Area-Under-Curve（AUC）"><a href="#Area-Under-Curve（AUC）" class="headerlink" title="Area Under Curve（AUC）"></a>Area Under Curve（AUC）</h3><p>Viewport-based Saliency Prediction提到这个不太好？</p><h3 id="shuffled-AUC（sAUC）"><a href="#shuffled-AUC（sAUC）" class="headerlink" title="shuffled AUC（sAUC）"></a>shuffled AUC（sAUC）</h3><p>ROC 曲线又称受试者受试者工做特征曲线，以假正例率（False Positive Rate, FPR）为横轴，真正例率（True Positive Rate, TPR）为纵轴所组成的坐标图，以0~255不一样的阈值对预测的眼注视点显著图分类描点，从而绘制成曲线图。从直观上看，曲线越接近左上角，说明该算法检测性能越好；曲线下面积称之为AUC, AUC越大说明算法检测性能越好。因为AUC会受中心误差（center bias）的影响，研究者又提出更加鲁棒的sAUC评价指标。</p><h3 id="Pearsons-Linear-Correlation-Coefficient（CC）"><a href="#Pearsons-Linear-Correlation-Coefficient（CC）" class="headerlink" title="Pearsons Linear Correlation Coefficient（CC）"></a>Pearsons Linear Correlation Coefficient（CC）</h3><p><strong>CC$\uparrow$是指皮尔逊相关系数，也是线性相关系数，用来评价预测的眼关注点显著图和参考图ground truth之间的线性相关性，CC越大说明该模型性能越好</strong></p><p>协方差：$Cov(X,Y)=\frac{\Sigma_{i=1}^n(x_i-E(X))(y_i-E(Y))}{n}$</p><blockquote><p>感性的理解，如果数据杂乱，正负抵消，那么这个协方差就很小，就谈不上二者相关；如果数据很一致，想么协方差就负的比较多（负相关），要么就是正的比较多（正相关）</p></blockquote><p>消除x和y的量差，引用皮尔逊相关系数：$\sigma_{X,Y}=\frac{Cov(X,Y)}{\sigma_X·\sigma_Y}$</p><ul><li><p>具体对于显著性而言，P和D分别代表saliency map和fixation map，被视为随机变量</p><p>$CC(P,Q)=\frac{Cov(P,Q)}{\sigma(P)\times\sigma(Q)}$</p></li></ul><p>参考：<a href="https://blog.csdn.net/limiyudianzi/article/details/103437093">https://blog.csdn.net/limiyudianzi/article/details/103437093</a></p><h3 id="Normalized-Scanpath-Saliency（NSS）"><a href="#Normalized-Scanpath-Saliency（NSS）" class="headerlink" title="Normalized Scanpath Saliency（NSS）"></a>Normalized Scanpath Saliency（NSS）</h3><p><strong>NSS$\uparrow$是指标准化扫描路径显着性，用来评价二者之间的差别值，NSS越大说明模型性能越好；</strong></p><p>$NSS(P，Q)=\frac{1}{N}·\Sigma_i({\overline P_i}\times Q_i)$</p><p>其中P是saliency map，Q是fixation map的二值图，其中i是像素的下标，N是所有的像素值总数，<em>N is the total number of ﬁxated pixels</em>，$\overline P=\frac{P-\mu(P)}{\sigma(P)}$</p><blockquote><p>这里说明一下，一般论文中NSS指标都是5.0+左右，很显然如果我们将预测saliency map归一化在0-1之间，我们得到的NSS只能在0-1之间，因此我觉得论文中计算NSS值可能是将saliency map归一化至0-10之后再计算的</p></blockquote><h3 id="Kullback-Leibler-Divergence-（KLDiv）"><a href="#Kullback-Leibler-Divergence-（KLDiv）" class="headerlink" title="Kullback-Leibler Divergence （KLDiv）"></a>Kullback-Leibler Divergence （KLDiv）</h3><p><strong>KLDiv$\downarrow$是指KL散度，Kullback-Leibler (KL) 是一种广泛使用的信息论度量，用于衡量两个概率分布之间的差异。KLDiv越小说明该模型检测性能越好。</strong></p><p>$KL(P,Q)=\Sigma_iQ_ilog(\epsilon+\frac{Q_i}{\epsilon+P_i})$</p><p>其中$\epsilon$表示正则化常数，KL是非对称差异度量</p><p>具体再参考：<a href="https://blog.csdn.net/matrix_space/article/details/80550561">https://blog.csdn.net/matrix_space/article/details/80550561</a></p><ul><li><p>参考1：What Do Different Evaluation Metrics Tell Us About Saliency Models? IEEE TPAMI 2019</p></li><li><p>参考2：Deep Visual Attention Prediction IEEE TIP 2018</p></li></ul><h2 id="2-显著性目标检测"><a href="#2-显著性目标检测" class="headerlink" title="2. 显著性目标检测"></a>2. 显著性目标检测</h2><h3 id="Mean-Absolute-Error"><a href="#Mean-Absolute-Error" class="headerlink" title="Mean Absolute Error"></a>Mean Absolute Error</h3><p>MAE是指平均绝对值偏差，用于评价预测的显著图和参考图之间的差别，MAE越小说明该算法性能越好；</p><p>$ MAE \downarrow =\dfrac{1}{W\times H}\sum{W}<em>{x=1}\sum{H}</em>{y=1}| \overline{S}(x,y)-\overline{G}(x,y) | $</p><h3 id="PR曲线"><a href="#PR曲线" class="headerlink" title="PR曲线"></a>PR曲线</h3><p>Precise是差准率，Recall是查全率，将图像二值化之后计算：</p><p><img src="https://i.loli.net/2021/07/23/HUswzIFu9We3b7N.png" alt="TP"></p><p>$Precision=\frac{TP}{TP+FP}$ 以及 $Recall=\frac{TP}{TP+FN}$</p><p>将输出图片S进行二值化时，阈值选择为从0到255，每取一个阈值，即可对所有输出图S算得一组相对应的Precision值与Recall值。最后将所有图像在该阈值下的Precision值与Recall值分别求平均，最后将会得到256对P,R值，以Recall为横坐标，Precision为纵坐标绘制曲线图即可得到precision-recall (PR)曲线。</p><h3 id="F-measure"><a href="#F-measure" class="headerlink" title="F-measure"></a>F-measure</h3><p><strong>查全率</strong>和<strong>查准率</strong>在非负权重β下的加权调和平均值(Weighted Harmonic Mean) ，计算公式如下：</p><p>$F_\beta \uparrow =\frac{(1+\beta^2)Precision*Recall}{\beta^2Precision+Recall}$</p><p>$\beta^2$一般取值为0.3，即增加了Precision的权重值，<strong>认为查准率比查全率要重要些</strong>。因为当模型将输出图全部标为目标区域时，查全率Recall将等于100%，但是查准率Precision却很低。</p><ul><li>ROC (Receiver Operating Characteristic curve)</li><li>AUC (Area Under Curve)</li><li>MAP (Mean Average Precision)</li><li>MAR (Mean Average Recall)</li></ul><p>上述评价指标中，ROC与AUC相似于眼注视点任务，都是用不一样的阈值来肯定描点位置，而后将全部点链接起构成ROC曲线；</p><p>MAP是指平均精度率，MAR是指平均召回率，MAR和MAP越大说明算法性能越好。</p><h2 id="3-如何得到fixation-map"><a href="#3-如何得到fixation-map" class="headerlink" title="3. 如何得到fixation map"></a>3. 如何得到fixation map</h2><p>根据用户实际的注视点，统计得到（可能需要去除那些saccade场景的注视点）</p><p>可以参考：A Saliency Dataset for 360-Degree Videos</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> saliency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】背包问题</title>
      <link href="suan-fa/2de3bef2abb4.html"/>
      <url>suan-fa/2de3bef2abb4.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-起源"><a href="#0-起源" class="headerlink" title="0. 起源"></a>0. 起源</h2><h3 id="0-1背包：最大最小问题"><a href="#0-1背包：最大最小问题" class="headerlink" title="0-1背包：最大最小问题"></a><code>0-1</code>背包：最大最小问题</h3><ul><li><p><strong>概念</strong>：一共有N件物品，第<code>i</code>（i从1开始）件物品的重量为<code>w[i]</code>，价值为<code>v[i]</code>。在总重量不超过背包承载上限<code>W</code>的情况下，能够装入背包的最大价值是多少？</p></li><li><p><strong>思路</strong>：定义一个二维数组<code> dp</code> 存储最大价值，其中<code>dp[i][j]</code>表示<strong>前<code>i</code>件物品体积不超过<code> j</code> 的情况下能达到的最大价值</strong>。设第<code>i</code>件物品体积为<code> w</code>，价值为<code> v</code>，根据第<code>i</code>件物品是否添加到背包中，可以分两种情况讨论：</p><ul><li><strong>第<code>i</code>件物品没添加到背包</strong>，总体积不超过<code> j</code> 的前<code> i</code> 件物品的最大价值就是总体积不超过<code>j</code>的前<code>i-1</code>件物品的最大价值，$dp[i][j] = dp[i-1][j]$</li><li><strong>第<code>i</code>件物品添加到背包中</strong>，$dp[i][j] = dp[i-1][j-w[i]] + v[i]$</li></ul></li><li><p>状态转换方程：$dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i]) , j &gt;= w[i]$</p></li><li><p>源代码：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// w 表示背包总体积</span><span class="token comment">// weights 表示物体的重量</span><span class="token comment">// values 表示物体的价值，和 weights 一一对应</span><span class="token keyword">int</span> <span class="token function">backpack</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>weights<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>values<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> n <span class="token operator">=</span> weights<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> w<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 背包承受力足够放下第 i 个物体</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// 背包承受力不够放下第 i 个物体</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>最后：可以优化一下空间的，这里不细说了，注意第二个循环需要倒叙遍历，具体参考：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#0-1-%E8%83%8C%E5%8C%85">CyC2018</a></p></blockquote></li></ul><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><ul><li><p><strong>概念</strong>：和0-1背包问题相似，只是每个重量的物体有无数多个，也就可以重复放某个价值的物体，最终目的就是让背包的总价值最大</p></li><li><p><strong>思路</strong>：总体思想和0-1背包一样</p><ul><li><strong>第<code>i</code>件物品没添加到背包</strong>，同上，$dp[i][j] = dp[i-1][j]$</li><li><strong>第<code>i</code>件物品添加到背包中</strong>，此时和01背包不太一样，因为每种物品有无限个（但注意书包限重是有限的），所以此时不应该转移到<code>dp[i−1][j−w[i]]</code>而应该转移到<code>dp[i][j−w[i]]</code>，即装入第i种商品后还可以再继续装入第种商品。$dp[i][j] = dp[i][j-w[i]] + v[i]$</li></ul></li><li><p>状态转换方程：$dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]]+v[i]) , j &gt;= w[i]$</p></li><li><p>源代码：</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// w 表示背包总体积</span><span class="token comment">// weights 表示物体的重量</span><span class="token comment">// values 表示物体的价值，和 weights 一一对应</span><span class="token keyword">int</span> <span class="token function">backpack</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>weights<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>values<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> n <span class="token operator">=</span> weights<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> w<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 背包承受力足够放下第 i 个物体</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// 背包承受力不够放下第 i 个物体</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>同理可以优化空间，好像需要注意：第二个循环正序遍历，不太懂，具体参考<a href="https://zhuanlan.zhihu.com/p/93857890?utm_source=wechat_session">完全背包-知乎</a></p></blockquote></li></ul><h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><ul><li>先不整理了，有点费脑子</li></ul><h3 id="混合背包或者多维度背包"><a href="#混合背包或者多维度背包" class="headerlink" title="混合背包或者多维度背包"></a>混合背包或者多维度背包</h3><ul><li>太难了，🤮了，具体可以参考<a href="https://github.com/tianyicui/pack/blob/master/V2.pdf">九讲背包问题</a></li></ul><h2 id="1-LeetCode实战"><a href="#1-LeetCode实战" class="headerlink" title="1. LeetCode实战"></a>1. LeetCode实战</h2><blockquote><p>参考：<a href="https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/">力扣-澜山</a></p></blockquote><h3 id="0-组合问题"><a href="#0-组合问题" class="headerlink" title="0. 组合问题"></a>0. 组合问题</h3><pre class="language-python" data-language="python"><code class="language-python">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token punctuation">]</span>  <span class="token operator">//</span> 组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> target<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span></code></pre><p><strong>377.组合总和 Ⅳ、494.目标和、518.零钱兑换 II</strong></p><ul><li><p>这里展示一下<a href="https://leetcode-cn.com/problems/combination-sum-iv/description/">377.组合总和 Ⅳ</a>，这是需要考虑每个数字之间的顺序的，所以是组合问题</p><ul><li>用 <strong>dp[x]</strong> 表示选取的元素之和等于 <strong>x</strong>的方案数，目标是求 **dp[target]**。</li><li>动态规划的边界是<strong>dp[0]=1</strong>，有当不选取任何元素时，元素之和才为 0，因此只有 1 种方案。</li><li>当$1 &lt;= i &lt;= target$，如果存在一种排列，其中的元素之和等于 i，则该排列的最后一个元素一定是数组 nums 中的一个元素，假设该排列的最后一个元素是 num，则一定有$num &lt;= i$，对于元素之和等于 <strong>i−num</strong>的每一种排列，在最后添加 <strong>num</strong>之后即可得到一个元素之和等于 <strong>i</strong> 的排列，因此在计算 <strong>dp[i]**时，应该计算所有的 **dp[i−num]</strong> 之和。</li><li>参考：<a href="https://leetcode-cn.com/problems/combination-sum-iv/solution/zu-he-zong-he-iv-by-leetcode-solution-q8zv/">力扣官方-题解</a></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">combinationSum4</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>target <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> target<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> num<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> num <span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><blockquote><p>说明一下：这里使用unsigned long long是为了防止测试数据的溢出，其实这个测试用例有点内个，<a href="https://leetcode-cn.com/problems/combination-sum-iv/solution/zu-he-zong-he-iv-by-leetcode-solution-q8zv/908055">我的疑问解答</a></p></blockquote></li></ul><h3 id="1-True、False问题公式"><a href="#1-True、False问题公式" class="headerlink" title="1. True、False问题公式"></a>1. True、False问题公式</h3><pre class="language-python" data-language="python"><code class="language-python">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">or</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token punctuation">]</span></code></pre><p><strong>139.单词拆分、416.分割等和子集</strong></p><ul><li><p>这里展示<a href="https://leetcode-cn.com/problems/word-break/">139.单词拆分</a>：<strong>dp[i]</strong> 表示 <strong>s</strong> 的前 <strong>i</strong> 位是否可以用 <strong>wordDict</strong> 中的单词表示</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">wordBreak</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">&amp;</span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 这里使用set容器是为方便查找</span>      unordered_set<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">m</span><span class="token punctuation">(</span>wordDict<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> wordDict<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment">// 这里做一个优化，每次j不需要从0开始遍历，wordDict里面有一个最小长度的串</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> s<span class="token operator">:</span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxL <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxL<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>i <span class="token operator">-</span> maxL<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> start<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> m<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> i<span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> m<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ul><h3 id="2-最大最小问题"><a href="#2-最大最小问题" class="headerlink" title="2. 最大最小问题"></a>2. 最大最小问题</h3><pre class="language-python" data-language="python"><code class="language-python">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">or</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><p><strong>474.一和零、322.零钱兑换</strong></p><ul><li><p>这里展示<a href="https://leetcode-cn.com/problems/coin-change/">322.零钱兑换</a>：让找的零钱数最少</p><ul><li><p>假设 <code>f(n)</code> 代表要凑齐金额为 n 所要用的最少硬币数量，那么有：</p><p>$f(n) = min(f(n - c1), f(n - c2), … f(n - cn)) + 1$</p><p>其中 <code>c1 ~ cn</code> 为硬币的所有面额。</p></li><li><p>再具体解释一下这个公式吧，例如这个示例：</p><pre class="language-angelscript" data-language="angelscript"><code class="language-angelscript">输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1</code></pre><p>题目求的值为 <code>f(11)</code>，第一次选择硬币时我们有三种选择。</p><p>假设我们取面额为 1 的硬币，那么接下来需要凑齐的总金额变为 <code>11 - 1 = 10</code>，即 <code>f(11) = f(10) + 1</code>，这里的 <code>+1</code> 就是我们取出的面额为 1 的硬币。</p><p>同理，如果取面额为 2 或面额为 5 的硬币可以得到：</p><ul><li><code>f(11) = f(9) + 1</code></li><li><code>f(11) = f(6) + 1</code></li></ul><p>所以：</p><pre class="language-lisp" data-language="lisp"><code class="language-lisp">f<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> = min<span class="token punctuation">(</span><span class="token car">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>, f<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>, f<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span> + 1</code></pre></li><li><p>参考：<a href="https://leetcode-cn.com/problems/coin-change/comments/78252">力扣-江不知</a></p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> INT_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token comment">// 两种遍历方式都可以</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> amount<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> c<span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> c <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>c<span class="token punctuation">]</span> <span class="token operator">!=</span> INT_MAX<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>c<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">// for (int c: coins) {</span>        <span class="token comment">//     for(int j = c; j &lt;= amount; ++ j) {</span>        <span class="token comment">//         if(dp[j- c] != INT_MAX) {</span>        <span class="token comment">//             dp[j] = min(dp[j], dp[j-c] + 1);</span>        <span class="token comment">//         }</span>        <span class="token comment">//     }</span>        <span class="token comment">// }</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> INT_MAX <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ul><h2 id="2-Trick"><a href="#2-Trick" class="headerlink" title="2. Trick"></a>2. Trick</h2><blockquote><p>参考：<a href="https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/">力扣-澜山</a></p><p>不过好像不是很理解，🤒</p></blockquote><h3 id="背包问题技巧："><a href="#背包问题技巧：" class="headerlink" title="背包问题技巧："></a>背包问题技巧：</h3><ul><li><p>如果是0-1背包，即数组中的元素不可重复使用，nums放在外循环，target在内循环，且内循环倒序；</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> nums<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span></code></pre></li></ul><ul><li><p>如果是完全背包，即数组中的元素可重复使用，nums放在外循环，target在内循环。且内循环正序。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span></code></pre></li></ul><ul><li><p>如果组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> target<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【PyTorch】RNN--高级篇</title>
      <link href="shen-du-xue-xi/20548f8be3b8.html"/>
      <url>shen-du-xue-xi/20548f8be3b8.html</url>
      
        <content type="html"><![CDATA[<p><strong>来源：<a href="https://www.bilibili.com/video/BV1Y7411d7Ys?t=3&amp;p=13">https://www.bilibili.com/video/BV1Y7411d7Ys?t=3&amp;p=13</a></strong></p><h2 id="RNN-Classifier-model"><a href="#RNN-Classifier-model" class="headerlink" title="RNN_Classifier model"></a>RNN_Classifier model</h2><p><img src="/pic/model.png" alt="model"></p><h3 id="1-准备数据"><a href="#1-准备数据" class="headerlink" title="1. 准备数据"></a>1. 准备数据</h3><ol><li><p>对于每个名字需要得到一个向量</p></li><li><p>通过ASCII对于每个名字的每个字符都得到一个<code>one-hot vector</code><br><img src="/pic/data.png" alt="data"></p></li><li><p>由于输入是矩阵所以需要<code>padding</code></p></li></ol><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> Dataset<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoader<span class="token keyword">import</span> gzip<span class="token keyword">import</span> csv<span class="token keyword">class</span> <span class="token class-name">NameDataset</span><span class="token punctuation">(</span>Dataset<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> is_train_set<span class="token punctuation">)</span><span class="token punctuation">:</span>        filename <span class="token operator">=</span> <span class="token string">'./names_train.csv.gz'</span> <span class="token keyword">if</span> is_train_set <span class="token keyword">else</span> <span class="token string">'./names_test.csv.gz'</span>        <span class="token keyword">with</span> gzip<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">'rt'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token comment"># r表示只读，从文件头开始 t表示文本模式</span>            reader <span class="token operator">=</span> csv<span class="token punctuation">.</span>reader<span class="token punctuation">(</span>f<span class="token punctuation">)</span>            rows <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>names <span class="token operator">=</span> <span class="token punctuation">[</span>row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> row <span class="token keyword">in</span> rows<span class="token punctuation">]</span>        self<span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>names<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>countries <span class="token operator">=</span> <span class="token punctuation">[</span>row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> row <span class="token keyword">in</span> rows<span class="token punctuation">]</span>        self<span class="token punctuation">.</span>country_list <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">sorted</span><span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>countries<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>country_dict <span class="token operator">=</span> self<span class="token punctuation">.</span>getCountryDict<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>country_num <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>country_list<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span>       <span class="token comment"># 根据索引拿到的是 名字，国家的索引</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>names<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>country_dict<span class="token punctuation">[</span>self<span class="token punctuation">.</span>countries<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">__len__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token builtin">len</span>    <span class="token keyword">def</span> <span class="token function">getCountryDict</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        country_dict <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> idx<span class="token punctuation">,</span> country_name <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>country_list<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            country_dict<span class="token punctuation">[</span>country_name<span class="token punctuation">]</span> <span class="token operator">=</span> idx        <span class="token keyword">return</span> country_dict    <span class="token keyword">def</span> <span class="token function">idx2country</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>country_list<span class="token punctuation">[</span>index<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">getCountriesNum</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>country_numHIDDEN_SIZE <span class="token operator">=</span> <span class="token number">100</span>BATCH_SIZE <span class="token operator">=</span> <span class="token number">256</span>N_LAYER <span class="token operator">=</span> <span class="token number">2</span>N_EPOCHS <span class="token operator">=</span> <span class="token number">50</span>N_CHARS <span class="token operator">=</span> <span class="token number">128</span>   <span class="token comment"># 这个是为了构造嵌入层</span>trainSet <span class="token operator">=</span> NameDataset<span class="token punctuation">(</span>is_train_set<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>trainLoader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>trainSet<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>BATCH_SIZE<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>testSet <span class="token operator">=</span> NameDataset<span class="token punctuation">(</span>is_train_set<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>testLoader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>testSet<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>BATCH_SIZE<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>N_COUNTRY <span class="token operator">=</span> trainSet<span class="token punctuation">.</span>getCountriesNum<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="2-构建模型"><a href="#2-构建模型" class="headerlink" title="2. 构建模型"></a>2. 构建模型</h3><h4 id="GRU的维度"><a href="#GRU的维度" class="headerlink" title="GRU的维度"></a>GRU的维度</h4><ol><li>输入维度</li></ol><ul><li>𝑖𝑛𝑝𝑢𝑡: (𝑠𝑒𝑞𝐿𝑒𝑛, 𝑏𝑎𝑡𝑐ℎ𝑆𝑖𝑧𝑒, ℎ𝑖𝑑𝑑𝑒𝑛𝑆𝑖𝑧𝑒) </li><li>hidden: (nLayers * nDirections, batchSize, hiddenSize)</li></ul><ol start="2"><li>输出维度</li></ol><ul><li>output: (seqLen, batchSize, hiddenSize * nDirections)</li><li>hidden: (nLayers * nDirections, batchSize, hiddenSize)</li></ul><ol start="3"><li>示意图<br><img src="/pic/model-show.png" alt="model示意图"></li></ol><h4 id="GRU处理时可以使用pack-padded-sequence提高效率"><a href="#GRU处理时可以使用pack-padded-sequence提高效率" class="headerlink" title="GRU处理时可以使用pack_padded_sequence提高效率"></a>GRU处理时可以使用<code>pack_padded_sequence</code>提高效率</h4><p><img src="/pic/pack_padded_sequence.png" alt="pack_padded"></p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">RNNClassifier</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">,</span> output_size<span class="token punctuation">,</span> n_layers<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bidirectional<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>RNNClassifier<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>         self<span class="token punctuation">.</span>hidden_size <span class="token operator">=</span> hidden_size         self<span class="token punctuation">.</span>n_layers <span class="token operator">=</span> n_layers         self<span class="token punctuation">.</span>n_directions <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">if</span> bidirectional <span class="token keyword">else</span> <span class="token number">1</span>   <span class="token comment"># 使用双向的GRU</span>                <span class="token comment"># 嵌入层（𝑠𝑒𝑞𝐿𝑒𝑛, 𝑏𝑎𝑡𝑐ℎ𝑆𝑖𝑧𝑒） --&gt; (𝑠𝑒𝑞𝐿𝑒𝑛, 𝑏𝑎𝑡𝑐ℎ𝑆𝑖𝑧𝑒, hidden_size)</span>        self<span class="token punctuation">.</span>embedding <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Embedding<span class="token punctuation">(</span>input_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">)</span>         self<span class="token punctuation">.</span>gru <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>GRU<span class="token punctuation">(</span>hidden_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">,</span> n_layers<span class="token punctuation">,</span> bidirectional<span class="token operator">=</span>bidirectional<span class="token punctuation">)</span>         self<span class="token punctuation">.</span>fc <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>hidden_size <span class="token operator">*</span> self<span class="token punctuation">.</span>n_directions<span class="token punctuation">,</span> output_size<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_init_hidden</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>        hidden <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>self<span class="token punctuation">.</span>n_layers <span class="token operator">*</span> self<span class="token punctuation">.</span>n_directions<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>         <span class="token keyword">return</span> hidden    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">,</span> seq_lengths<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># input shape : B x S -&gt; S x B</span>        <span class="token builtin">input</span> <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">.</span>t<span class="token punctuation">(</span><span class="token punctuation">)</span>         batch_size <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        hidden <span class="token operator">=</span> self<span class="token punctuation">.</span>_init_hidden<span class="token punctuation">(</span>batch_size<span class="token punctuation">)</span>         embedding <span class="token operator">=</span> self<span class="token punctuation">.</span>embedding<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span>        <span class="token comment"># pack them up</span>        gru_input <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>rnn<span class="token punctuation">.</span>pack_padded_sequence<span class="token punctuation">(</span>embedding<span class="token punctuation">,</span> seq_lengths<span class="token punctuation">)</span>        output<span class="token punctuation">,</span> hidden <span class="token operator">=</span> self<span class="token punctuation">.</span>gru<span class="token punctuation">(</span>gru_input<span class="token punctuation">,</span> hidden<span class="token punctuation">)</span>         <span class="token keyword">if</span> self<span class="token punctuation">.</span>n_directions <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>            hidden_cat <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>hidden<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> hidden<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            hidden_cat <span class="token operator">=</span> hidden<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        fc_output <span class="token operator">=</span> self<span class="token punctuation">.</span>fc<span class="token punctuation">(</span>hidden_cat<span class="token punctuation">)</span>         <span class="token keyword">return</span> fc_output    </code></pre><h3 id="3-数据转化成Tensor"><a href="#3-数据转化成Tensor" class="headerlink" title="3. 数据转化成Tensor"></a>3. 数据转化成Tensor</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">name2list</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>    arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">ord</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">for</span> c <span class="token keyword">in</span> name<span class="token punctuation">]</span>    <span class="token keyword">return</span> arr<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">make_tensors</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> countries<span class="token punctuation">)</span><span class="token punctuation">:</span>    sequences_and_lengths <span class="token operator">=</span> <span class="token punctuation">[</span>name2list<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">for</span> name <span class="token keyword">in</span> names<span class="token punctuation">]</span>    name_sequences <span class="token operator">=</span> <span class="token punctuation">[</span>s1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> s1 <span class="token keyword">in</span> sequences_and_lengths<span class="token punctuation">]</span>    seq_lengths <span class="token operator">=</span> torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">(</span><span class="token punctuation">[</span>s1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> s1 <span class="token keyword">in</span> sequences_and_lengths<span class="token punctuation">]</span><span class="token punctuation">)</span>    countries <span class="token operator">=</span> countries<span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># make tensor of name, BatchSize * seqLen</span>    <span class="token comment"># 他这里补零的方式先将所有的0 Tensor给初始化出来，然后在每行前面填充每个名字</span>    seq_tensor <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>name_sequences<span class="token punctuation">)</span><span class="token punctuation">,</span> seq_lengths<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># print("seq_lengths.max:", seq_lengths.max())</span>    <span class="token keyword">for</span> idx<span class="token punctuation">,</span> <span class="token punctuation">(</span>seq<span class="token punctuation">,</span> seq_len<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span><span class="token builtin">zip</span><span class="token punctuation">(</span>name_sequences<span class="token punctuation">,</span> seq_lengths<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        seq_tensor<span class="token punctuation">[</span>idx<span class="token punctuation">,</span> <span class="token punctuation">:</span>seq_len<span class="token punctuation">]</span> <span class="token operator">=</span> torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">(</span>seq<span class="token punctuation">)</span>    <span class="token comment"># sort by length to use pack_padded_sequence</span>    <span class="token comment"># 将名字长度降序排列，并且返回降序之后的长度在原tensor中的小标perm_idx</span>    seq_lengths<span class="token punctuation">,</span> perm_idx <span class="token operator">=</span> seq_lengths<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> descending<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment"># 这个Tensor中的类似于列表中切片的方法神奇啊，直接返回下标对应的元素，相等于排序了</span>    seq_tensor <span class="token operator">=</span> seq_tensor<span class="token punctuation">[</span>perm_idx<span class="token punctuation">]</span>    countries <span class="token operator">=</span> countries<span class="token punctuation">[</span>perm_idx<span class="token punctuation">]</span>    <span class="token comment"># 返回排序之后名字Tensor，排序之后的名字长度Tensor，排序之后的国家名字Tensor</span>    <span class="token keyword">return</span> seq_tensor<span class="token punctuation">,</span> seq_lengths<span class="token punctuation">,</span> countries</code></pre><h3 id="4-训练数据"><a href="#4-训练数据" class="headerlink" title="4. 训练数据"></a>4. 训练数据</h3><pre class="language-python" data-language="python"><code class="language-python">classifier <span class="token operator">=</span> RNNClassifier<span class="token punctuation">(</span>N_CHARS<span class="token punctuation">,</span> HIDDEN_SIZE<span class="token punctuation">,</span> N_COUNTRY<span class="token punctuation">,</span> N_LAYER<span class="token punctuation">)</span> criterion <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span> optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>classifier<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">)</span><span class="token keyword">import</span> time<span class="token keyword">import</span> math<span class="token keyword">def</span> <span class="token function">trainModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">time_since</span><span class="token punctuation">(</span>since<span class="token punctuation">)</span><span class="token punctuation">:</span>        s <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> since        m <span class="token operator">=</span> math<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>s <span class="token operator">/</span> <span class="token number">60</span><span class="token punctuation">)</span>        s <span class="token operator">-=</span> m <span class="token operator">*</span> <span class="token number">60</span>        <span class="token keyword">return</span> <span class="token string">'%dm %ds'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>m<span class="token punctuation">,</span> s<span class="token punctuation">)</span>    total_loss <span class="token operator">=</span> <span class="token number">0</span>     <span class="token keyword">for</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span>names<span class="token punctuation">,</span> countries<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>trainLoader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># print(type(names), type(countries))</span>        <span class="token comment"># print(len(names), countries.shape)</span>        inputs<span class="token punctuation">,</span> seq_lengths<span class="token punctuation">,</span> target <span class="token operator">=</span> make_tensors<span class="token punctuation">(</span>names<span class="token punctuation">,</span> countries<span class="token punctuation">)</span>                output <span class="token operator">=</span> classifier<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> seq_lengths<span class="token punctuation">)</span>         <span class="token comment"># print("Shape:", output.shape, target.shape)</span>        <span class="token comment"># 注意输出和目标的维度：Shape: torch.Size([256, 18]) torch.Size([256])</span>        loss <span class="token operator">=</span> criterion<span class="token punctuation">(</span>output<span class="token punctuation">,</span> target<span class="token punctuation">)</span>         optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>         loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>         optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        total_loss <span class="token operator">+=</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token keyword">if</span> i <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'[</span><span class="token interpolation"><span class="token punctuation">{</span>time_since<span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">] Epoch </span><span class="token interpolation"><span class="token punctuation">{</span>epoch<span class="token punctuation">}</span></span><span class="token string"> '</span></span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'[</span><span class="token interpolation"><span class="token punctuation">{</span>i <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>inputs<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">/</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token builtin">len</span><span class="token punctuation">(</span>trainSet<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">] '</span></span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'loss=</span><span class="token interpolation"><span class="token punctuation">{</span>total_loss <span class="token operator">/</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>inputs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>     <span class="token keyword">return</span> total_loss<span class="token keyword">def</span> <span class="token function">testModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    correct <span class="token operator">=</span> <span class="token number">0</span>    total <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>testSet<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"evaluating trained model ... "</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span>names<span class="token punctuation">,</span> countries<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>testLoader<span class="token punctuation">)</span><span class="token punctuation">:</span>            inputs<span class="token punctuation">,</span> seq_lengths<span class="token punctuation">,</span> target <span class="token operator">=</span> make_tensors<span class="token punctuation">(</span>names<span class="token punctuation">,</span> countries<span class="token punctuation">)</span>            output <span class="token operator">=</span> classifier<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> seq_lengths<span class="token punctuation">)</span>            <span class="token comment"># 注意这个keepdim的使用，为了直接和target计算loss</span>            pred <span class="token operator">=</span> output<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> keepdim<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token comment"># 注意这个view_as 和 eq</span>            correct <span class="token operator">+=</span> pred<span class="token punctuation">.</span>eq<span class="token punctuation">(</span>target<span class="token punctuation">.</span>view_as<span class="token punctuation">(</span>pred<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>                percent <span class="token operator">=</span> <span class="token string">'%.2f'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">*</span> correct <span class="token operator">/</span> total<span class="token punctuation">)</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Test set: Accuracy </span><span class="token interpolation"><span class="token punctuation">{</span>correct<span class="token punctuation">}</span></span><span class="token string">/</span><span class="token interpolation"><span class="token punctuation">{</span>total<span class="token punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token punctuation">{</span>percent<span class="token punctuation">}</span></span><span class="token string">%'</span></span><span class="token punctuation">)</span>    <span class="token keyword">return</span> correct <span class="token operator">/</span> total  N_EPOCHS <span class="token operator">=</span> <span class="token number">50</span>start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Training for %d epochs..."</span> <span class="token operator">%</span> N_EPOCHS<span class="token punctuation">)</span> acc_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> N_EPOCHS <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Train cycle</span>    trainModel<span class="token punctuation">(</span><span class="token punctuation">)</span>     acc <span class="token operator">=</span> testModel<span class="token punctuation">(</span><span class="token punctuation">)</span>     acc_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>acc<span class="token punctuation">)</span></code></pre><blockquote><p>训练结果：</p><pre class="language-none"><code class="language-none">Training for 50 epochs...[0m 2s] Epoch 1 [2560/13374] loss=0.00895661092363298[0m 4s] Epoch 1 [5120/13374] loss=0.007739758561365306[0m 6s] Epoch 1 [7680/13374] loss=0.0069853457777450485[0m 8s] Epoch 1 [10240/13374] loss=0.006530495395418256[0m 11s] Epoch 1 [12800/13374] loss=0.006135637713596225evaluating trained model ... Test set: Accuracy 4535/6700 67.69%[0m 15s] Epoch 2 [2560/13374] loss=0.004228085093200207[0m 17s] Epoch 2 [5120/13374] loss=0.0041014277492649855[0m 19s] Epoch 2 [7680/13374] loss=0.004011582878107826[0m 22s] Epoch 2 [10240/13374] loss=0.0038964587613008915[0m 24s] Epoch 2 [12800/13374] loss=0.0038181920163333416evaluating trained model ... ......（中间省略若干）[12m 46s] Epoch 49 [2560/13374] loss=0.00016357196727767587[12m 49s] Epoch 49 [5120/13374] loss=0.0001682748734310735[12m 51s] Epoch 49 [7680/13374] loss=0.00017566338913942067[12m 54s] Epoch 49 [10240/13374] loss=0.0001776946208337904[12m 57s] Epoch 49 [12800/13374] loss=0.00018831568930181676evaluating trained model ... Test set: Accuracy 5627/6700 83.99%[13m 2s] Epoch 50 [2560/13374] loss=0.00016892087151063607[13m 5s] Epoch 50 [5120/13374] loss=0.00015529338124906645[13m 7s] Epoch 50 [7680/13374] loss=0.00017500294488854707[13m 11s] Epoch 50 [10240/13374] loss=0.00017692927776806754[13m 14s] Epoch 50 [12800/13374] loss=0.00018558732335804962evaluating trained model ... Test set: Accuracy 5613/6700 83.78%</code></pre></blockquote><h3 id="5-可视化"><a href="#5-可视化" class="headerlink" title="5. 可视化"></a>5. 可视化</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npepoch <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>acc_list<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>acc_list <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>acc_list<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>epoch<span class="token punctuation">,</span> acc_list<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Epoch'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Accuracy'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>grid<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="/pic/EPOCH_ACC.png" alt="EPOCH_ACC"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【PyTorch】RNN</title>
      <link href="shen-du-xue-xi/791cc4c6eb51.html"/>
      <url>shen-du-xue-xi/791cc4c6eb51.html</url>
      
        <content type="html"><![CDATA[<h1 id="Pytorch-for-RNN"><a href="#Pytorch-for-RNN" class="headerlink" title="Pytorch for RNN"></a>Pytorch for RNN</h1><p>来源：<a href="https://www.bilibili.com/video/BV1Y7411d7Ys?p=12">https://www.bilibili.com/video/BV1Y7411d7Ys?p=12</a></p><h2 id="How-to-use-RNNCell"><a href="#How-to-use-RNNCell" class="headerlink" title="How to use RNNCell"></a>How to use RNNCell</h2><h3 id="注意几个参数"><a href="#注意几个参数" class="headerlink" title="注意几个参数"></a>注意几个参数</h3><ol><li><p>输入和隐层（输出）维度</p></li><li><p>序列长度</p></li><li><p>批处理大小</p></li></ol><ul><li><strong>注 调用RNNCell这个需要循环，循环长度就是序列长度</strong></li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchbatch_size <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment"># 批处理大小</span>seq_len <span class="token operator">=</span> <span class="token number">3</span>     <span class="token comment"># 序列长度</span>input_size <span class="token operator">=</span> <span class="token number">4</span>  <span class="token comment"># 输入维度</span>hidden_size <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment"># 隐层维度</span>cell <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>RNNCell<span class="token punctuation">(</span>input_size<span class="token operator">=</span>input_size<span class="token punctuation">,</span> hidden_size<span class="token operator">=</span>hidden_size<span class="token punctuation">)</span><span class="token comment"># (seq, batch, features)</span>dataset <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>seq_len<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> input_size<span class="token punctuation">)</span>hidden <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">)</span><span class="token comment"># 这个循环就是处理seq_len长度的数据</span><span class="token keyword">for</span> idx<span class="token punctuation">,</span> data <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>dataset<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'='</span> <span class="token operator">*</span> <span class="token number">20</span><span class="token punctuation">,</span> idx<span class="token punctuation">,</span> <span class="token string">'='</span> <span class="token operator">*</span> <span class="token number">20</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Input size:'</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> data<span class="token punctuation">)</span>    hidden <span class="token operator">=</span> cell<span class="token punctuation">(</span>data<span class="token punctuation">,</span> hidden<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hidden size:'</span><span class="token punctuation">,</span> hidden<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> hidden<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>hidden<span class="token punctuation">)</span></code></pre><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>Input size: torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">1.9129</span>, -0.7440,  <span class="token number">0.2329</span>,  <span class="token number">1.3065</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>hidden size: torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>-0.0790, -0.8957<span class="token punctuation">]</span><span class="token punctuation">]</span>, <span class="token assign-left variable">grad_fn</span><span class="token operator">=</span><span class="token operator">&lt;</span>TanhBackward<span class="token operator">&gt;</span><span class="token punctuation">)</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>-0.0790, -0.8957<span class="token punctuation">]</span><span class="token punctuation">]</span>, <span class="token assign-left variable">grad_fn</span><span class="token operator">=</span><span class="token operator">&lt;</span>TanhBackward<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>Input size: torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>-0.6290, -0.2338, -0.2949,  <span class="token number">0.3956</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>hidden size: torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0.0170</span>, -0.0005<span class="token punctuation">]</span><span class="token punctuation">]</span>, <span class="token assign-left variable">grad_fn</span><span class="token operator">=</span><span class="token operator">&lt;</span>TanhBackward<span class="token operator">&gt;</span><span class="token punctuation">)</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0.0170</span>, -0.0005<span class="token punctuation">]</span><span class="token punctuation">]</span>, <span class="token assign-left variable">grad_fn</span><span class="token operator">=</span><span class="token operator">&lt;</span>TanhBackward<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>Input size: torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>-0.6959,  <span class="token number">1.0590</span>, -0.6798,  <span class="token number">0.6989</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>hidden size: torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0.4216</span>, <span class="token number">0.6813</span><span class="token punctuation">]</span><span class="token punctuation">]</span>, <span class="token assign-left variable">grad_fn</span><span class="token operator">=</span><span class="token operator">&lt;</span>TanhBackward<span class="token operator">&gt;</span><span class="token punctuation">)</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0.4216</span>, <span class="token number">0.6813</span><span class="token punctuation">]</span><span class="token punctuation">]</span>, <span class="token assign-left variable">grad_fn</span><span class="token operator">=</span><span class="token operator">&lt;</span>TanhBackward<span class="token operator">&gt;</span><span class="token punctuation">)</span></code></pre><h2 id="How-to-use-RNN"><a href="#How-to-use-RNN" class="headerlink" title="How to use RNN"></a>How to use RNN</h2><h3 id="确定几个参数"><a href="#确定几个参数" class="headerlink" title="确定几个参数"></a>确定几个参数</h3><ol><li>input_size和hidden_size: 输入维度和隐层维度</li><li>batch_size: 批处理大小</li><li>seq_len: 序列长度</li><li>num_layers: 隐层数目</li></ol><ul><li><strong>注 直接调用RNN这个不用循环</strong></li><li><strong>注：如果使用batch_first: if True, the input and output tensors are provided as:(batch_size, seq_len, input_size)</strong></li></ul><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchbatch_size <span class="token operator">=</span> <span class="token number">1</span>seq_len <span class="token operator">=</span> <span class="token number">3</span>input_size <span class="token operator">=</span> <span class="token number">4</span>hidden_size <span class="token operator">=</span> <span class="token number">2</span>num_layers <span class="token operator">=</span> <span class="token number">1</span>cell <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>RNN<span class="token punctuation">(</span>input_size<span class="token operator">=</span>input_size<span class="token punctuation">,</span> hidden_size<span class="token operator">=</span>hidden_size<span class="token punctuation">,</span> num_layers<span class="token operator">=</span>num_layers<span class="token punctuation">)</span><span class="token comment"># (seqLen, batchSize, inputSize)</span>inputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>seq_len<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> input_size<span class="token punctuation">)</span>hidden <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>num_layers<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">)</span>out<span class="token punctuation">,</span> hidden <span class="token operator">=</span> cell<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> hidden<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Output size:'</span><span class="token punctuation">,</span> out<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>        <span class="token comment"># (seq_len, batch_size, hidden_size)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Output:'</span><span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Hidden size:'</span><span class="token punctuation">,</span> hidden<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>     <span class="token comment"># (num_layers, batch_size, hidden_size)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Hidden:'</span><span class="token punctuation">,</span> hidden<span class="token punctuation">)</span></code></pre><h3 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h3><pre class="language-bash" data-language="bash"><code class="language-bash">Output size: torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span>, <span class="token number">1</span>, <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Output: tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0.3689</span>,  <span class="token number">0.5982</span><span class="token punctuation">]</span><span class="token punctuation">]</span>,        <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0.1233</span>,  <span class="token number">0.2617</span><span class="token punctuation">]</span><span class="token punctuation">]</span>,        <span class="token punctuation">[</span><span class="token punctuation">[</span>-0.3517, -0.7246<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>, <span class="token assign-left variable">grad_fn</span><span class="token operator">=</span><span class="token operator">&lt;</span>StackBackward<span class="token operator">&gt;</span><span class="token punctuation">)</span>Hidden size: torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">1</span>, <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Hidden: tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span>-0.3517, -0.7246<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>, <span class="token assign-left variable">grad_fn</span><span class="token operator">=</span><span class="token operator">&lt;</span>StackBackward<span class="token operator">&gt;</span><span class="token punctuation">)</span></code></pre><h2 id="Example-Using-RNNCell"><a href="#Example-Using-RNNCell" class="headerlink" title="Example: Using RNNCell"></a>Example: Using RNNCell</h2><h3 id="Hello-–-gt-ohlol"><a href="#Hello-–-gt-ohlol" class="headerlink" title="Hello –> ohlol"></a>Hello –&gt; ohlol</h3><ol><li>首先需要将输入的单词转成向量<code>one-hot vector</code></li><li>注意input_size，如下图</li></ol><p><img src="/pic/RNN_example.png" alt="转化成向量"></p><h3 id="注意交叉熵在计算loss的时候维度关系"><a href="#注意交叉熵在计算loss的时候维度关系" class="headerlink" title="注意交叉熵在计算loss的时候维度关系"></a>注意交叉熵在计算loss的时候维度关系</h3><p><strong>这里的hidden是<code>([1, 4])</code>, label是 <code>([1])</code></strong></p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchinput_size <span class="token operator">=</span> <span class="token number">4</span>hidden_size <span class="token operator">=</span> <span class="token number">4</span>batch_size <span class="token operator">=</span> <span class="token number">1</span>idx2char <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">]</span>x_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>    <span class="token comment"># hello中各个字符的下标</span>y_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>    <span class="token comment"># ohlol中各个字符的下标</span>one_hot_lookup <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>x_one_hot <span class="token operator">=</span> <span class="token punctuation">[</span>one_hot_lookup<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> x_data<span class="token punctuation">]</span> <span class="token comment"># (seqLen, inputSize)</span>inputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span>x_one_hot<span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> input_size<span class="token punctuation">)</span>labels <span class="token operator">=</span> torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">(</span>y_data<span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment"># torch.Tensor默认是torch.FloatTensor是32位浮点类型数据，torch.LongTensor是64位整型</span><span class="token keyword">print</span><span class="token punctuation">(</span>inputs<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> labels<span class="token punctuation">.</span>shape<span class="token punctuation">)</span></code></pre><blockquote><p>输出结果：</p><pre class="language-bash" data-language="bash"><code class="language-bash">torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span>, <span class="token number">1</span>, <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span>, <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></blockquote><h4 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h4><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">class</span> <span class="token class-name">Model</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>Model<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>batch_size <span class="token operator">=</span> batch_size        self<span class="token punctuation">.</span>input_size <span class="token operator">=</span> input_size        self<span class="token punctuation">.</span>hidden_size <span class="token operator">=</span> hidden_size        self<span class="token punctuation">.</span>rnncell <span class="token operator">=</span> nn<span class="token punctuation">.</span>RNNCell<span class="token punctuation">(</span>input_size<span class="token operator">=</span>self<span class="token punctuation">.</span>input_size<span class="token punctuation">,</span> hidden_size<span class="token operator">=</span>self<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> hidden<span class="token punctuation">)</span><span class="token punctuation">:</span>        hidden <span class="token operator">=</span> self<span class="token punctuation">.</span>rnncell<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> hidden<span class="token punctuation">)</span>   <span class="token comment"># (batch_size, hidden_size)</span>        <span class="token keyword">return</span> hidden    <span class="token keyword">def</span> <span class="token function">init_hidden</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>self<span class="token punctuation">.</span>batch_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>net <span class="token operator">=</span> Model<span class="token punctuation">(</span>input_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span>criterion <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span></code></pre><h4 id="训练数据"><a href="#训练数据" class="headerlink" title="训练数据"></a>训练数据</h4><pre class="language-python" data-language="python"><code class="language-python">epochs <span class="token operator">=</span> <span class="token number">15</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>    loss <span class="token operator">=</span> <span class="token number">0</span>    optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    hidden <span class="token operator">=</span> net<span class="token punctuation">.</span>init_hidden<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Predicted string:'</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token builtin">input</span><span class="token punctuation">,</span> label <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">:</span>        hidden <span class="token operator">=</span> net<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">,</span> hidden<span class="token punctuation">)</span>        <span class="token comment"># 注意交叉熵在计算loss的时候维度关系，这里的hidden是([1, 4]), label是 ([1])</span>        loss <span class="token operator">+=</span> criterion<span class="token punctuation">(</span>hidden<span class="token punctuation">,</span> label<span class="token punctuation">)</span>        _<span class="token punctuation">,</span> idx <span class="token operator">=</span> hidden<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>dim <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>idx2char<span class="token punctuation">[</span>idx<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>    loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">', Epoch [%d/15] loss=%.4f'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>epoch<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><blockquote><p>输出结果：</p><pre class="language-bash" data-language="bash"><code class="language-bash">Predicted string:lhlhh, Epoch <span class="token punctuation">[</span><span class="token number">1</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">6.8407</span>Predicted string:lllll, Epoch <span class="token punctuation">[</span><span class="token number">2</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">5.2957</span>Predicted string:lllol, Epoch <span class="token punctuation">[</span><span class="token number">3</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">4.9344</span>Predicted string:lllol, Epoch <span class="token punctuation">[</span><span class="token number">4</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">4.7035</span>Predicted string:oolol, Epoch <span class="token punctuation">[</span><span class="token number">5</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">4.4781</span>Predicted string:oolol, Epoch <span class="token punctuation">[</span><span class="token number">6</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">4.2419</span>Predicted string:ohlol, Epoch <span class="token punctuation">[</span><span class="token number">7</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">3.9733</span>Predicted string:ohlol, Epoch <span class="token punctuation">[</span><span class="token number">8</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">3.6942</span>Predicted string:ohlol, Epoch <span class="token punctuation">[</span><span class="token number">9</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">3.4917</span>Predicted string:ohloo, Epoch <span class="token punctuation">[</span><span class="token number">10</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">3.3837</span>Predicted string:ohloo, Epoch <span class="token punctuation">[</span><span class="token number">11</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">3.2953</span>Predicted string:ohlol, Epoch <span class="token punctuation">[</span><span class="token number">12</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">3.1331</span>Predicted string:ohlol, Epoch <span class="token punctuation">[</span><span class="token number">13</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">2.9294</span>Predicted string:ohlol, Epoch <span class="token punctuation">[</span><span class="token number">14</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">2.7344</span>Predicted string:ohlol, Epoch <span class="token punctuation">[</span><span class="token number">15</span>/15<span class="token punctuation">]</span> <span class="token assign-left variable">loss</span><span class="token operator">=</span><span class="token number">2.5680</span></code></pre></blockquote><h2 id="Example-Using-RNN"><a href="#Example-Using-RNN" class="headerlink" title="Example: Using RNN"></a>Example: Using RNN</h2><h3 id="注意inputs和labels的维度"><a href="#注意inputs和labels的维度" class="headerlink" title="注意inputs和labels的维度"></a>注意<code>inputs</code>和<code>labels</code>的维度</h3><ul><li><code>inputs</code>维度是: (seqLen, batch_size, input_size)</li><li><code>labels</code>维度是: (seqLen * batch_size)</li></ul><h3 id="注意outputs维度，对应和labels做交叉熵的维度"><a href="#注意outputs维度，对应和labels做交叉熵的维度" class="headerlink" title="注意outputs维度，对应和labels做交叉熵的维度"></a>注意<code>outputs</code>维度，对应和<code>labels</code>做交叉熵的维度</h3><ul><li><code>outputs</code>维度是: (seqLen, batch_size, hidden_size)</li><li>为了能和labels做交叉熵，需要reshape一下: outputs.view(-1, hidden_size)</li></ul><h3 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h3><h4 id="数据准备-1"><a href="#数据准备-1" class="headerlink" title="数据准备"></a>数据准备</h4><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchinput_size <span class="token operator">=</span> <span class="token number">4</span>hidden_size <span class="token operator">=</span> <span class="token number">4</span>batch_size <span class="token operator">=</span> <span class="token number">1</span>seq_len <span class="token operator">=</span> <span class="token number">5</span>num_layers <span class="token operator">=</span> <span class="token number">1</span>idx2char <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">]</span>x_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>    <span class="token comment"># hello中各个字符的下标</span>y_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>    <span class="token comment"># ohlol中各个字符的下标</span>one_hot_lookup <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>x_one_hot <span class="token operator">=</span> <span class="token punctuation">[</span>one_hot_lookup<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> x_data<span class="token punctuation">]</span> <span class="token comment"># (seqLen, inputSize)</span>inputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span>x_one_hot<span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span>seq_len<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> input_size<span class="token punctuation">)</span>labels <span class="token operator">=</span> torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">(</span>y_data<span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>inputs<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> labels<span class="token punctuation">.</span>shape<span class="token punctuation">)</span></code></pre><blockquote><p>输出结果：</p><pre class="language-bash" data-language="bash"><code class="language-bash">torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span>, <span class="token number">1</span>, <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> torch.Size<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></blockquote><h4 id="构建模型-1"><a href="#构建模型-1" class="headerlink" title="构建模型"></a>构建模型</h4><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">class</span> <span class="token class-name">Model</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> num_layers<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>Model<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>num_layers <span class="token operator">=</span> num_layers        self<span class="token punctuation">.</span>batch_size <span class="token operator">=</span> batch_size        self<span class="token punctuation">.</span>input_size <span class="token operator">=</span> input_size        self<span class="token punctuation">.</span>hidden_size <span class="token operator">=</span> hidden_size        self<span class="token punctuation">.</span>rnn <span class="token operator">=</span> nn<span class="token punctuation">.</span>RNN<span class="token punctuation">(</span>input_size<span class="token operator">=</span>self<span class="token punctuation">.</span>input_size<span class="token punctuation">,</span> hidden_size<span class="token operator">=</span>self<span class="token punctuation">.</span>hidden_size<span class="token punctuation">,</span> <span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">)</span><span class="token punctuation">:</span>        hidden <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>self<span class="token punctuation">.</span>num_layers<span class="token punctuation">,</span> self<span class="token punctuation">.</span>batch_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span>        out<span class="token punctuation">,</span> _ <span class="token operator">=</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> hidden<span class="token punctuation">)</span>    <span class="token comment"># 注意维度是(seqLen, batch_size, hidden_size)</span>        <span class="token keyword">return</span> out<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>hidden_size<span class="token punctuation">)</span> <span class="token comment"># 为了容易计算交叉熵这里调整维度为(seqLen * batch_size, hidden_size)</span>net <span class="token operator">=</span> Model<span class="token punctuation">(</span>input_size<span class="token punctuation">,</span> hidden_size<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span>criterion <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span></code></pre><h4 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h4><pre class="language-python" data-language="python"><code class="language-python">epochs <span class="token operator">=</span> <span class="token number">15</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>    optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>     <span class="token comment"># print(outputs.shape, labels.shape)</span>    <span class="token comment"># 这里的outputs维度是([seqLen * batch_size, hidden]), labels维度是([seqLen])</span>    loss <span class="token operator">=</span> criterion<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> labels<span class="token punctuation">)</span>     loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>     optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    _<span class="token punctuation">,</span> idx <span class="token operator">=</span> outputs<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>     idx <span class="token operator">=</span> idx<span class="token punctuation">.</span>data<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Predicted: '</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>idx2char<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">', Epoch [%d/15] loss = %.3f'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><blockquote><p>输出结果：</p><pre class="language-bash" data-language="bash"><code class="language-bash">Predicted:  ololl, Epoch <span class="token punctuation">[</span><span class="token number">1</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">1.189</span>Predicted:  ollll, Epoch <span class="token punctuation">[</span><span class="token number">2</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">1.070</span>Predicted:  ollll, Epoch <span class="token punctuation">[</span><span class="token number">3</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.976</span>Predicted:  ohlll, Epoch <span class="token punctuation">[</span><span class="token number">4</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.883</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">5</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.788</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">6</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.715</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">7</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.652</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">8</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.603</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">9</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.570</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">10</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.548</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">11</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.530</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">12</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.511</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">13</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.488</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">14</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.462</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">15</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.439</span></code></pre></blockquote><h2 id="将一个单词变成vector"><a href="#将一个单词变成vector" class="headerlink" title="将一个单词变成vector"></a>将一个单词变成vector</h2><h3 id="One-hot-encoding-of-words-and-characters"><a href="#One-hot-encoding-of-words-and-characters" class="headerlink" title="One-hot encoding of words and characters"></a>One-hot encoding of words and characters</h3><ul><li><p><strong>one-hot vectors high-dimension –&gt; lower-dimension</strong></p></li><li><p><strong>one-hot vectors sparse –&gt; dense</strong></p></li><li><p><strong>one-hot vectors hardcoded  –&gt; learn from data</strong></p></li></ul><h3 id="Embedding"><a href="#Embedding" class="headerlink" title="Embedding"></a>Embedding</h3><p><img src="/pic/ont_hot_VS_embedding.png" alt="ont_hot_vector VS embedding"></p><p><img src="/pic/embedding.png" alt="embedding"></p><h3 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h3><h4 id="构建模型-2"><a href="#构建模型-2" class="headerlink" title="构建模型"></a>构建模型</h4><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token comment"># parameters</span>num_class <span class="token operator">=</span> <span class="token number">4</span> input_size <span class="token operator">=</span> <span class="token number">4</span> hidden_size <span class="token operator">=</span> <span class="token number">8</span> embedding_size <span class="token operator">=</span> <span class="token number">10</span> num_layers <span class="token operator">=</span> <span class="token number">2</span> batch_size <span class="token operator">=</span> <span class="token number">1</span> seq_len <span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">class</span> <span class="token class-name">Model</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>Model<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>emb <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Embedding<span class="token punctuation">(</span>input_size<span class="token punctuation">,</span> embedding_size<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>rnn <span class="token operator">=</span> nn<span class="token punctuation">.</span>RNN<span class="token punctuation">(</span>input_size<span class="token operator">=</span>embedding_size<span class="token punctuation">,</span> hidden_size<span class="token operator">=</span>hidden_size<span class="token punctuation">,</span> num_layers<span class="token operator">=</span>num_layers<span class="token punctuation">,</span> batch_first<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>hidden_size<span class="token punctuation">,</span> num_class<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        hidden <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>num_layers<span class="token punctuation">,</span> x<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hidden_size<span class="token punctuation">)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>emb<span class="token punctuation">(</span>x<span class="token punctuation">)</span>                 <span class="token comment"># (batch, seqLen, embeddingSize) </span>        x<span class="token punctuation">,</span> _ <span class="token operator">=</span> self<span class="token punctuation">.</span>rnn<span class="token punctuation">(</span>x<span class="token punctuation">,</span> hidden<span class="token punctuation">)</span>      <span class="token comment"># 输出(𝒃𝒂𝒕𝒄𝒉𝑺𝒊𝒛𝒆, 𝒔𝒆𝒒𝑳𝒆𝒏, hidden_size)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>fc<span class="token punctuation">(</span>x<span class="token punctuation">)</span>                  <span class="token comment"># 输出(𝒃𝒂𝒕𝒄𝒉𝑺𝒊𝒛𝒆, 𝒔𝒆𝒒𝑳𝒆𝒏, 𝒏𝒖𝒎𝑪𝒍𝒂𝒔𝒔)</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> num_class<span class="token punctuation">)</span>    <span class="token comment"># reshape to use Cross Entropy: (𝒃𝒂𝒕𝒄𝒉𝑺𝒊𝒛𝒆×𝒔𝒆𝒒𝑳𝒆𝒏, 𝒏𝒖𝒎𝑪𝒍𝒂𝒔𝒔)</span>        net <span class="token operator">=</span> Model<span class="token punctuation">(</span><span class="token punctuation">)</span>criterion <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>net<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.05</span><span class="token punctuation">)</span></code></pre><h4 id="准备数据并训练"><a href="#准备数据并训练" class="headerlink" title="准备数据并训练"></a>准备数据并训练</h4><pre class="language-python" data-language="python"><code class="language-python">idx2char <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">]</span> x_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># (batch, seq_len) </span>y_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>    <span class="token comment"># (batch * seq_len)</span>inputs <span class="token operator">=</span> torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">(</span>x_data<span class="token punctuation">)</span>   <span class="token comment"># Input should be LongTensor: (batchSize, seqLen)</span>labels <span class="token operator">=</span> torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">(</span>y_data<span class="token punctuation">)</span>   <span class="token comment"># Target should be LongTensor: (batchSize * seqLen)</span>epochs <span class="token operator">=</span> <span class="token number">15</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>    optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    outputs <span class="token operator">=</span> net<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>     loss <span class="token operator">=</span> criterion<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> labels<span class="token punctuation">)</span>     loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>     optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>    _<span class="token punctuation">,</span> idx <span class="token operator">=</span> outputs<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>     idx <span class="token operator">=</span> idx<span class="token punctuation">.</span>data<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Predicted: '</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>idx2char<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">', Epoch [%d/15] loss = %.3f'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><blockquote><p>输出结果：</p><pre class="language-bash" data-language="bash"><code class="language-bash">Predicted:  ollll, Epoch <span class="token punctuation">[</span><span class="token number">1</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">1.290</span>Predicted:  olooo, Epoch <span class="token punctuation">[</span><span class="token number">2</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">1.071</span>Predicted:  ollol, Epoch <span class="token punctuation">[</span><span class="token number">3</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.913</span>Predicted:  ollol, Epoch <span class="token punctuation">[</span><span class="token number">4</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.785</span>Predicted:  ollol, Epoch <span class="token punctuation">[</span><span class="token number">5</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.660</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">6</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.541</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">7</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.435</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">8</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.343</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">9</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.251</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">10</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.171</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">11</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.121</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">12</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.081</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">13</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.052</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">14</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.036</span>Predicted:  ohlol, Epoch <span class="token punctuation">[</span><span class="token number">15</span>/15<span class="token punctuation">]</span> loss <span class="token operator">=</span> <span class="token number">0.025</span></code></pre></blockquote><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>可以看到使用embedding之后收敛的更快了，说明模型的学习能力变强了</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode】并查集深入浅出，一文吃透！</title>
      <link href="suan-fa/47fefd104e9e.html"/>
      <url>suan-fa/47fefd104e9e.html</url>
      
        <content type="html"><![CDATA[<h2 id="【LeetCode】并查集"><a href="#【LeetCode】并查集" class="headerlink" title="【LeetCode】并查集"></a>【LeetCode】并查集</h2><blockquote><p>原文同步在：<a href="https://github.com/EricPengShuai/Interview/blob/main/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86.md">https://github.com/EricPengShuai/Interview/blob/main/algorithm/并查集.md</a></p></blockquote><h3 id="0-概念"><a href="#0-概念" class="headerlink" title="0. 概念"></a>0. 概念</h3><p>并查集主要用于解决一些 <strong>元素分组</strong> 问题，通过以下操作管理一系列不相交的集合：</p><ul><li>合并（Union）：把两个不相交的集合合并成一个集合</li><li>查询（Find）：查询两个元素是否在同一个集合中</li></ul><p>具体实现方面，使用一个数组 <code>parent</code> 存储每个变量的 <strong>父节点信息（每个节点的连通分量信息）</strong>，其中的每个元素表示当前变量所在的连通分量的父节点信息，如果父节点是自身，说明该变量为所在连通分量的根节点。初始化时所有变量的父节点都是它们自身。</p><ol><li><p>初始化：将每个节点的父节点指向自己。表示每个每个节点最开始都是自己一个集合，也就是节点的父节点都是自己</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">parent</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">iota</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> parent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><ol start="2"><li><p>查找时，沿着当前分量的父节点一路向上查找，直到找到根节点，这个过程也叫 <strong>路径压缩</strong>，具体来说有两种方法</p><ul><li><strong>隔代压缩</strong>：性能比较高，虽然压缩不完全，不过多次执行隔代压缩也能达到完全压缩的效果，这个方法也叫迭代查找</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        x <span class="token operator">=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><strong>完全压缩</strong>：需要借助系统栈，使用递归的写法。或者先找到当前节点的根节点，然后把沿途上所有的节点都指向根节点，得遍历两次，这个方法也叫递归查找</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><ol start="3"><li><p>合并时，将属于同一类的节点合并到一个树中，设计 <code>union(x, y)</code> 将 x 的根节点指向 y 的根节点</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 最好不要申明为 union，这是一个关键字</span><span class="token keyword">void</span> <span class="token function">Union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    parent<span class="token punctuation">[</span><span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在合并时还可以 <strong>按秩合并</strong>，秩没有明确的定义，一般可以指以节点为根节点的子树的深度，也可以表示以根节点的子树的节点个数，考虑按秩合并之后可以让查找的效率更高</p><ul><li><p>以秩比较大的节点为根合并：最大深度没有增加</p><img src="https://img-blog.csdnimg.cn/img_convert/c8a1efe9b35e7d432f8a11df4cb9a82c.png#pic_center" style="zoom:30%;" align="left"></li><li><p>以秩比较小的节点为根合并：最大深度有增加</p><img src="https://img-blog.csdnimg.cn/img_convert/e6708ec5ce7c00dbbcd9989104add532.png#pic_center" style="zoom:30%;" align="left"></li></ul></li></ol><h3 id="1-模板"><a href="#1-模板" class="headerlink" title="1. 模板"></a>1. 模板</h3><h4 id="1-1-维护深度——秩"><a href="#1-1-维护深度——秩" class="headerlink" title="1.1 维护深度——秩"></a>1.1 维护深度——秩</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> parent<span class="token punctuation">;</span>    vecotr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> rank<span class="token punctuation">;</span><span class="token comment">// 维护以节点为根节点的子树的深度——秩</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        parent<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">iota</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> parent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                rank <span class="token operator">=</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">// 隔代压缩，迭代查找</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            x <span class="token operator">=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">// 按秩合并</span>    <span class="token keyword">void</span> <span class="token function">Union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x_root <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> y_root <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x_root <span class="token operator">==</span> y_root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment">// 如果已经处于一个集合了直接返回</span>                <span class="token comment">// 注意这里只要最大的深度不变就不需要修改根节点的秩</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>x_root<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rank<span class="token punctuation">[</span>y_root<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 以深度大的节点为根</span>            parent<span class="token punctuation">[</span>x_root<span class="token punctuation">]</span> <span class="token operator">=</span> y_root<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span>x_root<span class="token punctuation">]</span> <span class="token operator">&gt;</span> rank<span class="token punctuation">[</span>y_root<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>y_root<span class="token punctuation">]</span> <span class="token operator">=</span> x_root<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// 深度一样，谁作为根节点都可以</span>         parent<span class="token punctuation">[</span>y_root<span class="token punctuation">]</span> <span class="token operator">=</span> x_root<span class="token punctuation">;</span>            rank<span class="token punctuation">[</span>x_root<span class="token punctuation">]</span> <span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 作为根节点的高度会+1</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="1-2-维护连通分量个数"><a href="#1-2-维护连通分量个数" class="headerlink" title="1.2 维护连通分量个数"></a>1.2 维护连通分量个数</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> parent<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> size<span class="token punctuation">;</span><span class="token comment">// 当前节点为根节点的子树节点总数</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token comment">// 连通分量个数</span>   <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        count <span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token comment">// 初始是每个节点都是一个连通分量</span>        parent<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">iota</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> parent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">iota</span><span class="token punctuation">(</span>size<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> size<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">// 完全压缩，递归查找</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">// 按照连通分量个数合并</span>    <span class="token keyword">void</span> <span class="token function">Union</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x_root <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> y_root <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x_root <span class="token operator">==</span> y_root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment">// 如果已经处于一个集合了直接返回</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>size<span class="token punctuation">[</span>x_root<span class="token punctuation">]</span> <span class="token operator">&gt;</span> size<span class="token punctuation">[</span>y_root<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 节点少分量合并到节点多的分量上</span>            parent<span class="token punctuation">[</span>y_root<span class="token punctuation">]</span> <span class="token operator">=</span> x_root<span class="token punctuation">;</span>            size<span class="token punctuation">[</span>x_root<span class="token punctuation">]</span> <span class="token operator">+=</span> size<span class="token punctuation">[</span>y_root<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>x_root<span class="token punctuation">]</span> <span class="token operator">=</span> y_root<span class="token punctuation">;</span>            size<span class="token punctuation">[</span>y_root<span class="token punctuation">]</span> <span class="token operator">+=</span> size<span class="token punctuation">[</span>x_root<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token operator">--</span> count<span class="token punctuation">;</span> <span class="token comment">// 合并时候连通分量个数减1</span>    <span class="token punctuation">}</span>        <span class="token keyword">int</span> <span class="token function">getSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> root <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> size<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>初始不知道节点个数的写法：维护哈希表</strong></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UnionFind</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> parent<span class="token punctuation">;</span>    <span class="token comment">// 连通分量个数</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">==</span> parent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> index<span class="token punctuation">;</span>            <span class="token comment">// 这里最初不知道节点个数需要在哈希表加入元素时候初始化</span>            count <span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">!=</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>            parent<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">Union</span><span class="token punctuation">(</span><span class="token keyword">int</span> index1<span class="token punctuation">,</span> <span class="token keyword">int</span> index2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> parent1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>index1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> parent2 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>index2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// *这步骤很重要，直接把两节点首领一样的结果返回过滤，否则会让count多减1*</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent1 <span class="token operator">==</span> parent2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        parent<span class="token punctuation">[</span>parent1<span class="token punctuation">]</span> <span class="token operator">=</span> parent2<span class="token punctuation">;</span>        count <span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 也是合并时候连通分量减1</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2. 例题"></a>2. 例题</h3><p><strong>基础</strong></p><table><thead><tr><th>题目</th><th>说明</th><th>答案</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/satisfiability-of-equality-equations/">990. 等式方程的可满足性</a></td><td>先将==全部合并，其次找出!=的根节点，如果一样则不行</td><td><a href="https://leetcode.cn/submissions/detail/136424817/">通过</a></td></tr><tr><td><a href="https://leetcode.cn/problems/number-of-provinces/">547. 省份数量</a></td><td>简单的并查集，维护连通分量个数，也可以 DFS 和 BFS</td><td><a href="https://leetcode.cn/submissions/detail/375522024/">通过</a></td></tr></tbody></table><p><strong>进阶</strong></p><table><thead><tr><th>题目</th><th>说明</th><th>答案</th></tr></thead><tbody><tr><td><a href="https://leetcode.cn/problems/regions-cut-by-slashes/">959. 由斜杠划分区域</a></td><td>重点在将斜杠怎样拆分成单元格，外部添加成3*3（还可以DFS），内部分解成4*4</td><td><a href="https://leetcode.cn/submissions/detail/141243167/">通过</a>   <a href="https://leetcode.cn/submissions/detail/375476296/">DFS</a></td></tr><tr><td><a href="https://leetcode.cn/problems/accounts-merge/">721. 账户合并</a></td><td>维护账户到id的哈希表，合并含有相同账户的id</td><td><a href="https://leetcode.cn/submissions/detail/375528105/">通过</a></td></tr><tr><td><a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用</a></td><td>Kruskal 算法：构造边，排序之后合并连通分量，维护分量长度和节点个数</td><td><a href="https://leetcode.cn/submissions/detail/389340427/">通过</a></td></tr><tr><td><a href="https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/">1697. 检查边长度限制的路径是否存在</a></td><td>离线查询（询问全部给出，但是没必要按照<strong>询问的顺序</strong>处理，可以排序之后离线处理），注意自定义 sort 排序时最好加上引用<code>&amp;</code></td><td><a href="https://leetcode.cn/submissions/detail/389035257/">通过</a></td></tr><tr><td><a href="https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/">2503. 矩阵查询可获得的最大分数</a></td><td>可以考虑<code>点权</code>或者<code>边权</code>（边权就考虑较大边），排序之后然后<strong>离线查询</strong>，询问排序下标就可以，可以看看灵神视频题解</td><td><a href="https://leetcode.cn/submissions/detail/389036925/">边权</a>   <a href="https://leetcode.cn/submissions/detail/389025813/">点权</a></td></tr></tbody></table><ul><li><input disabled="" type="checkbox"> <a href="https://leetcode.cn/problems/evaluate-division/">399. 除法求值</a> </li><li><input disabled="" type="checkbox"> <a href="https://leetcode.cn/problems/bricks-falling-when-hit/">803. 打砖块</a> </li><li><input disabled="" type="checkbox"> <a href="https://leetcode.cn/problems/smallest-string-with-swaps/">1202. 交换字符串中的元素</a></li></ul><h3 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h3><ul><li><a href="https://leetcode.cn/problems/satisfiability-of-equality-equations/solution/shi-yong-bing-cha-ji-chu-li-bu-xiang-jiao-ji-he-we/">使用并查集处理不相交集合问题（Java、Python）</a></li><li><a href="https://leetcode.cn/problems/satisfiability-of-equality-equations/solution/shou-hui-tu-jie-shou-xie-unionfind-bing-cha-ji-bu-/">「手画图解」手写UnionFind，并查集 不再畏惧</a></li><li><a href="https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/solution/by-endlesscheng-qeei/">LC2503：两种写法：离线询问 + 并查集 / 最小堆（Python/Java/C++/Go）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python】将列表转字符串</title>
      <link href="bian-cheng-bei-wang/4d78f241e58d.html"/>
      <url>bian-cheng-bei-wang/4d78f241e58d.html</url>
      
        <content type="html"><![CDATA[<p><strong>前提条件：列表中的元素全部是字符串</strong></p><pre class="language-python" data-language="python"><code class="language-python"><span class="token builtin">list</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token comment"># 首先需要将列表的元素全部转换为str，以下两种方法</span><span class="token comment"># 使用for循环</span>list1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">list</span><span class="token punctuation">]</span><span class="token comment"># 使用map函数</span>list2 <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span><span class="token comment"># 使用join将列表中的元素串起来</span>res1 <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>list1<span class="token punctuation">)</span>res2 <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>res1<span class="token punctuation">,</span> res2<span class="token punctuation">)</span></code></pre><p>输出如下：</p><p><img src="https://img-blog.csdnimg.cn/20200403182820156.png" alt="res1和res2结果如下"></p>]]></content>
      
      
      <categories>
          
          <category> 编程备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python】类中函数相互调用方法</title>
      <link href="bian-cheng-bei-wang/7d7b20d80e52.html"/>
      <url>bian-cheng-bei-wang/7d7b20d80e52.html</url>
      
        <content type="html"><![CDATA[<h4 id="方法一：self-方法（参数列表），注意参数列表不需要self"><a href="#方法一：self-方法（参数列表），注意参数列表不需要self" class="headerlink" title="方法一：self.方法（参数列表），注意参数列表不需要self"></a><strong>方法一：self.方法（参数列表），注意参数列表不需要self</strong></h4><h4 id="方法二：类名-方法（self，参数列表）"><a href="#方法二：类名-方法（self，参数列表）" class="headerlink" title="方法二：类名.方法（self，参数列表）"></a><strong>方法二：类名.方法（self，参数列表）</strong></h4><p>具体代码例子如下：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># 利用测试次数和鸡蛋个数的关系变化带来的确定的楼层数来解题</span><span class="token keyword">class</span> <span class="token class-name">dropeggs</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">superEggDrop</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> K<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> N<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        remainTestCount <span class="token operator">=</span> <span class="token number">1</span>        <span class="token comment"># 方法一</span>        <span class="token comment"># while self.getConfirmFloors(remainTestCount, K) &lt; N:</span>        <span class="token comment">#     remainTestCount += 1</span>        <span class="token comment"># return remainTestCount</span>                <span class="token comment"># 方法二</span>        <span class="token keyword">while</span> dropeggs<span class="token punctuation">.</span>getConfirmFloors<span class="token punctuation">(</span>self<span class="token punctuation">,</span> remainTestCount<span class="token punctuation">,</span> K<span class="token punctuation">)</span> <span class="token operator">&lt;</span> N<span class="token punctuation">:</span>            remainTestCount <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> remainTestCount    <span class="token comment"># 在remainTestCount个测试机会、eggsCount个鸡蛋可以确定的楼层数量</span>    <span class="token keyword">def</span> <span class="token function">getConfirmFloors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> remainTestCount<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> eggsCount<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token comment"># 如果remainTestCount=1，只能移动一次可以确定楼层0（在一楼扔鸡蛋碎了）</span>        <span class="token comment"># 如果eggsCount=1，只能从一楼开始往上面测试扔鸡蛋最多确定remainTestCount个楼层</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>remainTestCount <span class="token operator">==</span> <span class="token number">1</span> <span class="token keyword">or</span> eggsCount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> remainTestCount        <span class="token keyword">return</span> self<span class="token punctuation">.</span>getConfirmFloors<span class="token punctuation">(</span>remainTestCount<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> eggsCount<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>getConfirmFloors<span class="token punctuation">(</span>remainTestCount<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> eggsCount<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020总结</title>
      <link href="sheng-huo-sui-bi/6c249f289724.html"/>
      <url>sheng-huo-sui-bi/6c249f289724.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0609875a890474650cc542eb3889846dcf205dc652bc10026211fec91ef1ba9c">6802c8327ff80937d8b806ec285ce0fac9a755142ae6e2d068b0a504892a38134c79cbfaa8bd329c5c029d84299b6864db1f755ad9fa4bdb624ed8dc66e161e8c8ac28c66fc63de585151849fefa4c2e9164746e256756616627187b077aa48cfb1c921012a7725cad527555592fae768dc27746e5dd77575cbfbb169c487aaa55c87b89182f5d43630e54ab6cecaad40971367165c2d098188158c43000386c3e8529373d24a0fd00bd03a4acc4e32b36364f12ae1fc12e7a42b1942a1f62c4823c10bb63a1be46f5122c11ddc0f05ba93ebb925c94d1e9e0ea6a2a9e252324ae2afd18da5122bd8e274b6b28851dbc760baa8f1681847ecec8aa78a573e4a96255c3e7702c0d38bc7704b8e50f3f8f36cc467a80b53d167bd743298a304e165f1a8c3a85c6864e962303ad930b165c88ef0ab96feea970fc35810d060dec864d06b40660de7659a775627fd6c1dbdd90eae1b277824b3c3af73be893a8b0371111394bf4057390325c34806a9fe52d6526f2bc485e0e350a43dbc161d18f2de6c7813a638d182df400e50d61b38d49c7f1a40d8335e7f8a28a725eaf11cbd715bfb8e60ffa5aae2d105e46dae8eff4e6662480af5637a4a916e166f7bea08a51ada3eacb3c536acb5a15c567a70c8c141c091ae6b0d399990c9ff806d141e5b3b2ff9d79e47610a9c161617e830b9e01e43a61e65d29cb77e3176c636c92df56942acb1f5ee3e5302f51c2e5ff8eac44a4fe4e60e207b0d57b1efdbabbdf472a4b33a212d6cc2f41a7e8a2982eae6b1000c10b3519885638775e70408ddd98704945d7e78a47772d8cd454726ff1e06d7466b29dff2e8fa3723fdd8d9fed2315acf1f72cefa3321ef1a60ef68fdf806eb5d2c1eaac6424da6f5a6da22e4aea8298193a3d0f26507c218edb077817960a15b84bbb3da8b4a9ffd3b346f7dc63f7526da14a5a3e56ba00e353fdb4385bb9a3c68737658dc0b1e69aae8c28abab8e68e87ad902a5a625f64880920a8d77a56961cd666e6a919dbefbac0f1692974355cbfa49d54e82b290a84cad613c6da48f65a74cbca3d7de839ec4ad4247fe57e9190539089185b53b9d089658949fc4a468a76ed579516c4e52b55f1ae7332028f43adf4420b4cc9fc3f3270375b5a69379082c51ca2206ace6355115b0dca89f3e41795f2705f4912b956300f89f832ff972ab55f50fa16c72a67180ecc78494f474c69dfe302e5192117b49aabfedda80b2ef55510cafbc6f3ebe72b127d87e605bbb6f47ea1b5f05b22e3bad81c99848ca40817b227ba9bfaf6fbaed85bb8c75e9556f4affb7d75cc7202129b80ea59a43741140aeb79e897ba20b44a584dab8518b7b7dbec549143ef47512198cd2d1d44d6168cbe0101b278e33ab198a5670c67295dce6d8a73f8996bc85e330abdbc44f24d8737f31b6d069c060b1f74fa014c31074c89cd43aa01f7c619d6c6ecee009068c9545d37ac394c999fc79a82a79be799443d6972ea005056284aa440a75cd213f776cee1bc386c855dd0029d532adc8e64f047e3133ccf847ae3222ff5f6201387050e73e3aa2e2aaddf9113fcd52987323184ad8df89e9b73c1d9dd540c815dfa9775ee9462d5f882d898c35f8ed4b8b7500b9a7bfa5b16f8bb9e52e33e76425fa0d0b89b45dbda98411d67491b577003dc70d5cac0605fe07c5e13042e31be1a6c19a51d0d1bd83ca5f6cdb70deffb827535de4956c828f9c52ad13e15748109b101a21002754ed45d0c3bb04a1e0a13e30b650c64721974a18bf6d3409c6fc2144eb5eab6231b0a9a560f9f833ab740b7b2e5981c98fd2ac1da8c9b8c9061ba1112db3bfe314095dfaed5fd859de21f1461ae5038910cdafd242f9d79038eef23866d209421cce1c276b8a182e3a3e2da8afcba56c6659cb566d33d5acc44dde5d37af09bf13652d157fb819c27eb755c81ba0ec48cd0a623bb74501d51edfc049bab811dd851ca7124c45d97f5cbe3e0b1bcc9f25a41e1ece2bec48b2b30e04c6772489fa502840e9b0c72f80e70a0f2b4f3d9b852312aacbcb058a0d960f8ad9c65dec49847a3f3bf1808109315bc74a282604d122acf116511428f94e48272dc1f2b9eefd524f346406a8389a1f8f3d3909fd9387ddebdbe3ce9061f8759174657bae3a30d1a407b288e6b116be6474c5164a0c2d0f767dfabdf336e82b83e4133c9a19ca9a150f51c72a27c9bb49ae2e042f832852c54b68444a7f7bd852e2d67bb8e37f9912fee087061cb8138438d1f271dd81965a1d258ed7ceb173a932576d7997f9983ea0669b91ec41810992fab32fb0a11292948f27f455c6ab3540821129b16d928086ffd0415654f11897e44709a777ae4e879e750755d9920465548f5723504ac346285e62c33f996a91cbd44f6e1b0107060f8bc9aca9f6b702f9630611108ff962a6ae797dc8564dcd50b3728fef6e59ebcaf0bfa2bdeb66c487ff80a994444bb23735157df9d15eb516a7f833bd97b76cf86abcd1eddcfe0b1f117ab2ec828806445b61be8d4b4b32410e4c2ae2e63b99dd20b2417e6427ad99340eea17bd91b3089343b5b0dc643e7918a31b967c5439e70d47688410c5e34a0cbf8d1a062f28e8c066b2a6f8a9697e7275bfef2ffef8d7cbb453e11a2eebcec0e3ec04aa345542708a3bcc8f3b93d9dcfd646f58ddbcfbdf4cff22fef4194fadce65a7e8d709611978db4c0705d979fe0213eadcba88460420d0940c6680fd228bf329a346b434fcdd29e2032221352f545b3fc8e6d710165b6a7a7f82fe738b011c5434d87d951c2059cf2a9435285eb55c1492239a707400857118f9a0f0813bb30d2e1a077a0e7a55257ab47efe037ed7f7a8289073def28cc78ac11fff9ed5a458b9b692d7c87c7549054ccdb60b876c9ce416b744bd61c2b0a7838e779d99b59923c5cc54bce220d297e50bb6ad485d4131d0b5ce0cc7103ad6ccc1757ec71a6f48457be2ff9a37e57b52826c08e9853091bc0a8d77f66872c3f024f0573139346bdfb5e797a6bad70725b387d066e93334728c10b0a689d0cfe7bd01cc4359973943bb3b56b3813bfd2af298a24ec1dea3d038279775e6b9ba50c8d788502936b83928739f596fd1db881ea5e2fba4ee21e9a58d803aaa0ae89e402f925a9f8b17f63d1534b29f328d3494a1dbe589c7f07035492207c0967219698ce9ffaf53ce817d841b37162462ffa82268a55b5c38e4655d22bfee3f3b43b7d0ac2b39a2b0bf6b43df79f1f7791163f9de460f5ff0a1fe5fe155aeba2576fff5379cdf369c9ec8c4f468ea0c90d2b9924d01db8120fc14d8c49856df29d1d10c920027b85ed46526f09c75403d9cd77bfa9e948a48e3efd7893f5f8ea183e4b05c90a1aa50637865401d55389d3a141f6026fdce7016b7d33946f4f0931ff9407006c6fac47c4ea01db5a7fadb07c5a326850caf5495216c0051de313e499ac8855d0bf79efcaa215d5a50d927bce7e6c2df770adf30efe613fd0c2d0b9b17b86d6ead80fcf9359456384cca6aa384c2eb014981c309f84770162dc4bc6698ef0ecf2278aa4863c66bc01fee28054aaf480872bf23620138c548f9e497f045dedf25ccc6d692d9e950871d2c6acbd0011cc5aa01228847f45bc64df7db9464b9e88e910525127b2bc025e4e5072395465add0899b5535b65c515d3da5e2864c6a15a9ea293424fc0dca78a61be6816b2bb90b0fa2799f08bf4fa2abc079334ba35903b12c9dd63729b4a5c26ee4fb89b1ad7868c67f9a9408be3a486f4fca52df06aadf58f602108a00384b803c11c6fb92c6055ac0cb78eb36463b1a9069c357a7c5f56ecab1dc9502d54f17ff1cf932c1ee029243eddf40d80b95e3c3d3585cf5b747df6cfe4ce6a0b833b73d9c7fc178ed92d8250155206d2498bfbb10ac00f2ec0c223884fe8320595bd3221cac2fbfe5804e404f0807122bdf8a2228cf946ea6ab5319c09a98482e527edd1772d698e5633a985fa3a7f1f34749ad7cf80ab6ed9cab4bae0dcd4103f6786c61273fb8cfd0d3aab46c94bf727a4c679e278d0ca855704531ac8736dcdd1d65517f9189e5363a5eae4ccf4bafd0f9d3bfa83c0fa5e7351d63c236b2015ed78c526bb9dcb50ba504e964a7a5024f52638fe9a52b2127c6d44cd7099d2bdf8d7e9ece6906ac7ee396f19019615b0417338bc4fa91b5a115f57f2411ca3de5ee4fb181369157b770e46f47ef71457f139b3b295249027704b26df22330ca0c9e796bd40d22ae396ad5972d144114f9146540ab8d35cff824589c119dce5b338ad0e166c464b2e703071a9854adb399426f17a15ff7c12a82b5af736e508aa433bfe1b4f2222a1df66bd2280c023d6273c4121b40ea976e4ffc21136d786954f3532760ea3e1b38a8e3c09207cedded3f84ec2cf85e3abe9751ad7dadba8aa1d4f9ea9860d37d8fba229a197cb8a35b3e96f73afe5fbef9ca8b507c253804f0bd2ea4cb43b43233730e2c6bd19704197df0f430db7b08eeceaef7806b54a36a9772abddd7171be6acbc7a8c506b6258eb07c50632f399d5bfc9c656167067d75e3bb88c9500836c78f6da1eb89f969717d8b2e5b0bb0b9f314af6ca92af9075431a6764694ed4daba41c4453779b31acea70836967d76ad05e36fc7e0e63057836d2ae7d0f2fb31b479ec5281690edfe28ffa0fdecc6a3fad93cbb28901cfe71b85d76422608520dbc7a732cb662b1c9396bf42674094c732aa5e6d04eeb4216699ddf5b6e0eebb44d70b19cc030aed7c4474832c6b1b40497c30460d51aadf51aefb04f8814b1983e26c6b12057774d84624db36e6c85d213d56e91ea23e310c4702af7e804fccd242c102cd0990879350b208939f3db5e3d582411c3d5d015152fa6f4bc94ea8734e1fb3bfe60ded23c4ac25a3a522a80479d0b5104b8ada4fdb816b4188870b10fd360f765f333c0f3884b510d1d7a22065c7cce5339ac419f635784eb8b3a6a8d5c557784d80459730430fd478b4192ca7c6c8bd6817f043616a1fd03c4d0d97e0739bd503b57485cbf9967a527b54539b6d5f29e0a84acee38b67f7b6710348811dc83b59b54d645150183331abdeaa7461802d7c22653727ac239654175e6b0c72798062ca7bf1fa2899e497bcd7d392e9c293b146dca395dc5646468781cf66feeec5615850582e04d7b2ac9285a42a557a7beacd2e92420a7fa86a995a1373896d6bb0438b6543999b62e27f863bde4712247538dee71311bb04eed74576b92a57325a3d9caeab97646b724d872561853bde2e171b2dbaec36087cf80920910b8e6cd5b8e5a4ba5fcc2472c01a695301fef13064e3ceabf99c693a13f9daad516c0e6e84e2fbb541c303948990156315e8eb0160f5a0cd96297836db9cf0c5c44919bac6237993b233ae336239656001a5fc2d822a47ecbfde2bf8c870de126e1641af50c6a6198224bb22816fece0c28fb1113c08d5ad51bd9682b5e3d63b40ea92c0163c1d31be4212b4945020ca444385e3c73d34232ead14804e249c841cd4055f0ac1a490b6164ee2fab4e44dcdf979e67b98be80095d47b6d90395443abbd3b64428796601690acc61f1adcd252ddf6a805147b63dd23360f18f8b8b06fa708daf78d71c175a22ee4f0682f3ee8d64945cb152495802f6e900a9acba4548b9ce49b62aba43ac1367d92c124c546ff720132824812e04bc110f9f65f75aa7fcd5cf7344b8c16c7596c6faa3d290f5f55c9060da4f702e72b6660daa0ab381e768ba3797dc26f662a1561e0d3f8ba08bedeaaf6408b2d7f4bc99f55ed885b1430ae4876fb42c4ccd7454eac74a607ff83afba981a1e4cc4ab93078591ffe2fb33d8c5972e2e4668b404adc330d70a59a35d198f78d9045dc47718ead48fb9a84d6f14f5b266bff7b1419f047982eaea645e3edd319a89c9bfd755b7c7bad9831191764feafb7bc28d3bb7a34e1a4d3e92897efa6d58c03db2115ea53c8469f7de7abf645deca10f88ec04d86a66786a4c59c01e74321504ad72b9c40a85ce753fdd8196573c61faa8f0c0fb3d2eb4df5fe34a081982dac323f46044fb82fc80fd3b4e251fe76ff2fb39476fcf1ff3eb699e08d8b1b781b9229373ea89ea2103a6976e6197ae793b1d1547ed3fd4a0bb0d7069d94c3c92922a8670218ba1bf56bef4e9733def2220d23e68e9cb1d74c3e6e4ca33330933a97de00209ebdf5981362e14d68b33b717995be18a42039b2c3888cb71623ed00cfb5c454aa2d75301f887d3636d20e3cd6c0b01f40b8894a4a01db882b9dc8e630733a87b700807a58f0525ca0d20a389c01c0bcd1f8aefdf4ca66bfccf732e9768232e00b36b3a299ea73c851b57e2696b06a81beac18d2ecc51bf36f6f00fd45756ae7f39d70f2f1eb1f027c2087694fb3a6ec6b922a868928fb44f9a13b849cd7620f610ac824d506a8792301e7afa8bcacb7a920c0a91badaa567d336de8fd0060c764d4181e7a6ab5de8a1de953abf73563f8beac8f06e4218733a06cc62a24df9a1d889b14dc3c12d8a56c8bb2d5a5c02df690c172ada70711f358cd7a2ea4a373b12e00063df4525f4a1fbfc10b67939ee507c1ca6422919de17e900b1b876ac3c97aa98a861caef7bce279f160a3c11a480a037b437a97da1a96fa350b313df67d73ad98369a9d4a2f358157fec05ecfbb8c6538f60e99f40d9b8f2110ce6b3e3e87e186596a04ba3d208f63f9fad9fdee445aaed52877adecb3d285dfe79e8c4bc90a8463f1089e00d1732c56b0574ade0e7f85c140663d2c0ea700884846ba2d67dd7350cab8b43beb9350ee6a7419137656d305f7cca8675be441f49aea269a6a4766792bff250edf3dd8c4836d431f309beebb13c33d016766bba3868e696acf7197827e034cc3055737665f70d75bd4abd03c6f3b46126679b12defe1d206f1cb6ea611715d46acf4147edec8a01c9edb90d204d0c5f41e275cb3f2a983c1192a2c76ab49133f094bd01c41a5a7622f04deeef4e0071f1cb01d4107b0da54a42f33f23eee50f0362844a07dda2bee84552ea6fe0c802db608b70e384b80c7bbe18fc6a6d0e3fef18e45b86d5f3f171a8be299cdf90540a7c1bd39a5a949edf0e9e658d58f6f879dc4c65cdbe63382c3c0fb0d6cab13a1bfe4bd9a6933d139648c62e2a34e478b94259f23fbee6f28f90873588b6ae57ce27a4773518ae301026b7ab04a93e5dcf1513708b51eae126f17af3f1d0ddc17343c20e5cb46366e33a8d308e9732c1ef307755374c452d97ac6278a78e855729e0db83622e22aab7d2188ceb7d4649b9429cf78fce3e0e536565995e37f6c788d91239b06ef4535337dcd96910ca958259299d4a1c4efa4642b00fef9e9daae5304dcf9f9ae17754e575aea64b26c827ef9635a7be3772c8eab3c69bd0232f67e0d1b12f7a88f2ea7d0bf931f6531500c5b9663e4f99321d37d1a30be62ee8eddd8a28e933c8a3235dcd0b785ed5bd3d47434bd12b73cdb4d9bc731bb72ba3f4568204fa92ec4ac74d75ea2d929d761078b66a5647f701911655a14c346b0a0c7f860757a8b0e189e1991a0ece321105b483e1eadb75ca65ecf677cd288f5f6477913d12efbf8bde3bd4a8996ad57a9f6b7845e7c5979e498c008096504f2cb4d889e21411f500137ba3e7d576626e35991c97061d2eea740368787784c4f894644f461794fb58ca88a8ce4695e49f3569390d3a874179fc690eeeee5e542f3a8516048b701bbd7369f1f1315afa646a7eba94f937f186e7bda964d4eb47fe5a7b553773dbc46c79fae6efd0f2cfcc5b9c2ae9101e836566c48fe6068d1f13a7a153a3fa2bc246400e9f4cce74d1896c7ac5db7345799069d6bd18b6c1781db510816ddecfd2f97181245e07efb82beacb6295289fdfb8ae8206b92611a8c8557bc677ce0f468837130ae20e72a5218bd19b15f02c0f2c021d15ad74cc6f4ef214df5c2b413e9d6e07f2e2a3b8255dfada32fbd2a62a7c714e8a83b2a7bcf3b6ea0439e19f9a279485764b4cc9583c705bc9ad96e1dc226a31b88040cb930683c0c334eda8d181c16ce45eac5d7d98696e05f3d51abb47a321a31a0fccbb3be313cd99aab2a025010034f6c04903316e53029d991cab72890af00d32fb3fee74bc3857c941fb406d5f6a9e501da1a10f649f66d1ee9cecc5ce1b07e4e08a1723e81ba08f302cf60d301f755496afa611def99cb321e79db49e0482efb9f46ec878930c52edb8ff7e64349cb3cf1955c0c344924be8aa3811dc7437baadcf6f900fcd668c7376e9bc5ffbb5527cb70cc6f049c55ee0102c75e812069bc7ddce27d0eb5aae01da8a9636daf13bcf514834e000a74fe5ac524400fa4ea439c9d45703ecd2a393af0cad8c54f4289d9f0e8565f6b0b3687b47e227971517986eab286e4493e4bd2544e3fe5ddfc6c24ed5439fb08588112e7c6e1f200fdfa22d697e83e691c9f28029ed4fd1cf0c05cf5952b11a233ac57c3583278e2029c1045d7db114c520be1e802a82fa536c4bd240313533fe9b261ea3e2b77aaa3918acb67c04b5fa21fb1d47a42053fce3065c4f51e300a3ff4b9c19451c8a97fb4fb767f2db559acc905171e17b9e8848ed0b1332b7bd8258d246ce2ac4082ca38785db3605a1b56bd3f6465645e23f31a120963d5b8c6ede345561ebb19b0377feda5295a52c423b516b8abc3392b8c67caa4a55b08fdd78a8f982b3e8a0cb873addb27ec975b4c658b4dd4d9a08de525a7840a33d45da711bb176628abe6aaebd66916a773555c87f655b888fac9b3b1b1732614bb02c3b521381a0a01c4179abb2fb5b409439ded23e57a2ef52f462e9b0fe8a184d26afff18ada6eacbced43547e1e296318b2586d45e714857ad90ee56551c8a6df5b1762483c617e1826b0028f1d0444ce111984d61d53aa3638eda28b5f4e514e81854715a43fbc355ffc70914e236488a0ffa60d1f2641d94a517a1687c350b21d781be5ab841e9c8a967f78a6a69e1987dae1894852111a1bb9ca582edf8f35229fd17f283143e6f90d63b2a814d7a826e2b1b4764b91799851a78fe43604cefc2147c557dead5bdaf2dbfe74db273cdf88ffeab676f7792ede8829c3cb8660b6ac1dd796bdb787a6f84b38e38bbd6a53bfa9f688e4ea7db62bade7b6cab15e7061f463f388ddb6f5a4626c99a154a152e97216b041be3d0651f9ea0a4e0954dcdcebe2d966c5e3811b4dca12624dc5c1da9c62f60e3128b0041c55bd53141218e4fdeaf0f14955bc677c91b89e90e233badee3029ccfad8359927aff91668c3741ce1c6d267467e2a93eeeacb3d19eb2f0e5a24264893e6a102d47dbfc9943c15980459432a551c065384eb18c59320cf0f09450019cc0fe0afd8083fb0c3a576087d382b40098edd24fb796e6c0fd6c6bb917d3194b53de434c0f966a558174559f93ebd96190df9506f317f99d81d0932c301f72d2827f73581f661a8337e6db071e16bb91db04763a39a0034ddb0bdd63e9ace593d404346fe81f225cfa8923732b93a06dd9a1ba2eaff34bbdd6d4d406d06d92cf37df946597d74908d095d51bf53b50c2ef923f2990646b06f667a36c1409491ad8e6d11329db2124d4f96d9660829d05a246423c695f3814635a9ab399b3877b0441994f2f7845c6a38c074a32574267d43fe861b5176d2dc65ec11d878bbaee73c165e743fbd5c302022c5061635c58dca81000b2b332aaab06f4913df5a575633b7c2db3f73979ac7681711522a26b8f56d1d88e0c412c7753a22ddd885208d7d1e8842c076956b4696c32058dd22ea6fa7d0b4b98cf356de209111ac46d8991e13ed45921cee1c1b1428b5cae1314a9bde2572173e0a68dae99e7b035a8ca41281e8083d81e39621197bd69009643ee445bae2902af6cec74d921504544dbad5eee131245afb5fba5fef4760e8305312b59737ce217f2e5932270b52d773da868a4c3e256a3eb04f0a390e51c04757c6bb46f0d056c8792ba1ced58f3134da30423470327dff5c92f4f3cdb28e7eec0c8c11d3dc5824c08292f4aaab3bdd242de7cc9c36824e07790a3078dc637bdbc06cfd93de49ba3fc66425f0cb4bef224a640e297c97578437d04cc38e124e4a04acff1b21c26b3656c7aefa23de7f52badcdf6fd2bbdfba36fcfe23c7bdeebabe63c68e18ae5f6925cff0f4b5cf669e6141bdf2136fb2adb809c32723331a0f4fbdcdeb022fec45694859171b0221d5b5af7c677730fbe8d7d12a91281a7c6e94cdf19e79486f8c93143a05e76ccda5708580fffb451b2c8d7f9b8d3275538d520feaf2800d639876729fcfaad73501384690b66ee791d000cfbe7fc0872629ba629305e8e78edb292c360ef6ea5163b8920418e11357d13316e9fdaa3c83e1aea266cab1947727f38329436515cd277c306206959236b1ee45dd5d6880d1801359dd57b32b4008e41947f7fd9ae5c92253896022f5418479f8a1596df8bfaed70c101122963415a479a7b88acbbf99c0a34d6a20de756119578d618dc1281c747da5c79205324318a1325149ae5164640e7d517839a6b796739642f7f917ff6ad3989d0fc27cfb1d9db1a352eaa09c0cb107f37d0f7aa88a3bc927a3270f06313c09e03e3f6790a901038be95b72b17997cb684ca0355c16510cd49c0195ee3eb097cd8a776be005bd1e508094e3e28e778f6f934403237482f70c5fd5a9290ed705c8ac22d2cce404a2c109a88de9af594a76bec4915ebc5ba5b60b02244742c3be18acee7e26c45e67866e8aafbbe18c58697c22574ac7dca510b5fe811bb25fe970fff64bbc2052092eee1e4f480638262f414d3cffe7381ea0a2c641065f397be8733da6386b38bb761e7391ddf7d67a050b2a4d1b485a199687ace94ef3f5abb0c0ef30397767015397b9eaa0c32b759290d611679b83323c58d03bc58c7cd6c5947261bc0dfe25366009f8b4ea827ffe26cf106e311a8d0e005c07787a3bc66d429177b7226de368b6d1e054dcf5ade8cda0a45a0adb7e2716ce366132fb3a0526eff6ed78c5a9f404ec4758e2aca3ed576e6565cc60b6894b3165fd114886ec91f164fd66a1345a898831bdf888fa5c3cea01886a8fe53f9c03839d7c97729dbca7f5a5b2593094ac47cba4f66f17a8cce5d9904668c1f4ba87996af1695a02a0073d97f53ec1e5201c822c869096c4e92d253996b4e534f708cbee6dbc437c2d6c6e7d9270d3ad88f0ee10c380ada9e14c1e038f0994c318d539c0e1700a7d6c1be67957c84f55ce083f31bc558d3761453e7b2997428cde91b99e7b3ebe12b1e4b5b73c5b332d227eb37e1ccd9ceee39d119da6a898ecf3a24ea7fbca60d846ede0cc18e8d99c59b07777cfafe77a18ad3617fa7dacf6b7084fa5e85e864487b015fc859cc99ef11a143e1dde592b856ce5c5a18e9cc26f3e84964e8d511f3415b1771b98954c431393d325812e70541603dbef51f29bdbe77125506e33fbd4e4a031c13208e6c2a371c0e74f4b2100491b8605507a566b7305fc83e13355d547f70dbdc610c1b8e845912734b00c24a91ab530aa6bc31d7a78374b26f7578edf75d7b6962646663402c4a1d074c914d1f434c94bfbd2d14ad07853b558f54c725725e199769a03d07e0812d49b35e73e63e5b756d984e6383816001adf4cbd000c76f466d7b04849508516f64a4f5c5a93a22d072baeb713ecb01d275e49a8a2d41ba1c41b90e3c52fd00f1781bbcd48ec1a1095c7734545b045e38790bd86add690b78c1cda80c26c61928437989ce7da05c08fbbb61d2c30249a8a33e598c133d836ed7af32b54809f3399dd4c6d320e2e107a1a2e470fb981ff80a72c8813bc2455b6f4496a484c054868d432e83f6f3cdd760b263fc3160b033e4690bfae638f5275cc43f07306519bc2c9bee1bdce7971df284a0631035907efc9dc3de6f63c287a6e0ec48fc346e110eaa5959c036c9e30b2949f799d39a75b20cc8476d715f1f6282d4f10627ccf5962c3184e1d288eaa4814e87e88723f451e112a938b1c46c0c75b8c206f7f491330203c49e7a14d368d7d0e75d84e989af416c5e7460e20f3968e54587af7fc40d5ce0671f194cbde9176c74a000431a9508385cc3a5c24714c98f2d4bcd1487d5e3cad56ecaa20283b61e05aee991e31d2e23630ab352c4826ca66f885211dd165f75d19fcdbb16a07eb3c5d01a265d197143d65ea7d8124b70364a3a880c6770998fbacb31d9704f6935e839a5249b6c385786f24c189ec3359fdc31709a3f058c2026325ef3faaa2e88f92bc8b415771ca11510d28601a379b2756ef874a72edd5c2756cf8b3dc8194587e56788f87e9611ad3a30e8f81215d8511dd8650429df73073e3f3f2abad57454546e38b2e00af4004d803f2ae76f73075976c823bf88c7202dd2fa2db000afe1ba798386309f90e43dd729e44719e7c5c5201938aa24ee4180734b826f0f025758477e9ff5dd06853de2f090cc6246fb999802d731209e60225c48c31e98d9dbb1bf7b173e61f364aca1f00e550553d71d22dec521056dee031d5219e213372e081edbf7db0c9a32b3751a51e498d48ebbbf0a05af36f8d682f7d5c9ba11eecc323bfdd028ab9278b08f922e35cb4d3949dd00ac4dddbc5b0e309c1368ee00e3e9feed236365e598b7af5ea902987a8bc080aefeb4a2dba0718e2f2f33fc79862feeb1eea95e8f1d2bbe54e8fc993564ce81192af858d2d180d9989f746a3e074c24cd187c826d2cc7fc85e19d7c2a859a6ecf771373e08b1d7758c9ba084a7a618fc9fafdc1f80aeea71a6fb33ad901b2ac289406a5a10bd00d80044b2c8c1aa0f4171c5b398317cc9b5894cacb38bfb9687aaf309f4e6d9cb75348c2ac2815d6e4c1825b655737b258f40320bda6469aaf5f81bc9165ae8e8b581fd09f3f86720061e316ac6537ef98fa740a4ae1a620c1fc5225c6f5dac7cfba8ed5e670fee04dfb1084cd8aaa4d73f4904bdc42c49cc6ad4a72a7da559276294b434524c0eff4701171d4e6658ff469951d0c1dd74e1a0553abc9cc3a3690db1512524f7fa91d4baa8f9dfa1bf3513ac7b4f92d1416cfd7640c0490984166638f4a5df492b73c081a473eaab3e1dbc5b49c1e17a045bd62c8ca95b2db8178bd14c3996379917a7ec36ec567e464439d710460fcac4288e67bd30106fc891abab7b8b3ef017f41fde24997a74dc33cc86154520fe678f261345728afe72eef1a4806efab92c5a16173d332fc8702223614077b4c6e628c30bf1174f7abe4792fe21348771fcee210634875862a012932c8d869476fe5d7f4e365a851b9f2f7add67dbc97c734446b3d0e0127840a627bb7512e397735c9cefb620116585cd9d10a5490b09f68a8a736cf487658f99bad5b27708ace25f0e9daccc88ec422fd54e217194375cc7876f441d7f7f77d63e6b7f36208a82c660b2027dacdff81f14c53f288ca6037a505fba44a33530ac46cb555c9136746206b8a29be646492bf7239778ea02f0016606af297049d10650b4b2cccf36bc06ae80c8504a611e348c65a7dfcfb95ab05acce08c80c6253594e0b9c33b5e20820ec7b15f208294c3a87ed3d019f8041eef69adcea2a35acaf613b0551f371e84bc49c8c34658c97ef2fccc436c338b77bd80bf984e3c53d2baad52f4b1de18462c66f29c42ae3cac015c45bc413fb9dff102e18747f2dfed30043a9d8a9104d511c97f25332fab8b59fc576c4dbf76638fc31ec63e39160edc53cb04e7efc3a55751123a131311d2009476317fcb81b81427000e4e0fe3b3752253e1667148b73013253d98553afd6e53e2b5b65ef1ee177abc3e7995d49739fd0e333911d6b315b32a5be87c55db7583020118bce5e72b123c193ff72c810394f84723c555e1b605d0020a843cc28e771c6db50b5cbfa8959aaf18cbd067cdd08b23604aaf2fc040bb7ba5bac7f5ce48bfa7bd77a7a69d433289a30f2c8d84fe6779faf0d8bc26f762392de37d6f17cd2d0b01ddf30e24dd0b9085ec6e34f2fad6d94e7c73c9ed57793c92bcb6ba6fb695d4a401e4be92b39c2f6952892355da9a9ba982c6419b4755689904742facea4ae7df63769b207c1081c2a141be07f0712fbca00b054c0a3f20a67c444965dd14d97ee316b5bb102ee2ab5caf8a3fe08fb62b75dc5e47e3f51ee8c3dd5d9d00e16133948d95c4ad0c950c76425d614f42199d8fdcaedfef3a62bb71f5326e57f4e483de4d103739d841a1246ddfa109aac99677f7e6808b0c96b05758c17cef356e8cdcf4a93563923d42542911473a00ff75a8c7b82b75a47c7cd861f48da283f89bdbdf9ff2021f1522763e7059358bd4ef8000dd5b73fd027cfa031a07121b2d17b4eccb7213921b84563e8536befd239d78fd68b29a41546243422c2a4519b67e44cbcc9b48f132cf4cc34e8dd0c90cef7302e211e439ab4514286524b3551277c4d98102d8ec2c52944c1b4d36203af03e902662b70a20ff0d1b92a6ab9a001842615e726ee153857146bc43ba99f2e5422062a13198191e187a060f4a77a004d72ed5dc86cc7b978ed266d5816108f52caa360a75d839d0bc7d5ba81eedee9aae12ce62e15046d87c28ca148e4a3f2fcad2cb3295248bb8d6e7098e316d0303232ee39992eb6fddeb02a1b46aee35eeecb891a222f83c9c2977c8de065b2959bb22390d54c73f71005c87e4e65eaa30422536f5587fcd0edda8bee845318afcdd64263a8d3b038fccd14a11c5052971eb089c3f6e9463942988d6b3e00a00d70613322d36d87ea90a085d65a578393dbc736270d2e88603796a9c368044b3e72fedf0be64739349235da4bda283b56b644717a5e2edcde0712b28451428c48e32e0af83d23e3b030883cd359ee56099a9a328d5d765a2d6b4627c278121e0c007d7dde6fc868e6264d47aaee9ee3c3457cc42822abd203f31189e8b5143e0dd76824fdd498f28e3bcb2ad196a856d039eb2c518987d2f32d2d50d45c30cc1a81543404586a9e8e7e36d9425600da266f197fce290d12e530792d48cafdb8cd0dda4eea4773d5a0d33aa3b0739265fe7acba093616e94852e185c0f520638f641b024c877042c5ab8b807f39570e607ff480bc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章（欲知晓请于留言板与我联系）。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Git】更新github指定文件以及git创建分支操作</title>
      <link href="xiao-ji-qiao/5c784c3b9232.html"/>
      <url>xiao-ji-qiao/5c784c3b9232.html</url>
      
        <content type="html"><![CDATA[<h2 id="更新github指定文件"><a href="#更新github指定文件" class="headerlink" title="更新github指定文件"></a>更新github指定文件</h2><p>首先在先前提交的文件中，更新要提交的文件</p><ol><li><code>git add filename</code>（要更新的文件名）</li><li><code>git commit -m 'Update filename'</code></li><li><code>git remote rm origin</code></li><li><code>git remote add origin 地址</code></li><li><code>git pull origin main</code>     // 没有这一步容易出错</li><li><code>git push origin main</code></li></ol><p>参考：</p><ul><li><a href="https://blog.csdn.net/weixin_44046355/article/details/91984584">更新github项目</a></li><li><a href="https://blog.csdn.net/gongqinglin/article/details/79752398?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control">git推送更新出错</a><blockquote><p>为什么<code>git push / push </code>不需要加 <code>-u </code>选项，可以参<a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732864121440">考廖雪峰老师</a>说的：”由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令” ，大致意思就是刚开始创建仓库的时候是空的就需要加，现在我是修改已经存在仓库中的文件就不需要加了</p></blockquote></li></ul><h2 id="git创建分支基本操作"><a href="#git创建分支基本操作" class="headerlink" title="git创建分支基本操作"></a>git创建分支基本操作</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 创建一个新的分支newbranch，并且切换到这个分支上</span><span class="token function">git</span> checkout -b <span class="token variable"><span class="token variable">`</span>newbranch<span class="token variable">`</span></span><span class="token comment"># 注意这个checkout命令如果后面加了`--`之后是撤销修改的意思，例如撤销对readme文件的修改</span><span class="token function">git</span> checkout -- README.md<span class="token comment"># 所以推荐使用switch方法，创建并且切换分支</span><span class="token function">git</span> switch -c new branch<span class="token comment"># 如果分为两步骤 1.创建新分支 2.切换</span><span class="token function">git</span> branch <span class="token variable"><span class="token variable">`</span>newbranch<span class="token variable">`</span></span><span class="token function">git</span> checkout <span class="token variable"><span class="token variable">`</span>newbranch<span class="token variable">`</span></span><span class="token comment"># 通过switch切换</span><span class="token function">git</span> switch <span class="token variable"><span class="token variable">`</span>newbranch<span class="token variable">`</span></span><span class="token comment"># 查看当前分支：会列出所有分支，当前分支前面有一个*号</span><span class="token function">git</span> branch<span class="token comment"># 合并新分支到主分支main上面</span><span class="token function">git</span> merge newbranch<span class="token comment"># 删除分支</span><span class="token function">git</span> branch -d <span class="token variable"><span class="token variable">`</span>newbranch<span class="token variable">`</span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【linux shell】while read line几种方法以及区别</title>
      <link href="yi-cuo-zhi-shi/fbae3676e54e.html"/>
      <url>yi-cuo-zhi-shi/fbae3676e54e.html</url>
      
        <content type="html"><![CDATA[<p><strong>引言</strong>：开始时自己的写的一个下载<a href="https://bing.ioliu.cn/?p=">某个bing网站</a>上面的图片的脚本程序中需要使用while read line读取自己提取出来的图片信息，刚开始没有用临时文件存放信息，而是直接使用管道机制重定向，结果……坑了我一个小时<br>==然后自己查了一些资料，比较一下三种while read line方法的区别==<br>首先自己的test文件如下：（就简单是三行数据）<br><img src="https://img-blog.csdnimg.cn/20200508145856694.png" alt="test文件内容"></p><h2 id="while-read-line三种方法"><a href="#while-read-line三种方法" class="headerlink" title="while-read-line三种方法"></a>while-read-line三种方法</h2><h3 id="1-形如cat-test-while-read-line-do-echo-line-done"><a href="#1-形如cat-test-while-read-line-do-echo-line-done" class="headerlink" title="1. 形如cat test | while read line;do echo $line;done"></a>1. 形如cat test | while read line;do echo $line;done</h3><ul><li>代码如下<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">name1</span><span class="token operator">=</span><span class="token string">"xiaowang"</span><span class="token assign-left variable">date1</span><span class="token operator">=</span><span class="token string">"2020-05-08"</span><span class="token function">cat</span> <span class="token builtin class-name">test</span> <span class="token operator">|</span> <span class="token keyword">while</span> <span class="token builtin class-name">read</span> <span class="token function">date</span><span class="token keyword">do</span>    <span class="token builtin class-name">read</span> url    <span class="token builtin class-name">read</span> name    <span class="token assign-left variable">name1</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$name</span>"</span>    <span class="token assign-left variable">date1</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$date</span>"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$date1</span> <span class="token variable">$name1</span> <span class="token variable">$url</span>"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$date</span> <span class="token variable">$name</span> <span class="token variable">$url</span>"</span><span class="token keyword">done</span><span class="token builtin class-name">echo</span> <span class="token string">"888888 <span class="token variable">$date1</span> 777 <span class="token variable">$name1</span> 666  <span class="token variable">$url</span>"</span></code></pre></li><li>结果输出<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token number">2020</span>-05-07 https://bing.ioliu.cn/photo/WildflowerWeek_ZH-CN4593499387?force<span class="token operator">=</span>download 印克斯湖国家公园中的德克萨斯矢车菊，德克萨斯州<span class="token number">2020</span>-05-07 https://bing.ioliu.cn/photo/WildflowerWeek_ZH-CN4593499387?force<span class="token operator">=</span>download 印克斯湖国家公园中的德克萨斯矢车菊，德克萨斯州<span class="token number">888888</span> <span class="token number">2020</span>-05-08 <span class="token number">777</span> xiaowang <span class="token number">666</span></code></pre></li></ul><p><strong>我想的是使用while read line读取文件之后赋值给name1和date1，结果并没赋值。刚开始很疑惑，明明在while循环中的name1和date1都赋值了为啥退出之后没了呢，结果发现是管道的机制，这个使用管道之后while read line是在子shell中进行的，所以在退出while之后其中的操作都是无效的</strong></p><p>另外，参考一片博客中说的：cat test会一次性将test文件所有数据装入内存，如果test文件足够大，会直接占用巨量内存</p><h3 id="2-形如-while-read-line-lt-test-do-echo-line-done"><a href="#2-形如-while-read-line-lt-test-do-echo-line-done" class="headerlink" title="2.形如 while read line <test;do echo $line;done"></a>2.形如 while read line &lt;test;do echo $line;done</h3><ul><li><p>代码如下</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">name1</span><span class="token operator">=</span><span class="token string">"xiaowang"</span><span class="token assign-left variable">date1</span><span class="token operator">=</span><span class="token string">"2020-05-08"</span><span class="token keyword">while</span> <span class="token builtin class-name">read</span> <span class="token function">date</span> <span class="token operator">&lt;</span> <span class="token builtin class-name">test</span><span class="token keyword">do</span>    <span class="token builtin class-name">read</span> url    <span class="token builtin class-name">read</span> name    <span class="token assign-left variable">name1</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$name</span>"</span>    <span class="token assign-left variable">date1</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$date</span>"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$date1</span> <span class="token variable">$name1</span> <span class="token variable">$url</span>"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$date</span> <span class="token variable">$name</span> <span class="token variable">$url</span>"</span><span class="token keyword">done</span><span class="token builtin class-name">echo</span> <span class="token string">"888888 <span class="token variable">$date1</span> 777 <span class="token variable">$name1</span> 666  <span class="token variable">$url</span>"</span></code></pre></li><li><p>结果如下</p><pre class="language-bash" data-language="bash"><code class="language-bash">   <span class="token number">2020</span>-05-07  <span class="token number">2020</span>-05-07  <span class="token number">2020</span>-05-07  <span class="token number">2020</span>-05-07  <span class="token number">2020</span>-05-07  <span class="token number">2020</span>-05-07  <span class="token punctuation">..</span>.</code></pre></li></ul><p><strong>首先我看不懂这个输出结果（其中的空行全是我自己按的回车，也就是按了两次回车之后才出现结果，然后这个while循环一直不结束…）查说法就是：它会在每次循环的时候都重新打开test文件，使得每次都从头开始读数据，而不是每次从上一次标记的地方继续读数据。</strong></p><h3 id="3-【最佳】形如while-read-line-do-echo-line-done-lt-test"><a href="#3-【最佳】形如while-read-line-do-echo-line-done-lt-test" class="headerlink" title="3.【最佳】形如while read line;do echo $line;done <test"></a>3.【最佳】形如while read line;do echo $line;done &lt;test</h3><ul><li><p>代码如下</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">name1</span><span class="token operator">=</span><span class="token string">"xiaowang"</span><span class="token assign-left variable">date1</span><span class="token operator">=</span><span class="token string">"2020-05-08"</span><span class="token keyword">while</span> <span class="token builtin class-name">read</span> <span class="token function">date</span><span class="token keyword">do</span>    <span class="token builtin class-name">read</span> url    <span class="token builtin class-name">read</span> name    <span class="token assign-left variable">name1</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$name</span>"</span>    <span class="token assign-left variable">date1</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$date</span>"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$date1</span> <span class="token variable">$name1</span> <span class="token variable">$url</span>"</span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$date</span> <span class="token variable">$name</span> <span class="token variable">$url</span>"</span><span class="token keyword">done</span> <span class="token operator">&lt;</span> <span class="token builtin class-name">test</span><span class="token builtin class-name">echo</span> <span class="token string">"888888 <span class="token variable">$date1</span> 777 <span class="token variable">$name1</span> 666  <span class="token variable">$url</span>"</span></code></pre></li><li><p>结果如下（正常了耶）</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token number">2020</span>-05-07 https://bing.ioliu.cn/photo/WildflowerWeek_ZH-CN4593499387?force<span class="token operator">=</span>download 印克斯湖国家公园中的德克萨斯矢车菊，德克萨斯州<span class="token number">2020</span>-05-07 https://bing.ioliu.cn/photo/WildflowerWeek_ZH-CN4593499387?force<span class="token operator">=</span>download 印克斯湖国家公园中的德克萨斯矢车菊，德克萨斯州<span class="token number">888888</span> <span class="token number">2020</span>-05-07 <span class="token number">777</span> https://bing.ioliu.cn/photo/WildflowerWeek_ZH-CN4593499387?force<span class="token operator">=</span>download <span class="token number">666</span>  印克斯湖国家公园中的德克萨斯矢车菊，德克萨斯州</code></pre></li></ul><p><strong>这个不就是我想要的结果吗，使用输入重定向的方式则每次只占用一行数据的内存，而且是在当前shell环境下执行的，while内的变量赋值、数组赋值在退出while后仍然有效。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>以上三种方法中，大家在选取的时候最好选择第三那种方法，别问为什么问。</li><li>其实读取文件内容的方法有很多，比如使用形如：for line in $(&lt;file); do echo ​$line; done的方法，据说这种方法效率最高，具体可以参考<a href="https://blog.csdn.net/u014650722/article/details/51563823">这篇博客</a>，这个说了几种while read和for的比较。</li><li>另外如果想要了解我那个下载图片的脚本程序可以访问<a href="https://github.com/EricPengShuai/Linux-Shell-netstat--s-And-download-photos">我的github</a></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/xl-892694298/p/11017168.html">https://www.cnblogs.com/xl-892694298/p/11017168.html</a><br><a href="https://blog.csdn.net/u014650722/article/details/51563823">https://blog.csdn.net/u014650722/article/details/51563823</a></p>]]></content>
      
      
      <categories>
          
          <category> 易错知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WireShark】成功解决WireShark没有发现端口，Win10pcap和Npcap安装失败</title>
      <link href="chang-jian-bao-cuo/40828016f13e.html"/>
      <url>chang-jian-bao-cuo/40828016f13e.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><h3 id="引言："><a href="#引言：" class="headerlink" title="引言："></a><strong>引言</strong>：</h3><p>wireshark是去年安装的，大约一年没用了，现在一打开发现<strong>“没有发现接口”</strong>，本来是要通过抓包了解IPV6分组机制（分片扩展首部），结果蒙了…下面说一下整个解决过程</p><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a><strong>原因</strong>：</h3><p>没有<a href="https://www.cnblogs.com/cc1840/p/10074686.html">Npcap或者Winpcap</a>，这里大家可能想知道这两个有啥区别，总体上是Npcap是现在的新型Windows网络数据包截获软件，替代了Winpcap，现在安装wireshark的时候一般都会安装Npcap的，具体区别<a href="https://blog.csdn.net/hsluoyc/article/details/46483151">传送门</a></p><ol><li><p>首先<strong>卸载你电脑中的Npcap或者Winpcap</strong>（这个已经不完整了），具体清理过程<a href="https://blog.csdn.net/hs_err_log/article/details/79646455">传送门</a></p></li><li><p>开始我查CSDN上面的说法是<strong>下载Win10pcap</strong>，这里<a href="http://www.win10pcap.org/download/">附链接</a>，不知道为什么我总是安装失败（可能自己环境确实有点问题，不过你们可以试试）</p></li><li><p>然后我又尝试<strong>安装Npcap</strong>（一般的wireshark文件夹中都会有这个的安装程序）<br><img src="https://img-blog.csdnimg.cn/20200403185450956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="wireshark安装目录"><br>如果你安装成功，那么恭喜你，你欧气爆棚，但是我是没有安装上的，总是提示<br><img src="https://img-blog.csdnimg.cn/20200403185619214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="安装Npcap失败"></p></li></ol><p> <strong>关于这个错误网上说法很多：有可能是自己的Npcap没有卸载干净、还有可能你改变了路径、另外就是他自己说的版本太低……</strong><br> 前两个我试了还是不行<br> 然后我又<strong>下载了最新版本的Npcap</strong>，这里附上<a href="https://nmap.org/download.html">官网</a>，然后重新安装，结果还是报错，气得我…..直接把wireshark卸载了（以为我去年这个版本已经不行了，然后去<a href="https://www.wireshark.org/download.html">官网</a>下载最新的版本），然后把之前的工作又重新做了一遍，所以结果还是一样不行！！！！心态崩了</p><ol start="4"><li>将之前安装的Npcap重新卸载之后，<strong>百度了一下WinPcap，结果发现了新大陆</strong>，在<a href="https://www.winpcap.org/install/default.htm">WinPcap官网下载</a>了WinPcap，傻瓜式下载安装竟然ok了，然后打开<strong>wireshark竟然看到了接口</strong>，我人没了【具体为什么之前的Win10Pcap不行而这个可以我也不知道，注意这个我用的是WinPcap】<br><img src="https://img-blog.csdnimg.cn/20200403191932344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="WinPcap主页"></li></ol><h3 id="结束："><a href="#结束：" class="headerlink" title="结束："></a><strong>结束</strong>：</h3><p>然后我又可以快乐的用wireshark抓包了</p>]]></content>
      
      
      <categories>
          
          <category> 常见报错 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WireShark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【WXG后端实习面试题】去除驼峰字符串</title>
      <link href="suan-fa/aa9cbe7520ab.html"/>
      <url>suan-fa/aa9cbe7520ab.html</url>
      
        <content type="html"><![CDATA[<p>今天面试了一个腾讯微信后台，说了几句就说弄一个题做一下，结果一脸懵逼，给定字符串，去除其中的驼峰字符串（例如：将“AaAdfAAaAaA”变成“df”）。</p><p>说实话对于<strong>驼峰串</strong>这个定义就有点模糊，本来当时有点紧张，有时在牛客网上做题，他别是那个面试官看着你做题，我当时脑子真的就是一片空白，这个驼峰串仅仅是两个大写字母中间夹一个小字母吗？能不能是两个小字母夹一个大写字母呢？（毕竟这个<strong>aAa</strong>也像驼峰）总之面试是gg了，之后网上看了一些解答，自己总结一下。</p><ul><li>首先对于第一种情况：驼峰串仅仅是两个大写字母中间夹一个小字母，形如AaA<pre class="language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token string">'AaAdfaAaAaAaAaB'</span><span class="token builtin">len</span> <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s字符串长度："</span> <span class="token operator">%</span> <span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">)</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">:</span>    <span class="token comment"># 遇到驼峰</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">and</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">and</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">2</span>        i <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 如果没有驼峰并且不是之前识别驼峰的最后一个字母就打印</span>    <span class="token keyword">elif</span> i <span class="token operator">!=</span> j<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">'  '</span><span class="token punctuation">)</span>    i <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token builtin">len</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">:</span>    <span class="token comment"># 对于像'AaAdfAaAaAaAaA'这样的串处理最后两个字符不要打印</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">and</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">and</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 对于像"AaAdfAaAaAaAaB"、"AaAdfaAaAaAaAaB"这样的串特殊处理最后两个字符</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>调试结果如下：<br><img src="https://img-blog.csdnimg.cn/20200331225824935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020033122565815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>其次对于第二种情况：形如AaA、aAa都可以当成驼峰串<pre class="language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token string">'AaAdfAaAaAaAaA'</span><span class="token builtin">len</span> <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"字符串长度："</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">)</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> i <span class="token operator">&lt;</span> <span class="token builtin">len</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">:</span>    <span class="token comment"># 遇到驼峰</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">and</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">2</span>        i <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 如果没有驼峰并且不是之前识别驼峰的最后一个字母就打印</span>    <span class="token keyword">elif</span> i <span class="token operator">!=</span> j<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">'  '</span><span class="token punctuation">)</span>    i <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token builtin">len</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">:</span>    <span class="token comment"># 对于像'AaAdfAaAaAaAaA'这样的串处理最后两个字符不要打印</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">and</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token comment"># 对于像"AaAdfaAaAaAaAaB"这样的字符串特殊处理最后一个字符</span>    <span class="token keyword">elif</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">and</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment"># 对于像'AaAdfAaAaAaAaaa'这样的串特殊处理最后两个字符,另外对于这种情况是不是有点问题</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>调试结果如下：<br><img src="https://img-blog.csdnimg.cn/20200331223036784.png" alt="测试结果1"><br><img src="https://img-blog.csdnimg.cn/20200331222927502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="测试结果2"><br><img src="https://img-blog.csdnimg.cn/20200331223319160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="测试结果3"></li></ul><p><strong>总结</strong>：其实这个算法的核心就是<strong>while循环</strong>部分：其中j的作用很巧妙，配合i的增加做到了对每个驼峰串的识别</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【分治法】解决循环赛问题（n分为奇数和偶数）</title>
      <link href="suan-fa/1741f76a1a4e.html"/>
      <url>suan-fa/1741f76a1a4e.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设有N个运动员要进行网球循环赛，设计一个满足以下要求的比赛日程表</p><ol><li>每个选手必须与其他n-1个选手各赛一次；</li><li>每个选手一天只能赛一次；</li><li>当n 是偶数，循环赛进行n-1简单天，当n是奇数，循环赛进行n天。</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-首先考虑简单问题（n-2-k）"><a href="#1-首先考虑简单问题（n-2-k）" class="headerlink" title="1. 首先考虑简单问题（n = 2^k）"></a>1. 首先考虑简单问题（n = 2^k）</h3><p>这个我先上一个图大家应该就可以明白：</p><p><img src="https://img-blog.csdnimg.cn/20191024222342845.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="第1列为选手，第2-8列为赛程，8个选手赛7天"></p><p>应该很容易想到分治法，有如下规律：对于任意一个正方形区域（包括4、16……个小方块）左上角和右下角相等，右上角和左下角相等（<strong>如果懒得看汉字就直接看上面几种颜色的方块吧</strong>）</p><p><img src="/pic/divide.jpg" alt="n=8"></p><blockquote><p>按分治策略，我们可以将所有的选手分为两半，则n个选手的比赛日程表可以通过n/2个选手的比赛日程表来决定。递归地用这种一分为二的策略对选手进行划分，直到只剩下两个选手时，比赛日程表的制定就变得很简单。这时只要让这两个选手进行比赛就可以了。如上图，所列出的正方形表是8个选手的比赛日程表。其中左上角与左下角的两小块分别为选手1至选手4和选手5至选手8前3天的比赛日程。据此，将左上角小块中的所有数字按其相对位置抄到右下角，又将左下角小块中的所有数字按其相对位置抄到右上角，这样我们就分别安排好了选手1至选手4和选手5至选手8在后4天的比赛日程。</p></blockquote><p>然后这个代码也很容易：</p><ul><li><input disabled="" type="checkbox"> 非递归（k是2上面的次数）<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">SetTable</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//初始化左上角数</span>    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//然后分治安排</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span>   <span class="token comment">//len = 2^i</span>        <span class="token keyword">int</span> half <span class="token operator">=</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>         <span class="token comment">//左下角子表就是左上角子表加上half</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> half<span class="token punctuation">;</span> row <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> row <span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> half<span class="token punctuation">;</span> col <span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                a<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>row <span class="token operator">-</span> half<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">+</span> half<span class="token punctuation">;</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//右上角子表就是左下角子表</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> row <span class="token operator">&lt;</span> half<span class="token punctuation">;</span> row <span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> half<span class="token punctuation">;</span> col <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> col <span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                a<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>row <span class="token operator">+</span> half<span class="token punctuation">]</span><span class="token punctuation">[</span>col <span class="token operator">-</span> half<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//右下角子表就是左上角子表</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> half<span class="token punctuation">;</span> row <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> row <span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> half<span class="token punctuation">;</span> col <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> col <span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                a<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>row <span class="token operator">-</span> half<span class="token punctuation">]</span><span class="token punctuation">[</span>col <span class="token operator">-</span> half<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><input disabled="" type="checkbox"> 递归（n是比赛总人数，这里先考虑简单的n = 2^k）<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">tourna</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tourna</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">copy</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            a<span class="token punctuation">[</span>i <span class="token operator">+</span> m<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> m<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//右下角</span>            a<span class="token punctuation">[</span>i <span class="token operator">+</span> m<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> m<span class="token punctuation">;</span>  <span class="token comment">//左下角</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> m<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> m<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//右上角</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="2-衍生到一般的偶数（如果n不是2的次方）"><a href="#2-衍生到一般的偶数（如果n不是2的次方）" class="headerlink" title="2. 衍生到一般的偶数（如果n不是2的次方）"></a>2. 衍生到一般的偶数（如果n不是2的次方）</h3><p>举一个例子（n=6），既然是分治法，按照大的思路，我们把tourna(6, a)问题转换成tourna(3, a)【这里的你们就先看成是上面的tourna函数】，那么问题又来了，n=3怎么解决呢？（自然引出了奇数的问题，那我们直接考虑下面的奇数问题，这里大家可以直接跳到第三种情况看，看完之后回看这一点）</p><p>我们可以将6分为（1 2 3）和（4 5 6）我们且看两者单独考虑的赛程：<br><img src="https://img-blog.csdnimg.cn/2019102423094673.PNG" alt="（1 2 3）赛程"> <img src="https://img-blog.csdnimg.cn/20191024231411687.PNG" alt="（4  5  6）赛程">  </p><ul><li>考虑到（1 2 3）（4 5  6）“1和4”的第四列（第三天），只有一号选手和四号选手没比赛，那就让他们比，同理还有2和5，3和6，推出如下图【左图】</li><li>再来分析【右图】，第一行由于（1 5）（1 6）没比赛，后面就填他们，对应的也有（5 1）（6 1），再看第二行可以是（2 4）（2 6），由于6在第五天和1比赛了，所以应该是先填（2 6）然后（2 4），对应的也有（6 2）（4 2）；后面同理。</li></ul><blockquote><p>其实我感觉这个就是找规律好吗，<del>和分治法有“桃子”关系</del> </p></blockquote><p><img src="https://img-blog.csdnimg.cn/20191024232029757.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="找规律"></p><h3 id="3-n为奇数"><a href="#3-n为奇数" class="headerlink" title="3. n为奇数"></a>3. n为奇数</h3><ul><li>考虑到题目中有n天时间比赛，自然想到n = 4 的情况（看下图）</li></ul><blockquote><p> 这个是4个人比赛3天的情况，现在如果只有3个人，那么岂不是正好是3天，我们仅仅需要将其中的4改变为0（看下图），代表选手那天空闲就可</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20191024224244591.PNG" alt="n = 4">                            <img src="https://img-blog.csdnimg.cn/20191024225923228.PNG" alt="n = 3"></p><ul><li>其实对于一般的奇数，我们都可以转换成相应的n + 1，变成偶数再分治求解，最终递归到尽头就是n = 3（然后我们回到第二问）</li></ul><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">//n为奇数时候的输出</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                    cout <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>  cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> n<span class="token punctuation">)</span>                    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                <span class="token keyword">else</span>                    cout <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token comment">//n为偶数时候的输出</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>                    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                <span class="token keyword">else</span>                    cout <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">//cout &lt;&lt; m &lt;&lt; endl;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            a<span class="token punctuation">[</span>i <span class="token operator">+</span> m<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> m<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//右下角</span>            a<span class="token punctuation">[</span>i <span class="token operator">+</span> m<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> m<span class="token punctuation">;</span>  <span class="token comment">//左下角</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> m<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> m<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//右上角</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">copyodd</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> m <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// 4 5 6</span>        b<span class="token punctuation">[</span>m <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 4 5 6</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token comment">//改写左上角和填写右下角</span>        <span class="token punctuation">{</span>   <span class="token comment">//这里如果你硬要说什么解释的话，我也说不出啥来，我看来就是找规律</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> m<span class="token punctuation">)</span>             <span class="token punctuation">{</span>                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                a<span class="token punctuation">[</span>m <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> m<span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> a<span class="token punctuation">[</span>m <span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> m<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token comment">//填写右上角和对应的右下角</span>        <span class="token punctuation">{</span>   <span class="token comment">//这里我当时是把 n = 6作为特例带进去一个一个是试出规律来的</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>b<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">makecopy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">copyodd</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">copy</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">tourna</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token function">tourna</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//奇数+1变成偶数</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tourna</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//分治</span>    <span class="token function">makecopy</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    cin <span class="token operator">&gt;&gt;</span>n<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token operator">*</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//分配空间</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">tourna</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">output</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token operator">*</span>n<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//delete空间</span>        <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>a<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 分治法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Qt】运行qt生成的exe文件报“无法找到Qt5network.dll等组件”“无法找到入口”的问题</title>
      <link href="chang-jian-bao-cuo/d47d18d8b526.html"/>
      <url>chang-jian-bao-cuo/d47d18d8b526.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><p>我在Qt creator上面构建好项目之后生成了exe文件（在debug中），我想直接在qt creator之外运行时候就报“什么缺少一些插件的错误”，我查了一些资料，说是要设置什么环境变量path，然后我也设置了好了，如下：<br><img src="https://img-blog.csdnimg.cn/20190502175006195.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="添加环境变量path"><br> 然后我就运行，也是报错什么“无法找到入口”：如下（有几个错误，弄一个）<br> <img src="https://img-blog.csdnimg.cn/20190502175307908.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="无法找到入口"><br>然后查了一些资料之后说是要把那个环境变量放到上面几个（为了一次成功，<strong>我直接把那个环境变量置顶</strong>）<br><img src="https://img-blog.csdnimg.cn/20190502175634356.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pcmFjbGVfcHM=,size_16,color_FFFFFF,t_70" alt="🔝环境变量"><br>然后保存好设置之后就可以运行了。</p>]]></content>
      
      
      <categories>
          
          <category> 常见报错 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
